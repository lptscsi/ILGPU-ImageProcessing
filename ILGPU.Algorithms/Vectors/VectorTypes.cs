// ---------------------------------------------------------------------------------------
//                                   ILGPU Algorithms
//                           Copyright (c) 2023 ILGPU Project
//                                    www.ilgpu.net
//
// File: VectorTypes.tt/VectorTypes.cs
//
// This file is part of ILGPU and is distributed under the University of Illinois Open
// Source License. See LICENSE.txt for details.
// ---------------------------------------------------------------------------------------

// ---------------------------------------------------------------------------------------
//                                   ILGPU Algorithms
//                        Copyright (c) 2020-2021 ILGPU Project
//                                    www.ilgpu.net
//
// File: TypeInformation.ttinclude
//
// This file is part of ILGPU and is distributed under the University of Illinois Open
// Source License. See LICENSE.txt for details.
// ---------------------------------------------------------------------------------------

// ---------------------------------------------------------------------------------------
//                                        ILGPU
//                        Copyright (c) 2016-2024 ILGPU Project
//                                    www.ilgpu.net
//
// File: TypeInformation.ttinclude
//
// This file is part of ILGPU and is distributed under the University of Illinois Open
// Source License. See LICENSE.txt for details.
// ---------------------------------------------------------------------------------------

using ILGPU.Algorithms.Random;
using ILGPU.Runtime;
using System;
using System.Globalization;
using System.Numerics;
using System.Runtime.CompilerServices;

#if NET7_0_OR_GREATER

// disable: max_line_length

#pragma warning disable IDE0004 // Cast is redundant
#pragma warning disable CA2225 // Friendly operator names

namespace ILGPU.Algorithms.Vectors
{
    /// <summary>
    /// Represents a vectorized sbyte type with length 2.
    /// </summary>
    [CLSCompliant(false)]
    public readonly record struct Int8x2(
        sbyte X, sbyte Y) :
        IVectorType<Int8x2, sbyte>
    {
        /// <summary>
        /// The offset of the X field in bytes.
        /// </summary>
        public static readonly int OffsetX =
            sizeof(sbyte) * 0;

        /// <summary>
        /// The offset of the X field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrX =>
            new UIntPtr((uint)OffsetX);
        /// <summary>
        /// The offset of the Y field in bytes.
        /// </summary>
        public static readonly int OffsetY =
            sizeof(sbyte) * 1;

        /// <summary>
        /// The offset of the Y field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrY =>
            new UIntPtr((uint)OffsetY);

        /// <summary>
        /// Returns the length of this vector which is 2.
        /// </summary>
        public static int Length => 2;

        /// <summary>
        /// Returns the radix of the underlying value.
        /// </summary>
        public static int Radix => 10;

        /// <summary>
        /// Returns an invalid value (min [signed types], max value [unsigned] or NaN).
        /// </summary>
        public static Int8x2 Invalid => FromScalar(
            sbyte.MinValue
        );

        /// <summary>
        /// Returns the value zero.
        /// </summary>
        public static Int8x2 Zero => new();

        /// <summary>
        /// Returns the value one.
        /// </summary>
        public static Int8x2 One => FromScalar((1));

        /// <summary>
        /// Returns the value zero.
        /// </summary>
        public static Int8x2 AdditiveIdentity => Zero;

        /// <summary>
        /// Returns the value one.
        /// </summary>
        public static Int8x2 MultiplicativeIdentity => One;

        /// <summary>
        /// Computes the min value of both.
        /// </summary>
        /// <param name="first">The first value.</param>
        /// <param name="second">The second value.</param>
        /// <returns>The min value.</returns>
        public static Int8x2 Min(
            Int8x2 first,
            Int8x2 second) =>
            new Int8x2((sbyte)Math.Min(first.X, second.X), (sbyte)Math.Min(first.Y, second.Y));

        /// <summary>
        /// Computes the max value of both.
        /// </summary>
        /// <param name="first">The first value.</param>
        /// <param name="second">The second value.</param>
        /// <returns>The max value.</returns>
        public static Int8x2 Max(
            Int8x2 first,
            Int8x2 second) =>
            new Int8x2((sbyte)Math.Max(first.X, second.X), (sbyte)Math.Max(first.Y, second.Y));

        /// <summary>
        /// Clamps the given value.
        /// </summary>
        /// <param name="value">The value to clamp.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The clamped value.</returns>
        public static Int8x2 Clamp(
            Int8x2 value,
            Int8x2 min,
            Int8x2 max) =>
            Max(Min(value, max), min);

        /// <summary>
        /// Creates a random scalar instance falling into the range of min max.
        /// </summary>
        /// <param name="random">The random provider to use.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The created random scalar instance.</returns>
        public static sbyte GetRandomScalar<TRandom>(
            ref TRandom random,
            sbyte min,
            sbyte max)
            where TRandom : struct, IRandomProvider =>
            (sbyte)RandomExtensions.
                Next(ref random, min, max);

        /// <summary>
        /// Creates a random vector instance falling into the range of min max.
        /// </summary>
        /// <param name="random">The random provider to use.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The created random vector instance.</returns>
        public static Int8x2 GetRandom<TRandom>(
            ref TRandom random,
            Int8x2 min,
            Int8x2 max)
            where TRandom : struct, IRandomProvider
        {
            sbyte x = GetRandomScalar(
                ref random, min.X, max.X);
            sbyte y = GetRandomScalar(
                ref random, min.Y, max.Y);
            return new Int8x2(x, y);
        }

        /// <summary>
        /// Creates a vector instance from the given source view.
        /// </summary>
        /// <typeparam name="TStride">The custom stride type.</typeparam>
        /// <param name="sourceView">The source view.</param>
        /// <param name="index">The source base index.</param>
        /// <returns>The vector instance.</returns>
        public static Int8x2 FromElementView<TStride>(
            ArrayView1D<sbyte, TStride> sourceView,
            Index1D index)
            where TStride : struct, IStride1D =>
            new Int8x2(
                sourceView[index + 0],
                sourceView[index + 1]
                );

        /// <summary>
        /// Serializes the current vector instance into the given target view.
        /// </summary>
        /// <typeparam name="TStride">The custom stride type.</typeparam>
        /// <param name="targetView">The target view.</param>
        /// <param name="index">The target base index.</param>
        public void ToElementView<TStride>(
            ArrayView1D<sbyte, TStride> targetView,
            Index1D index)
            where TStride : struct, IStride1D
        {
            targetView[index + 0] = X;
            targetView[index + 1] = Y;
        }

        /// <summary>
        /// Creates a vector instance from the given source view.
        /// </summary>
        /// <param name="sourceView">The source view.</param>
        /// <param name="index">The source base index.</param>
        /// <returns>The vector instance.</returns>
        public static Int8x2 FromElementView(
            SingleVectorView<sbyte> sourceView,
            Index1D index) =>
            new Int8x2(
                sourceView[index + 0],
                sourceView[index + 1]
                );

        /// <summary>
        /// Serializes the current vector instance into the given target view.
        /// </summary>
        /// <param name="targetView">The target view.</param>
        /// <param name="index">The target base index.</param>
        public void ToElementView(
            SingleVectorView<sbyte> targetView,
            Index1D index)
        {
            targetView[index + 0] = X;
            targetView[index + 1] = Y;
        }

        /// <summary>
        /// Converts a scalar value into the current vectorized type.
        /// </summary>
        /// <param name="scalar">The scalar element type.</param>
        /// <returns>The created vectorized type.</returns>
        public static Int8x2 FromScalar(sbyte scalar) =>
            new Int8x2(scalar, scalar);

        /// <summary>
        /// Converts this instance into an unsafe span instance.
        /// </summary>
        /// <returns>The readonly span instance.</returns>
        public unsafe ReadOnlySpan<sbyte> AsSpan() =>
            new(Unsafe.AsPointer(ref Unsafe.AsRef(this)), 2);

        /// <summary>
        /// Iterates over all elements by applying the given iterator to each element.
        /// </summary>
        /// <typeparam name="TIterator">The managed iterator type.</typeparam>
        /// <param name="iterator">The iterator to invoke.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ForEach<TIterator>(ref TIterator iterator)
            where TIterator : struct, IVectorElementIterator<
            Int8x2,
            sbyte>
        {
            iterator.Iterate(X, 0);
            iterator.Iterate(Y, 1);
        }

        /// <summary>
        /// Converts this vector instance to a string.
        /// </summary>
        public override string ToString() =>
            $"{X}, {Y}";

        /// <summary>
        /// Converts this vector instance to a string.
        /// </summary>
        public string ToString(string? format, IFormatProvider? formatProvider) =>
            $"{X.ToString(format, formatProvider)}, {Y.ToString(format, formatProvider)}";

        /// <summary>
        /// Returns true.
        /// </summary>
        public static bool IsCanonical(Int8x2 value) => true;

        /// <summary>
        /// Returns false.
        /// </summary>
        public static bool IsComplexNumber(Int8x2 value) => false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsEvenInteger(Int8x2 value) =>
            sbyte.IsEvenInteger(value.X) & sbyte.IsEvenInteger(value.Y);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsFinite(Int8x2 value) =>
            true;

        /// <summary>
        /// Returns false.
        /// </summary>
        public static bool IsImaginaryNumber(Int8x2 value) => false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsInfinity(Int8x2 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsInteger(Int8x2 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNaN(Int8x2 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNegative(Int8x2 value) =>
            sbyte.IsNegative(value.X) & sbyte.IsNegative(value.Y);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNegativeInfinity(Int8x2 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNormal(Int8x2 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsOddInteger(Int8x2 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsPositive(Int8x2 value) =>
            sbyte.IsPositive(value.X) & sbyte.IsPositive(value.Y);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsPositiveInfinity(Int8x2 value) =>
            false;

        /// <summary>
        /// Returns true.
        /// </summary>
        public static bool IsRealNumber(Int8x2 value) => true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsSubnormal(Int8x2 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsZero(Int8x2 value) =>
            value == Zero;

        /// <summary>
        /// Returns the absolute value.
        /// </summary>
        public static Int8x2 Abs(Int8x2 value) =>
            new Int8x2(Math.Abs(value.X), Math.Abs(value.Y));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int8x2 operator +(Int8x2 left, Int8x2 right) =>
            new Int8x2((sbyte)(left.X + right.X), (sbyte)(left.Y + right.Y));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int8x2 operator --(Int8x2 value) => value - One;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int8x2 operator /(Int8x2 left, Int8x2 right) =>
            new Int8x2((sbyte)(left.X / right.X), (sbyte)(left.Y / right.Y));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int8x2 operator ++(Int8x2 value) => value + One;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int8x2 operator *(Int8x2 left, Int8x2 right) =>
            new Int8x2((sbyte)(left.X * right.X), (sbyte)(left.Y * right.Y));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int8x2 operator -(Int8x2 left, Int8x2 right) =>
            new Int8x2((sbyte)(left.X - right.X), (sbyte)(left.Y - right.Y));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int8x2 operator -(Int8x2 value) =>
            new Int8x2((sbyte)-value.X, (sbyte)-value.Y);

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int8x2 operator +(Int8x2 value) => value;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int8x2 MaxMagnitude(Int8x2 x, Int8x2 y) =>
            new Int8x2(sbyte.MaxMagnitude(x.X, y.X), sbyte.MaxMagnitude(x.Y, y.Y));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int8x2 MaxMagnitudeNumber(Int8x2 x, Int8x2 y) =>
            MaxMagnitude(x, y);

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int8x2 MinMagnitude(Int8x2 x, Int8x2 y) =>
            new Int8x2(sbyte.MinMagnitude(x.X, y.X), sbyte.MinMagnitude(x.Y, y.Y));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int8x2 MinMagnitudeNumber(Int8x2 x, Int8x2 y) =>
            MinMagnitude(x, y);

        // Not supported operations

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static Int8x2 IParsable<Int8x2>.Parse(
            string s,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static Int8x2 ISpanParsable<Int8x2>.Parse(
            ReadOnlySpan<char> s,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static Int8x2 INumberBase<Int8x2>.Parse(
            ReadOnlySpan<char> s,
            NumberStyles style,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static Int8x2 INumberBase<Int8x2>.Parse(
            string s,
            NumberStyles style,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        bool ISpanFormattable.TryFormat(
            Span<char> destination,
            out int charsWritten,
            ReadOnlySpan<char> format,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool IParsable<Int8x2>.TryParse(
            string? s,
            IFormatProvider? provider,
            out Int8x2 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given span into a vectorized instance.
        /// </summary>
        static bool ISpanParsable<Int8x2>.TryParse(
            ReadOnlySpan<char> s,
            IFormatProvider? provider,
            out Int8x2 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool INumberBase<Int8x2>.TryParse(
            ReadOnlySpan<char> s,
            NumberStyles style,
            IFormatProvider? provider,
            out Int8x2 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool INumberBase<Int8x2>.TryParse(
            string? s,
            NumberStyles style,
            IFormatProvider? provider,
            out Int8x2 result) =>
            throw new NotSupportedException();

        static bool INumberBase<Int8x2>.TryConvertFromChecked<TOther>(
            TOther value,
            out Int8x2 result) =>
            throw new NotSupportedException();
        static bool INumberBase<Int8x2>.TryConvertFromSaturating<TOther>(
            TOther value,
            out Int8x2 result) =>
            throw new NotSupportedException();
        static bool INumberBase<Int8x2>.TryConvertFromTruncating<TOther>(
            TOther value,
            out Int8x2 result) =>
            throw new NotSupportedException();
        static bool INumberBase<Int8x2>.TryConvertToChecked<TOther>(
            Int8x2 value,
            out TOther result) =>
            throw new NotSupportedException();
        static bool INumberBase<Int8x2>.TryConvertToSaturating<TOther>(
            Int8x2 value,
            out TOther result) =>
            throw new NotSupportedException();
        static bool INumberBase<Int8x2>.TryConvertToTruncating<TOther>(
            Int8x2 value,
            out TOther result) =>
            throw new NotSupportedException();
    }

    /// <summary>
    /// Represents a vectorized sbyte type with length 4.
    /// </summary>
    [CLSCompliant(false)]
    public readonly record struct Int8x4(
        sbyte X, sbyte Y, sbyte Z, sbyte W) :
        IVectorType<Int8x4, sbyte>
    {
        /// <summary>
        /// The offset of the X field in bytes.
        /// </summary>
        public static readonly int OffsetX =
            sizeof(sbyte) * 0;

        /// <summary>
        /// The offset of the X field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrX =>
            new UIntPtr((uint)OffsetX);
        /// <summary>
        /// The offset of the Y field in bytes.
        /// </summary>
        public static readonly int OffsetY =
            sizeof(sbyte) * 1;

        /// <summary>
        /// The offset of the Y field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrY =>
            new UIntPtr((uint)OffsetY);
        /// <summary>
        /// The offset of the Z field in bytes.
        /// </summary>
        public static readonly int OffsetZ =
            sizeof(sbyte) * 2;

        /// <summary>
        /// The offset of the Z field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrZ =>
            new UIntPtr((uint)OffsetZ);
        /// <summary>
        /// The offset of the W field in bytes.
        /// </summary>
        public static readonly int OffsetW =
            sizeof(sbyte) * 3;

        /// <summary>
        /// The offset of the W field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrW =>
            new UIntPtr((uint)OffsetW);

        /// <summary>
        /// Returns the length of this vector which is 4.
        /// </summary>
        public static int Length => 4;

        /// <summary>
        /// Returns the radix of the underlying value.
        /// </summary>
        public static int Radix => 10;

        /// <summary>
        /// Returns an invalid value (min [signed types], max value [unsigned] or NaN).
        /// </summary>
        public static Int8x4 Invalid => FromScalar(
            sbyte.MinValue
        );

        /// <summary>
        /// Returns the value zero.
        /// </summary>
        public static Int8x4 Zero => new();

        /// <summary>
        /// Returns the value one.
        /// </summary>
        public static Int8x4 One => FromScalar((1));

        /// <summary>
        /// Returns the value zero.
        /// </summary>
        public static Int8x4 AdditiveIdentity => Zero;

        /// <summary>
        /// Returns the value one.
        /// </summary>
        public static Int8x4 MultiplicativeIdentity => One;

        /// <summary>
        /// Computes the min value of both.
        /// </summary>
        /// <param name="first">The first value.</param>
        /// <param name="second">The second value.</param>
        /// <returns>The min value.</returns>
        public static Int8x4 Min(
            Int8x4 first,
            Int8x4 second) =>
            new Int8x4((sbyte)Math.Min(first.X, second.X), (sbyte)Math.Min(first.Y, second.Y), (sbyte)Math.Min(first.Z, second.Z), (sbyte)Math.Min(first.W, second.W));

        /// <summary>
        /// Computes the max value of both.
        /// </summary>
        /// <param name="first">The first value.</param>
        /// <param name="second">The second value.</param>
        /// <returns>The max value.</returns>
        public static Int8x4 Max(
            Int8x4 first,
            Int8x4 second) =>
            new Int8x4((sbyte)Math.Max(first.X, second.X), (sbyte)Math.Max(first.Y, second.Y), (sbyte)Math.Max(first.Z, second.Z), (sbyte)Math.Max(first.W, second.W));

        /// <summary>
        /// Clamps the given value.
        /// </summary>
        /// <param name="value">The value to clamp.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The clamped value.</returns>
        public static Int8x4 Clamp(
            Int8x4 value,
            Int8x4 min,
            Int8x4 max) =>
            Max(Min(value, max), min);

        /// <summary>
        /// Creates a random scalar instance falling into the range of min max.
        /// </summary>
        /// <param name="random">The random provider to use.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The created random scalar instance.</returns>
        public static sbyte GetRandomScalar<TRandom>(
            ref TRandom random,
            sbyte min,
            sbyte max)
            where TRandom : struct, IRandomProvider =>
            (sbyte)RandomExtensions.
                Next(ref random, min, max);

        /// <summary>
        /// Creates a random vector instance falling into the range of min max.
        /// </summary>
        /// <param name="random">The random provider to use.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The created random vector instance.</returns>
        public static Int8x4 GetRandom<TRandom>(
            ref TRandom random,
            Int8x4 min,
            Int8x4 max)
            where TRandom : struct, IRandomProvider
        {
            sbyte x = GetRandomScalar(
                ref random, min.X, max.X);
            sbyte y = GetRandomScalar(
                ref random, min.Y, max.Y);
            sbyte z = GetRandomScalar(
                ref random, min.Z, max.Z);
            sbyte w = GetRandomScalar(
                ref random, min.W, max.W);
            return new Int8x4(x, y, z, w);
        }

        /// <summary>
        /// Creates a vector instance from the given source view.
        /// </summary>
        /// <typeparam name="TStride">The custom stride type.</typeparam>
        /// <param name="sourceView">The source view.</param>
        /// <param name="index">The source base index.</param>
        /// <returns>The vector instance.</returns>
        public static Int8x4 FromElementView<TStride>(
            ArrayView1D<sbyte, TStride> sourceView,
            Index1D index)
            where TStride : struct, IStride1D =>
            new Int8x4(
                sourceView[index + 0],
                sourceView[index + 1],
                sourceView[index + 2],
                sourceView[index + 3]
                );

        /// <summary>
        /// Serializes the current vector instance into the given target view.
        /// </summary>
        /// <typeparam name="TStride">The custom stride type.</typeparam>
        /// <param name="targetView">The target view.</param>
        /// <param name="index">The target base index.</param>
        public void ToElementView<TStride>(
            ArrayView1D<sbyte, TStride> targetView,
            Index1D index)
            where TStride : struct, IStride1D
        {
            targetView[index + 0] = X;
            targetView[index + 1] = Y;
            targetView[index + 2] = Z;
            targetView[index + 3] = W;
        }

        /// <summary>
        /// Creates a vector instance from the given source view.
        /// </summary>
        /// <param name="sourceView">The source view.</param>
        /// <param name="index">The source base index.</param>
        /// <returns>The vector instance.</returns>
        public static Int8x4 FromElementView(
            SingleVectorView<sbyte> sourceView,
            Index1D index) =>
            new Int8x4(
                sourceView[index + 0],
                sourceView[index + 1],
                sourceView[index + 2],
                sourceView[index + 3]
                );

        /// <summary>
        /// Serializes the current vector instance into the given target view.
        /// </summary>
        /// <param name="targetView">The target view.</param>
        /// <param name="index">The target base index.</param>
        public void ToElementView(
            SingleVectorView<sbyte> targetView,
            Index1D index)
        {
            targetView[index + 0] = X;
            targetView[index + 1] = Y;
            targetView[index + 2] = Z;
            targetView[index + 3] = W;
        }

        /// <summary>
        /// Converts a scalar value into the current vectorized type.
        /// </summary>
        /// <param name="scalar">The scalar element type.</param>
        /// <returns>The created vectorized type.</returns>
        public static Int8x4 FromScalar(sbyte scalar) =>
            new Int8x4(scalar, scalar, scalar, scalar);

        /// <summary>
        /// Converts this instance into an unsafe span instance.
        /// </summary>
        /// <returns>The readonly span instance.</returns>
        public unsafe ReadOnlySpan<sbyte> AsSpan() =>
            new(Unsafe.AsPointer(ref Unsafe.AsRef(this)), 4);

        /// <summary>
        /// Iterates over all elements by applying the given iterator to each element.
        /// </summary>
        /// <typeparam name="TIterator">The managed iterator type.</typeparam>
        /// <param name="iterator">The iterator to invoke.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ForEach<TIterator>(ref TIterator iterator)
            where TIterator : struct, IVectorElementIterator<
            Int8x4,
            sbyte>
        {
            iterator.Iterate(X, 0);
            iterator.Iterate(Y, 1);
            iterator.Iterate(Z, 2);
            iterator.Iterate(W, 3);
        }

        /// <summary>
        /// Converts this vector instance to a string.
        /// </summary>
        public override string ToString() =>
            $"{X}, {Y}, {Z}, {W}";

        /// <summary>
        /// Converts this vector instance to a string.
        /// </summary>
        public string ToString(string? format, IFormatProvider? formatProvider) =>
            $"{X.ToString(format, formatProvider)}, {Y.ToString(format, formatProvider)}, {Z.ToString(format, formatProvider)}, {W.ToString(format, formatProvider)}";

        /// <summary>
        /// Returns true.
        /// </summary>
        public static bool IsCanonical(Int8x4 value) => true;

        /// <summary>
        /// Returns false.
        /// </summary>
        public static bool IsComplexNumber(Int8x4 value) => false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsEvenInteger(Int8x4 value) =>
            sbyte.IsEvenInteger(value.X) & sbyte.IsEvenInteger(value.Y) & sbyte.IsEvenInteger(value.Z) & sbyte.IsEvenInteger(value.W);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsFinite(Int8x4 value) =>
            true;

        /// <summary>
        /// Returns false.
        /// </summary>
        public static bool IsImaginaryNumber(Int8x4 value) => false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsInfinity(Int8x4 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsInteger(Int8x4 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNaN(Int8x4 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNegative(Int8x4 value) =>
            sbyte.IsNegative(value.X) & sbyte.IsNegative(value.Y) & sbyte.IsNegative(value.Z) & sbyte.IsNegative(value.W);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNegativeInfinity(Int8x4 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNormal(Int8x4 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsOddInteger(Int8x4 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsPositive(Int8x4 value) =>
            sbyte.IsPositive(value.X) & sbyte.IsPositive(value.Y) & sbyte.IsPositive(value.Z) & sbyte.IsPositive(value.W);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsPositiveInfinity(Int8x4 value) =>
            false;

        /// <summary>
        /// Returns true.
        /// </summary>
        public static bool IsRealNumber(Int8x4 value) => true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsSubnormal(Int8x4 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsZero(Int8x4 value) =>
            value == Zero;

        /// <summary>
        /// Returns the absolute value.
        /// </summary>
        public static Int8x4 Abs(Int8x4 value) =>
            new Int8x4(Math.Abs(value.X), Math.Abs(value.Y), Math.Abs(value.Z), Math.Abs(value.W));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int8x4 operator +(Int8x4 left, Int8x4 right) =>
            new Int8x4((sbyte)(left.X + right.X), (sbyte)(left.Y + right.Y), (sbyte)(left.Z + right.Z), (sbyte)(left.W + right.W));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int8x4 operator --(Int8x4 value) => value - One;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int8x4 operator /(Int8x4 left, Int8x4 right) =>
            new Int8x4((sbyte)(left.X / right.X), (sbyte)(left.Y / right.Y), (sbyte)(left.Z / right.Z), (sbyte)(left.W / right.W));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int8x4 operator ++(Int8x4 value) => value + One;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int8x4 operator *(Int8x4 left, Int8x4 right) =>
            new Int8x4((sbyte)(left.X * right.X), (sbyte)(left.Y * right.Y), (sbyte)(left.Z * right.Z), (sbyte)(left.W * right.W));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int8x4 operator -(Int8x4 left, Int8x4 right) =>
            new Int8x4((sbyte)(left.X - right.X), (sbyte)(left.Y - right.Y), (sbyte)(left.Z - right.Z), (sbyte)(left.W - right.W));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int8x4 operator -(Int8x4 value) =>
            new Int8x4((sbyte)-value.X, (sbyte)-value.Y, (sbyte)-value.Z, (sbyte)-value.W);

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int8x4 operator +(Int8x4 value) => value;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int8x4 MaxMagnitude(Int8x4 x, Int8x4 y) =>
            new Int8x4(sbyte.MaxMagnitude(x.X, y.X), sbyte.MaxMagnitude(x.Y, y.Y), sbyte.MaxMagnitude(x.Z, y.Z), sbyte.MaxMagnitude(x.W, y.W));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int8x4 MaxMagnitudeNumber(Int8x4 x, Int8x4 y) =>
            MaxMagnitude(x, y);

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int8x4 MinMagnitude(Int8x4 x, Int8x4 y) =>
            new Int8x4(sbyte.MinMagnitude(x.X, y.X), sbyte.MinMagnitude(x.Y, y.Y), sbyte.MinMagnitude(x.Z, y.Z), sbyte.MinMagnitude(x.W, y.W));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int8x4 MinMagnitudeNumber(Int8x4 x, Int8x4 y) =>
            MinMagnitude(x, y);

        // Not supported operations

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static Int8x4 IParsable<Int8x4>.Parse(
            string s,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static Int8x4 ISpanParsable<Int8x4>.Parse(
            ReadOnlySpan<char> s,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static Int8x4 INumberBase<Int8x4>.Parse(
            ReadOnlySpan<char> s,
            NumberStyles style,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static Int8x4 INumberBase<Int8x4>.Parse(
            string s,
            NumberStyles style,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        bool ISpanFormattable.TryFormat(
            Span<char> destination,
            out int charsWritten,
            ReadOnlySpan<char> format,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool IParsable<Int8x4>.TryParse(
            string? s,
            IFormatProvider? provider,
            out Int8x4 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given span into a vectorized instance.
        /// </summary>
        static bool ISpanParsable<Int8x4>.TryParse(
            ReadOnlySpan<char> s,
            IFormatProvider? provider,
            out Int8x4 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool INumberBase<Int8x4>.TryParse(
            ReadOnlySpan<char> s,
            NumberStyles style,
            IFormatProvider? provider,
            out Int8x4 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool INumberBase<Int8x4>.TryParse(
            string? s,
            NumberStyles style,
            IFormatProvider? provider,
            out Int8x4 result) =>
            throw new NotSupportedException();

        static bool INumberBase<Int8x4>.TryConvertFromChecked<TOther>(
            TOther value,
            out Int8x4 result) =>
            throw new NotSupportedException();
        static bool INumberBase<Int8x4>.TryConvertFromSaturating<TOther>(
            TOther value,
            out Int8x4 result) =>
            throw new NotSupportedException();
        static bool INumberBase<Int8x4>.TryConvertFromTruncating<TOther>(
            TOther value,
            out Int8x4 result) =>
            throw new NotSupportedException();
        static bool INumberBase<Int8x4>.TryConvertToChecked<TOther>(
            Int8x4 value,
            out TOther result) =>
            throw new NotSupportedException();
        static bool INumberBase<Int8x4>.TryConvertToSaturating<TOther>(
            Int8x4 value,
            out TOther result) =>
            throw new NotSupportedException();
        static bool INumberBase<Int8x4>.TryConvertToTruncating<TOther>(
            Int8x4 value,
            out TOther result) =>
            throw new NotSupportedException();
    }

    /// <summary>
    /// Represents a vectorized sbyte type with length 8.
    /// </summary>
    [CLSCompliant(false)]
    public readonly record struct Int8x8(
        sbyte X, sbyte Y, sbyte Z, sbyte W, sbyte I, sbyte J, sbyte K, sbyte L) :
        IVectorType<Int8x8, sbyte>
    {
        /// <summary>
        /// The offset of the X field in bytes.
        /// </summary>
        public static readonly int OffsetX =
            sizeof(sbyte) * 0;

        /// <summary>
        /// The offset of the X field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrX =>
            new UIntPtr((uint)OffsetX);
        /// <summary>
        /// The offset of the Y field in bytes.
        /// </summary>
        public static readonly int OffsetY =
            sizeof(sbyte) * 1;

        /// <summary>
        /// The offset of the Y field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrY =>
            new UIntPtr((uint)OffsetY);
        /// <summary>
        /// The offset of the Z field in bytes.
        /// </summary>
        public static readonly int OffsetZ =
            sizeof(sbyte) * 2;

        /// <summary>
        /// The offset of the Z field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrZ =>
            new UIntPtr((uint)OffsetZ);
        /// <summary>
        /// The offset of the W field in bytes.
        /// </summary>
        public static readonly int OffsetW =
            sizeof(sbyte) * 3;

        /// <summary>
        /// The offset of the W field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrW =>
            new UIntPtr((uint)OffsetW);
        /// <summary>
        /// The offset of the I field in bytes.
        /// </summary>
        public static readonly int OffsetI =
            sizeof(sbyte) * 4;

        /// <summary>
        /// The offset of the I field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrI =>
            new UIntPtr((uint)OffsetI);
        /// <summary>
        /// The offset of the J field in bytes.
        /// </summary>
        public static readonly int OffsetJ =
            sizeof(sbyte) * 5;

        /// <summary>
        /// The offset of the J field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrJ =>
            new UIntPtr((uint)OffsetJ);
        /// <summary>
        /// The offset of the K field in bytes.
        /// </summary>
        public static readonly int OffsetK =
            sizeof(sbyte) * 6;

        /// <summary>
        /// The offset of the K field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrK =>
            new UIntPtr((uint)OffsetK);
        /// <summary>
        /// The offset of the L field in bytes.
        /// </summary>
        public static readonly int OffsetL =
            sizeof(sbyte) * 7;

        /// <summary>
        /// The offset of the L field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrL =>
            new UIntPtr((uint)OffsetL);

        /// <summary>
        /// Returns the length of this vector which is 8.
        /// </summary>
        public static int Length => 8;

        /// <summary>
        /// Returns the radix of the underlying value.
        /// </summary>
        public static int Radix => 10;

        /// <summary>
        /// Returns an invalid value (min [signed types], max value [unsigned] or NaN).
        /// </summary>
        public static Int8x8 Invalid => FromScalar(
            sbyte.MinValue
        );

        /// <summary>
        /// Returns the value zero.
        /// </summary>
        public static Int8x8 Zero => new();

        /// <summary>
        /// Returns the value one.
        /// </summary>
        public static Int8x8 One => FromScalar((1));

        /// <summary>
        /// Returns the value zero.
        /// </summary>
        public static Int8x8 AdditiveIdentity => Zero;

        /// <summary>
        /// Returns the value one.
        /// </summary>
        public static Int8x8 MultiplicativeIdentity => One;

        /// <summary>
        /// Computes the min value of both.
        /// </summary>
        /// <param name="first">The first value.</param>
        /// <param name="second">The second value.</param>
        /// <returns>The min value.</returns>
        public static Int8x8 Min(
            Int8x8 first,
            Int8x8 second) =>
            new Int8x8((sbyte)Math.Min(first.X, second.X), (sbyte)Math.Min(first.Y, second.Y), (sbyte)Math.Min(first.Z, second.Z), (sbyte)Math.Min(first.W, second.W), (sbyte)Math.Min(first.I, second.I), (sbyte)Math.Min(first.J, second.J), (sbyte)Math.Min(first.K, second.K), (sbyte)Math.Min(first.L, second.L));

        /// <summary>
        /// Computes the max value of both.
        /// </summary>
        /// <param name="first">The first value.</param>
        /// <param name="second">The second value.</param>
        /// <returns>The max value.</returns>
        public static Int8x8 Max(
            Int8x8 first,
            Int8x8 second) =>
            new Int8x8((sbyte)Math.Max(first.X, second.X), (sbyte)Math.Max(first.Y, second.Y), (sbyte)Math.Max(first.Z, second.Z), (sbyte)Math.Max(first.W, second.W), (sbyte)Math.Max(first.I, second.I), (sbyte)Math.Max(first.J, second.J), (sbyte)Math.Max(first.K, second.K), (sbyte)Math.Max(first.L, second.L));

        /// <summary>
        /// Clamps the given value.
        /// </summary>
        /// <param name="value">The value to clamp.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The clamped value.</returns>
        public static Int8x8 Clamp(
            Int8x8 value,
            Int8x8 min,
            Int8x8 max) =>
            Max(Min(value, max), min);

        /// <summary>
        /// Creates a random scalar instance falling into the range of min max.
        /// </summary>
        /// <param name="random">The random provider to use.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The created random scalar instance.</returns>
        public static sbyte GetRandomScalar<TRandom>(
            ref TRandom random,
            sbyte min,
            sbyte max)
            where TRandom : struct, IRandomProvider =>
            (sbyte)RandomExtensions.
                Next(ref random, min, max);

        /// <summary>
        /// Creates a random vector instance falling into the range of min max.
        /// </summary>
        /// <param name="random">The random provider to use.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The created random vector instance.</returns>
        public static Int8x8 GetRandom<TRandom>(
            ref TRandom random,
            Int8x8 min,
            Int8x8 max)
            where TRandom : struct, IRandomProvider
        {
            sbyte x = GetRandomScalar(
                ref random, min.X, max.X);
            sbyte y = GetRandomScalar(
                ref random, min.Y, max.Y);
            sbyte z = GetRandomScalar(
                ref random, min.Z, max.Z);
            sbyte w = GetRandomScalar(
                ref random, min.W, max.W);
            sbyte i = GetRandomScalar(
                ref random, min.I, max.I);
            sbyte j = GetRandomScalar(
                ref random, min.J, max.J);
            sbyte k = GetRandomScalar(
                ref random, min.K, max.K);
            sbyte l = GetRandomScalar(
                ref random, min.L, max.L);
            return new Int8x8(x, y, z, w, i, j, k, l);
        }

        /// <summary>
        /// Creates a vector instance from the given source view.
        /// </summary>
        /// <typeparam name="TStride">The custom stride type.</typeparam>
        /// <param name="sourceView">The source view.</param>
        /// <param name="index">The source base index.</param>
        /// <returns>The vector instance.</returns>
        public static Int8x8 FromElementView<TStride>(
            ArrayView1D<sbyte, TStride> sourceView,
            Index1D index)
            where TStride : struct, IStride1D =>
            new Int8x8(
                sourceView[index + 0],
                sourceView[index + 1],
                sourceView[index + 2],
                sourceView[index + 3],
                sourceView[index + 4],
                sourceView[index + 5],
                sourceView[index + 6],
                sourceView[index + 7]
                );

        /// <summary>
        /// Serializes the current vector instance into the given target view.
        /// </summary>
        /// <typeparam name="TStride">The custom stride type.</typeparam>
        /// <param name="targetView">The target view.</param>
        /// <param name="index">The target base index.</param>
        public void ToElementView<TStride>(
            ArrayView1D<sbyte, TStride> targetView,
            Index1D index)
            where TStride : struct, IStride1D
        {
            targetView[index + 0] = X;
            targetView[index + 1] = Y;
            targetView[index + 2] = Z;
            targetView[index + 3] = W;
            targetView[index + 4] = I;
            targetView[index + 5] = J;
            targetView[index + 6] = K;
            targetView[index + 7] = L;
        }

        /// <summary>
        /// Creates a vector instance from the given source view.
        /// </summary>
        /// <param name="sourceView">The source view.</param>
        /// <param name="index">The source base index.</param>
        /// <returns>The vector instance.</returns>
        public static Int8x8 FromElementView(
            SingleVectorView<sbyte> sourceView,
            Index1D index) =>
            new Int8x8(
                sourceView[index + 0],
                sourceView[index + 1],
                sourceView[index + 2],
                sourceView[index + 3],
                sourceView[index + 4],
                sourceView[index + 5],
                sourceView[index + 6],
                sourceView[index + 7]
                );

        /// <summary>
        /// Serializes the current vector instance into the given target view.
        /// </summary>
        /// <param name="targetView">The target view.</param>
        /// <param name="index">The target base index.</param>
        public void ToElementView(
            SingleVectorView<sbyte> targetView,
            Index1D index)
        {
            targetView[index + 0] = X;
            targetView[index + 1] = Y;
            targetView[index + 2] = Z;
            targetView[index + 3] = W;
            targetView[index + 4] = I;
            targetView[index + 5] = J;
            targetView[index + 6] = K;
            targetView[index + 7] = L;
        }

        /// <summary>
        /// Converts a scalar value into the current vectorized type.
        /// </summary>
        /// <param name="scalar">The scalar element type.</param>
        /// <returns>The created vectorized type.</returns>
        public static Int8x8 FromScalar(sbyte scalar) =>
            new Int8x8(scalar, scalar, scalar, scalar, scalar, scalar, scalar, scalar);

        /// <summary>
        /// Converts this instance into an unsafe span instance.
        /// </summary>
        /// <returns>The readonly span instance.</returns>
        public unsafe ReadOnlySpan<sbyte> AsSpan() =>
            new(Unsafe.AsPointer(ref Unsafe.AsRef(this)), 8);

        /// <summary>
        /// Iterates over all elements by applying the given iterator to each element.
        /// </summary>
        /// <typeparam name="TIterator">The managed iterator type.</typeparam>
        /// <param name="iterator">The iterator to invoke.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ForEach<TIterator>(ref TIterator iterator)
            where TIterator : struct, IVectorElementIterator<
            Int8x8,
            sbyte>
        {
            iterator.Iterate(X, 0);
            iterator.Iterate(Y, 1);
            iterator.Iterate(Z, 2);
            iterator.Iterate(W, 3);
            iterator.Iterate(I, 4);
            iterator.Iterate(J, 5);
            iterator.Iterate(K, 6);
            iterator.Iterate(L, 7);
        }

        /// <summary>
        /// Converts this vector instance to a string.
        /// </summary>
        public override string ToString() =>
            $"{X}, {Y}, {Z}, {W}, {I}, {J}, {K}, {L}";

        /// <summary>
        /// Converts this vector instance to a string.
        /// </summary>
        public string ToString(string? format, IFormatProvider? formatProvider) =>
            $"{X.ToString(format, formatProvider)}, {Y.ToString(format, formatProvider)}, {Z.ToString(format, formatProvider)}, {W.ToString(format, formatProvider)}, {I.ToString(format, formatProvider)}, {J.ToString(format, formatProvider)}, {K.ToString(format, formatProvider)}, {L.ToString(format, formatProvider)}";

        /// <summary>
        /// Returns true.
        /// </summary>
        public static bool IsCanonical(Int8x8 value) => true;

        /// <summary>
        /// Returns false.
        /// </summary>
        public static bool IsComplexNumber(Int8x8 value) => false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsEvenInteger(Int8x8 value) =>
            sbyte.IsEvenInteger(value.X) & sbyte.IsEvenInteger(value.Y) & sbyte.IsEvenInteger(value.Z) & sbyte.IsEvenInteger(value.W) & sbyte.IsEvenInteger(value.I) & sbyte.IsEvenInteger(value.J) & sbyte.IsEvenInteger(value.K) & sbyte.IsEvenInteger(value.L);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsFinite(Int8x8 value) =>
            true;

        /// <summary>
        /// Returns false.
        /// </summary>
        public static bool IsImaginaryNumber(Int8x8 value) => false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsInfinity(Int8x8 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsInteger(Int8x8 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNaN(Int8x8 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNegative(Int8x8 value) =>
            sbyte.IsNegative(value.X) & sbyte.IsNegative(value.Y) & sbyte.IsNegative(value.Z) & sbyte.IsNegative(value.W) & sbyte.IsNegative(value.I) & sbyte.IsNegative(value.J) & sbyte.IsNegative(value.K) & sbyte.IsNegative(value.L);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNegativeInfinity(Int8x8 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNormal(Int8x8 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsOddInteger(Int8x8 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsPositive(Int8x8 value) =>
            sbyte.IsPositive(value.X) & sbyte.IsPositive(value.Y) & sbyte.IsPositive(value.Z) & sbyte.IsPositive(value.W) & sbyte.IsPositive(value.I) & sbyte.IsPositive(value.J) & sbyte.IsPositive(value.K) & sbyte.IsPositive(value.L);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsPositiveInfinity(Int8x8 value) =>
            false;

        /// <summary>
        /// Returns true.
        /// </summary>
        public static bool IsRealNumber(Int8x8 value) => true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsSubnormal(Int8x8 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsZero(Int8x8 value) =>
            value == Zero;

        /// <summary>
        /// Returns the absolute value.
        /// </summary>
        public static Int8x8 Abs(Int8x8 value) =>
            new Int8x8(Math.Abs(value.X), Math.Abs(value.Y), Math.Abs(value.Z), Math.Abs(value.W), Math.Abs(value.I), Math.Abs(value.J), Math.Abs(value.K), Math.Abs(value.L));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int8x8 operator +(Int8x8 left, Int8x8 right) =>
            new Int8x8((sbyte)(left.X + right.X), (sbyte)(left.Y + right.Y), (sbyte)(left.Z + right.Z), (sbyte)(left.W + right.W), (sbyte)(left.I + right.I), (sbyte)(left.J + right.J), (sbyte)(left.K + right.K), (sbyte)(left.L + right.L));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int8x8 operator --(Int8x8 value) => value - One;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int8x8 operator /(Int8x8 left, Int8x8 right) =>
            new Int8x8((sbyte)(left.X / right.X), (sbyte)(left.Y / right.Y), (sbyte)(left.Z / right.Z), (sbyte)(left.W / right.W), (sbyte)(left.I / right.I), (sbyte)(left.J / right.J), (sbyte)(left.K / right.K), (sbyte)(left.L / right.L));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int8x8 operator ++(Int8x8 value) => value + One;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int8x8 operator *(Int8x8 left, Int8x8 right) =>
            new Int8x8((sbyte)(left.X * right.X), (sbyte)(left.Y * right.Y), (sbyte)(left.Z * right.Z), (sbyte)(left.W * right.W), (sbyte)(left.I * right.I), (sbyte)(left.J * right.J), (sbyte)(left.K * right.K), (sbyte)(left.L * right.L));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int8x8 operator -(Int8x8 left, Int8x8 right) =>
            new Int8x8((sbyte)(left.X - right.X), (sbyte)(left.Y - right.Y), (sbyte)(left.Z - right.Z), (sbyte)(left.W - right.W), (sbyte)(left.I - right.I), (sbyte)(left.J - right.J), (sbyte)(left.K - right.K), (sbyte)(left.L - right.L));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int8x8 operator -(Int8x8 value) =>
            new Int8x8((sbyte)-value.X, (sbyte)-value.Y, (sbyte)-value.Z, (sbyte)-value.W, (sbyte)-value.I, (sbyte)-value.J, (sbyte)-value.K, (sbyte)-value.L);

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int8x8 operator +(Int8x8 value) => value;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int8x8 MaxMagnitude(Int8x8 x, Int8x8 y) =>
            new Int8x8(sbyte.MaxMagnitude(x.X, y.X), sbyte.MaxMagnitude(x.Y, y.Y), sbyte.MaxMagnitude(x.Z, y.Z), sbyte.MaxMagnitude(x.W, y.W), sbyte.MaxMagnitude(x.I, y.I), sbyte.MaxMagnitude(x.J, y.J), sbyte.MaxMagnitude(x.K, y.K), sbyte.MaxMagnitude(x.L, y.L));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int8x8 MaxMagnitudeNumber(Int8x8 x, Int8x8 y) =>
            MaxMagnitude(x, y);

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int8x8 MinMagnitude(Int8x8 x, Int8x8 y) =>
            new Int8x8(sbyte.MinMagnitude(x.X, y.X), sbyte.MinMagnitude(x.Y, y.Y), sbyte.MinMagnitude(x.Z, y.Z), sbyte.MinMagnitude(x.W, y.W), sbyte.MinMagnitude(x.I, y.I), sbyte.MinMagnitude(x.J, y.J), sbyte.MinMagnitude(x.K, y.K), sbyte.MinMagnitude(x.L, y.L));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int8x8 MinMagnitudeNumber(Int8x8 x, Int8x8 y) =>
            MinMagnitude(x, y);

        // Not supported operations

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static Int8x8 IParsable<Int8x8>.Parse(
            string s,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static Int8x8 ISpanParsable<Int8x8>.Parse(
            ReadOnlySpan<char> s,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static Int8x8 INumberBase<Int8x8>.Parse(
            ReadOnlySpan<char> s,
            NumberStyles style,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static Int8x8 INumberBase<Int8x8>.Parse(
            string s,
            NumberStyles style,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        bool ISpanFormattable.TryFormat(
            Span<char> destination,
            out int charsWritten,
            ReadOnlySpan<char> format,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool IParsable<Int8x8>.TryParse(
            string? s,
            IFormatProvider? provider,
            out Int8x8 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given span into a vectorized instance.
        /// </summary>
        static bool ISpanParsable<Int8x8>.TryParse(
            ReadOnlySpan<char> s,
            IFormatProvider? provider,
            out Int8x8 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool INumberBase<Int8x8>.TryParse(
            ReadOnlySpan<char> s,
            NumberStyles style,
            IFormatProvider? provider,
            out Int8x8 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool INumberBase<Int8x8>.TryParse(
            string? s,
            NumberStyles style,
            IFormatProvider? provider,
            out Int8x8 result) =>
            throw new NotSupportedException();

        static bool INumberBase<Int8x8>.TryConvertFromChecked<TOther>(
            TOther value,
            out Int8x8 result) =>
            throw new NotSupportedException();
        static bool INumberBase<Int8x8>.TryConvertFromSaturating<TOther>(
            TOther value,
            out Int8x8 result) =>
            throw new NotSupportedException();
        static bool INumberBase<Int8x8>.TryConvertFromTruncating<TOther>(
            TOther value,
            out Int8x8 result) =>
            throw new NotSupportedException();
        static bool INumberBase<Int8x8>.TryConvertToChecked<TOther>(
            Int8x8 value,
            out TOther result) =>
            throw new NotSupportedException();
        static bool INumberBase<Int8x8>.TryConvertToSaturating<TOther>(
            Int8x8 value,
            out TOther result) =>
            throw new NotSupportedException();
        static bool INumberBase<Int8x8>.TryConvertToTruncating<TOther>(
            Int8x8 value,
            out TOther result) =>
            throw new NotSupportedException();
    }

    /// <summary>
    /// Represents a vectorized short type with length 2.
    /// </summary>
    public readonly record struct Int16x2(
        short X, short Y) :
        IVectorType<Int16x2, short>
    {
        /// <summary>
        /// The offset of the X field in bytes.
        /// </summary>
        public static readonly int OffsetX =
            sizeof(short) * 0;

        /// <summary>
        /// The offset of the X field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrX =>
            new UIntPtr((uint)OffsetX);
        /// <summary>
        /// The offset of the Y field in bytes.
        /// </summary>
        public static readonly int OffsetY =
            sizeof(short) * 1;

        /// <summary>
        /// The offset of the Y field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrY =>
            new UIntPtr((uint)OffsetY);

        /// <summary>
        /// Returns the length of this vector which is 2.
        /// </summary>
        public static int Length => 2;

        /// <summary>
        /// Returns the radix of the underlying value.
        /// </summary>
        public static int Radix => 10;

        /// <summary>
        /// Returns an invalid value (min [signed types], max value [unsigned] or NaN).
        /// </summary>
        public static Int16x2 Invalid => FromScalar(
            short.MinValue
        );

        /// <summary>
        /// Returns the value zero.
        /// </summary>
        public static Int16x2 Zero => new();

        /// <summary>
        /// Returns the value one.
        /// </summary>
        public static Int16x2 One => FromScalar((1));

        /// <summary>
        /// Returns the value zero.
        /// </summary>
        public static Int16x2 AdditiveIdentity => Zero;

        /// <summary>
        /// Returns the value one.
        /// </summary>
        public static Int16x2 MultiplicativeIdentity => One;

        /// <summary>
        /// Computes the min value of both.
        /// </summary>
        /// <param name="first">The first value.</param>
        /// <param name="second">The second value.</param>
        /// <returns>The min value.</returns>
        public static Int16x2 Min(
            Int16x2 first,
            Int16x2 second) =>
            new Int16x2((short)Math.Min(first.X, second.X), (short)Math.Min(first.Y, second.Y));

        /// <summary>
        /// Computes the max value of both.
        /// </summary>
        /// <param name="first">The first value.</param>
        /// <param name="second">The second value.</param>
        /// <returns>The max value.</returns>
        public static Int16x2 Max(
            Int16x2 first,
            Int16x2 second) =>
            new Int16x2((short)Math.Max(first.X, second.X), (short)Math.Max(first.Y, second.Y));

        /// <summary>
        /// Clamps the given value.
        /// </summary>
        /// <param name="value">The value to clamp.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The clamped value.</returns>
        public static Int16x2 Clamp(
            Int16x2 value,
            Int16x2 min,
            Int16x2 max) =>
            Max(Min(value, max), min);

        /// <summary>
        /// Creates a random scalar instance falling into the range of min max.
        /// </summary>
        /// <param name="random">The random provider to use.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The created random scalar instance.</returns>
        public static short GetRandomScalar<TRandom>(
            ref TRandom random,
            short min,
            short max)
            where TRandom : struct, IRandomProvider =>
            (short)RandomExtensions.
                Next(ref random, min, max);

        /// <summary>
        /// Creates a random vector instance falling into the range of min max.
        /// </summary>
        /// <param name="random">The random provider to use.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The created random vector instance.</returns>
        public static Int16x2 GetRandom<TRandom>(
            ref TRandom random,
            Int16x2 min,
            Int16x2 max)
            where TRandom : struct, IRandomProvider
        {
            short x = GetRandomScalar(
                ref random, min.X, max.X);
            short y = GetRandomScalar(
                ref random, min.Y, max.Y);
            return new Int16x2(x, y);
        }

        /// <summary>
        /// Creates a vector instance from the given source view.
        /// </summary>
        /// <typeparam name="TStride">The custom stride type.</typeparam>
        /// <param name="sourceView">The source view.</param>
        /// <param name="index">The source base index.</param>
        /// <returns>The vector instance.</returns>
        public static Int16x2 FromElementView<TStride>(
            ArrayView1D<short, TStride> sourceView,
            Index1D index)
            where TStride : struct, IStride1D =>
            new Int16x2(
                sourceView[index + 0],
                sourceView[index + 1]
                );

        /// <summary>
        /// Serializes the current vector instance into the given target view.
        /// </summary>
        /// <typeparam name="TStride">The custom stride type.</typeparam>
        /// <param name="targetView">The target view.</param>
        /// <param name="index">The target base index.</param>
        public void ToElementView<TStride>(
            ArrayView1D<short, TStride> targetView,
            Index1D index)
            where TStride : struct, IStride1D
        {
            targetView[index + 0] = X;
            targetView[index + 1] = Y;
        }

        /// <summary>
        /// Creates a vector instance from the given source view.
        /// </summary>
        /// <param name="sourceView">The source view.</param>
        /// <param name="index">The source base index.</param>
        /// <returns>The vector instance.</returns>
        public static Int16x2 FromElementView(
            SingleVectorView<short> sourceView,
            Index1D index) =>
            new Int16x2(
                sourceView[index + 0],
                sourceView[index + 1]
                );

        /// <summary>
        /// Serializes the current vector instance into the given target view.
        /// </summary>
        /// <param name="targetView">The target view.</param>
        /// <param name="index">The target base index.</param>
        public void ToElementView(
            SingleVectorView<short> targetView,
            Index1D index)
        {
            targetView[index + 0] = X;
            targetView[index + 1] = Y;
        }

        /// <summary>
        /// Converts a scalar value into the current vectorized type.
        /// </summary>
        /// <param name="scalar">The scalar element type.</param>
        /// <returns>The created vectorized type.</returns>
        public static Int16x2 FromScalar(short scalar) =>
            new Int16x2(scalar, scalar);

        /// <summary>
        /// Converts this instance into an unsafe span instance.
        /// </summary>
        /// <returns>The readonly span instance.</returns>
        public unsafe ReadOnlySpan<short> AsSpan() =>
            new(Unsafe.AsPointer(ref Unsafe.AsRef(this)), 2);

        /// <summary>
        /// Iterates over all elements by applying the given iterator to each element.
        /// </summary>
        /// <typeparam name="TIterator">The managed iterator type.</typeparam>
        /// <param name="iterator">The iterator to invoke.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ForEach<TIterator>(ref TIterator iterator)
            where TIterator : struct, IVectorElementIterator<
            Int16x2,
            short>
        {
            iterator.Iterate(X, 0);
            iterator.Iterate(Y, 1);
        }

        /// <summary>
        /// Converts this vector instance to a string.
        /// </summary>
        public override string ToString() =>
            $"{X}, {Y}";

        /// <summary>
        /// Converts this vector instance to a string.
        /// </summary>
        public string ToString(string? format, IFormatProvider? formatProvider) =>
            $"{X.ToString(format, formatProvider)}, {Y.ToString(format, formatProvider)}";

        /// <summary>
        /// Returns true.
        /// </summary>
        public static bool IsCanonical(Int16x2 value) => true;

        /// <summary>
        /// Returns false.
        /// </summary>
        public static bool IsComplexNumber(Int16x2 value) => false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsEvenInteger(Int16x2 value) =>
            short.IsEvenInteger(value.X) & short.IsEvenInteger(value.Y);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsFinite(Int16x2 value) =>
            true;

        /// <summary>
        /// Returns false.
        /// </summary>
        public static bool IsImaginaryNumber(Int16x2 value) => false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsInfinity(Int16x2 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsInteger(Int16x2 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNaN(Int16x2 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNegative(Int16x2 value) =>
            short.IsNegative(value.X) & short.IsNegative(value.Y);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNegativeInfinity(Int16x2 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNormal(Int16x2 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsOddInteger(Int16x2 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsPositive(Int16x2 value) =>
            short.IsPositive(value.X) & short.IsPositive(value.Y);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsPositiveInfinity(Int16x2 value) =>
            false;

        /// <summary>
        /// Returns true.
        /// </summary>
        public static bool IsRealNumber(Int16x2 value) => true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsSubnormal(Int16x2 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsZero(Int16x2 value) =>
            value == Zero;

        /// <summary>
        /// Returns the absolute value.
        /// </summary>
        public static Int16x2 Abs(Int16x2 value) =>
            new Int16x2(Math.Abs(value.X), Math.Abs(value.Y));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int16x2 operator +(Int16x2 left, Int16x2 right) =>
            new Int16x2((short)(left.X + right.X), (short)(left.Y + right.Y));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int16x2 operator --(Int16x2 value) => value - One;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int16x2 operator /(Int16x2 left, Int16x2 right) =>
            new Int16x2((short)(left.X / right.X), (short)(left.Y / right.Y));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int16x2 operator ++(Int16x2 value) => value + One;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int16x2 operator *(Int16x2 left, Int16x2 right) =>
            new Int16x2((short)(left.X * right.X), (short)(left.Y * right.Y));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int16x2 operator -(Int16x2 left, Int16x2 right) =>
            new Int16x2((short)(left.X - right.X), (short)(left.Y - right.Y));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int16x2 operator -(Int16x2 value) =>
            new Int16x2((short)-value.X, (short)-value.Y);

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int16x2 operator +(Int16x2 value) => value;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int16x2 MaxMagnitude(Int16x2 x, Int16x2 y) =>
            new Int16x2(short.MaxMagnitude(x.X, y.X), short.MaxMagnitude(x.Y, y.Y));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int16x2 MaxMagnitudeNumber(Int16x2 x, Int16x2 y) =>
            MaxMagnitude(x, y);

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int16x2 MinMagnitude(Int16x2 x, Int16x2 y) =>
            new Int16x2(short.MinMagnitude(x.X, y.X), short.MinMagnitude(x.Y, y.Y));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int16x2 MinMagnitudeNumber(Int16x2 x, Int16x2 y) =>
            MinMagnitude(x, y);

        // Not supported operations

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static Int16x2 IParsable<Int16x2>.Parse(
            string s,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static Int16x2 ISpanParsable<Int16x2>.Parse(
            ReadOnlySpan<char> s,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static Int16x2 INumberBase<Int16x2>.Parse(
            ReadOnlySpan<char> s,
            NumberStyles style,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static Int16x2 INumberBase<Int16x2>.Parse(
            string s,
            NumberStyles style,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        bool ISpanFormattable.TryFormat(
            Span<char> destination,
            out int charsWritten,
            ReadOnlySpan<char> format,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool IParsable<Int16x2>.TryParse(
            string? s,
            IFormatProvider? provider,
            out Int16x2 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given span into a vectorized instance.
        /// </summary>
        static bool ISpanParsable<Int16x2>.TryParse(
            ReadOnlySpan<char> s,
            IFormatProvider? provider,
            out Int16x2 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool INumberBase<Int16x2>.TryParse(
            ReadOnlySpan<char> s,
            NumberStyles style,
            IFormatProvider? provider,
            out Int16x2 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool INumberBase<Int16x2>.TryParse(
            string? s,
            NumberStyles style,
            IFormatProvider? provider,
            out Int16x2 result) =>
            throw new NotSupportedException();

        static bool INumberBase<Int16x2>.TryConvertFromChecked<TOther>(
            TOther value,
            out Int16x2 result) =>
            throw new NotSupportedException();
        static bool INumberBase<Int16x2>.TryConvertFromSaturating<TOther>(
            TOther value,
            out Int16x2 result) =>
            throw new NotSupportedException();
        static bool INumberBase<Int16x2>.TryConvertFromTruncating<TOther>(
            TOther value,
            out Int16x2 result) =>
            throw new NotSupportedException();
        static bool INumberBase<Int16x2>.TryConvertToChecked<TOther>(
            Int16x2 value,
            out TOther result) =>
            throw new NotSupportedException();
        static bool INumberBase<Int16x2>.TryConvertToSaturating<TOther>(
            Int16x2 value,
            out TOther result) =>
            throw new NotSupportedException();
        static bool INumberBase<Int16x2>.TryConvertToTruncating<TOther>(
            Int16x2 value,
            out TOther result) =>
            throw new NotSupportedException();
    }

    /// <summary>
    /// Represents a vectorized short type with length 4.
    /// </summary>
    public readonly record struct Int16x4(
        short X, short Y, short Z, short W) :
        IVectorType<Int16x4, short>
    {
        /// <summary>
        /// The offset of the X field in bytes.
        /// </summary>
        public static readonly int OffsetX =
            sizeof(short) * 0;

        /// <summary>
        /// The offset of the X field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrX =>
            new UIntPtr((uint)OffsetX);
        /// <summary>
        /// The offset of the Y field in bytes.
        /// </summary>
        public static readonly int OffsetY =
            sizeof(short) * 1;

        /// <summary>
        /// The offset of the Y field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrY =>
            new UIntPtr((uint)OffsetY);
        /// <summary>
        /// The offset of the Z field in bytes.
        /// </summary>
        public static readonly int OffsetZ =
            sizeof(short) * 2;

        /// <summary>
        /// The offset of the Z field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrZ =>
            new UIntPtr((uint)OffsetZ);
        /// <summary>
        /// The offset of the W field in bytes.
        /// </summary>
        public static readonly int OffsetW =
            sizeof(short) * 3;

        /// <summary>
        /// The offset of the W field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrW =>
            new UIntPtr((uint)OffsetW);

        /// <summary>
        /// Returns the length of this vector which is 4.
        /// </summary>
        public static int Length => 4;

        /// <summary>
        /// Returns the radix of the underlying value.
        /// </summary>
        public static int Radix => 10;

        /// <summary>
        /// Returns an invalid value (min [signed types], max value [unsigned] or NaN).
        /// </summary>
        public static Int16x4 Invalid => FromScalar(
            short.MinValue
        );

        /// <summary>
        /// Returns the value zero.
        /// </summary>
        public static Int16x4 Zero => new();

        /// <summary>
        /// Returns the value one.
        /// </summary>
        public static Int16x4 One => FromScalar((1));

        /// <summary>
        /// Returns the value zero.
        /// </summary>
        public static Int16x4 AdditiveIdentity => Zero;

        /// <summary>
        /// Returns the value one.
        /// </summary>
        public static Int16x4 MultiplicativeIdentity => One;

        /// <summary>
        /// Computes the min value of both.
        /// </summary>
        /// <param name="first">The first value.</param>
        /// <param name="second">The second value.</param>
        /// <returns>The min value.</returns>
        public static Int16x4 Min(
            Int16x4 first,
            Int16x4 second) =>
            new Int16x4((short)Math.Min(first.X, second.X), (short)Math.Min(first.Y, second.Y), (short)Math.Min(first.Z, second.Z), (short)Math.Min(first.W, second.W));

        /// <summary>
        /// Computes the max value of both.
        /// </summary>
        /// <param name="first">The first value.</param>
        /// <param name="second">The second value.</param>
        /// <returns>The max value.</returns>
        public static Int16x4 Max(
            Int16x4 first,
            Int16x4 second) =>
            new Int16x4((short)Math.Max(first.X, second.X), (short)Math.Max(first.Y, second.Y), (short)Math.Max(first.Z, second.Z), (short)Math.Max(first.W, second.W));

        /// <summary>
        /// Clamps the given value.
        /// </summary>
        /// <param name="value">The value to clamp.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The clamped value.</returns>
        public static Int16x4 Clamp(
            Int16x4 value,
            Int16x4 min,
            Int16x4 max) =>
            Max(Min(value, max), min);

        /// <summary>
        /// Creates a random scalar instance falling into the range of min max.
        /// </summary>
        /// <param name="random">The random provider to use.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The created random scalar instance.</returns>
        public static short GetRandomScalar<TRandom>(
            ref TRandom random,
            short min,
            short max)
            where TRandom : struct, IRandomProvider =>
            (short)RandomExtensions.
                Next(ref random, min, max);

        /// <summary>
        /// Creates a random vector instance falling into the range of min max.
        /// </summary>
        /// <param name="random">The random provider to use.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The created random vector instance.</returns>
        public static Int16x4 GetRandom<TRandom>(
            ref TRandom random,
            Int16x4 min,
            Int16x4 max)
            where TRandom : struct, IRandomProvider
        {
            short x = GetRandomScalar(
                ref random, min.X, max.X);
            short y = GetRandomScalar(
                ref random, min.Y, max.Y);
            short z = GetRandomScalar(
                ref random, min.Z, max.Z);
            short w = GetRandomScalar(
                ref random, min.W, max.W);
            return new Int16x4(x, y, z, w);
        }

        /// <summary>
        /// Creates a vector instance from the given source view.
        /// </summary>
        /// <typeparam name="TStride">The custom stride type.</typeparam>
        /// <param name="sourceView">The source view.</param>
        /// <param name="index">The source base index.</param>
        /// <returns>The vector instance.</returns>
        public static Int16x4 FromElementView<TStride>(
            ArrayView1D<short, TStride> sourceView,
            Index1D index)
            where TStride : struct, IStride1D =>
            new Int16x4(
                sourceView[index + 0],
                sourceView[index + 1],
                sourceView[index + 2],
                sourceView[index + 3]
                );

        /// <summary>
        /// Serializes the current vector instance into the given target view.
        /// </summary>
        /// <typeparam name="TStride">The custom stride type.</typeparam>
        /// <param name="targetView">The target view.</param>
        /// <param name="index">The target base index.</param>
        public void ToElementView<TStride>(
            ArrayView1D<short, TStride> targetView,
            Index1D index)
            where TStride : struct, IStride1D
        {
            targetView[index + 0] = X;
            targetView[index + 1] = Y;
            targetView[index + 2] = Z;
            targetView[index + 3] = W;
        }

        /// <summary>
        /// Creates a vector instance from the given source view.
        /// </summary>
        /// <param name="sourceView">The source view.</param>
        /// <param name="index">The source base index.</param>
        /// <returns>The vector instance.</returns>
        public static Int16x4 FromElementView(
            SingleVectorView<short> sourceView,
            Index1D index) =>
            new Int16x4(
                sourceView[index + 0],
                sourceView[index + 1],
                sourceView[index + 2],
                sourceView[index + 3]
                );

        /// <summary>
        /// Serializes the current vector instance into the given target view.
        /// </summary>
        /// <param name="targetView">The target view.</param>
        /// <param name="index">The target base index.</param>
        public void ToElementView(
            SingleVectorView<short> targetView,
            Index1D index)
        {
            targetView[index + 0] = X;
            targetView[index + 1] = Y;
            targetView[index + 2] = Z;
            targetView[index + 3] = W;
        }

        /// <summary>
        /// Converts a scalar value into the current vectorized type.
        /// </summary>
        /// <param name="scalar">The scalar element type.</param>
        /// <returns>The created vectorized type.</returns>
        public static Int16x4 FromScalar(short scalar) =>
            new Int16x4(scalar, scalar, scalar, scalar);

        /// <summary>
        /// Converts this instance into an unsafe span instance.
        /// </summary>
        /// <returns>The readonly span instance.</returns>
        public unsafe ReadOnlySpan<short> AsSpan() =>
            new(Unsafe.AsPointer(ref Unsafe.AsRef(this)), 4);

        /// <summary>
        /// Iterates over all elements by applying the given iterator to each element.
        /// </summary>
        /// <typeparam name="TIterator">The managed iterator type.</typeparam>
        /// <param name="iterator">The iterator to invoke.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ForEach<TIterator>(ref TIterator iterator)
            where TIterator : struct, IVectorElementIterator<
            Int16x4,
            short>
        {
            iterator.Iterate(X, 0);
            iterator.Iterate(Y, 1);
            iterator.Iterate(Z, 2);
            iterator.Iterate(W, 3);
        }

        /// <summary>
        /// Converts this vector instance to a string.
        /// </summary>
        public override string ToString() =>
            $"{X}, {Y}, {Z}, {W}";

        /// <summary>
        /// Converts this vector instance to a string.
        /// </summary>
        public string ToString(string? format, IFormatProvider? formatProvider) =>
            $"{X.ToString(format, formatProvider)}, {Y.ToString(format, formatProvider)}, {Z.ToString(format, formatProvider)}, {W.ToString(format, formatProvider)}";

        /// <summary>
        /// Returns true.
        /// </summary>
        public static bool IsCanonical(Int16x4 value) => true;

        /// <summary>
        /// Returns false.
        /// </summary>
        public static bool IsComplexNumber(Int16x4 value) => false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsEvenInteger(Int16x4 value) =>
            short.IsEvenInteger(value.X) & short.IsEvenInteger(value.Y) & short.IsEvenInteger(value.Z) & short.IsEvenInteger(value.W);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsFinite(Int16x4 value) =>
            true;

        /// <summary>
        /// Returns false.
        /// </summary>
        public static bool IsImaginaryNumber(Int16x4 value) => false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsInfinity(Int16x4 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsInteger(Int16x4 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNaN(Int16x4 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNegative(Int16x4 value) =>
            short.IsNegative(value.X) & short.IsNegative(value.Y) & short.IsNegative(value.Z) & short.IsNegative(value.W);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNegativeInfinity(Int16x4 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNormal(Int16x4 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsOddInteger(Int16x4 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsPositive(Int16x4 value) =>
            short.IsPositive(value.X) & short.IsPositive(value.Y) & short.IsPositive(value.Z) & short.IsPositive(value.W);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsPositiveInfinity(Int16x4 value) =>
            false;

        /// <summary>
        /// Returns true.
        /// </summary>
        public static bool IsRealNumber(Int16x4 value) => true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsSubnormal(Int16x4 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsZero(Int16x4 value) =>
            value == Zero;

        /// <summary>
        /// Returns the absolute value.
        /// </summary>
        public static Int16x4 Abs(Int16x4 value) =>
            new Int16x4(Math.Abs(value.X), Math.Abs(value.Y), Math.Abs(value.Z), Math.Abs(value.W));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int16x4 operator +(Int16x4 left, Int16x4 right) =>
            new Int16x4((short)(left.X + right.X), (short)(left.Y + right.Y), (short)(left.Z + right.Z), (short)(left.W + right.W));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int16x4 operator --(Int16x4 value) => value - One;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int16x4 operator /(Int16x4 left, Int16x4 right) =>
            new Int16x4((short)(left.X / right.X), (short)(left.Y / right.Y), (short)(left.Z / right.Z), (short)(left.W / right.W));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int16x4 operator ++(Int16x4 value) => value + One;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int16x4 operator *(Int16x4 left, Int16x4 right) =>
            new Int16x4((short)(left.X * right.X), (short)(left.Y * right.Y), (short)(left.Z * right.Z), (short)(left.W * right.W));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int16x4 operator -(Int16x4 left, Int16x4 right) =>
            new Int16x4((short)(left.X - right.X), (short)(left.Y - right.Y), (short)(left.Z - right.Z), (short)(left.W - right.W));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int16x4 operator -(Int16x4 value) =>
            new Int16x4((short)-value.X, (short)-value.Y, (short)-value.Z, (short)-value.W);

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int16x4 operator +(Int16x4 value) => value;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int16x4 MaxMagnitude(Int16x4 x, Int16x4 y) =>
            new Int16x4(short.MaxMagnitude(x.X, y.X), short.MaxMagnitude(x.Y, y.Y), short.MaxMagnitude(x.Z, y.Z), short.MaxMagnitude(x.W, y.W));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int16x4 MaxMagnitudeNumber(Int16x4 x, Int16x4 y) =>
            MaxMagnitude(x, y);

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int16x4 MinMagnitude(Int16x4 x, Int16x4 y) =>
            new Int16x4(short.MinMagnitude(x.X, y.X), short.MinMagnitude(x.Y, y.Y), short.MinMagnitude(x.Z, y.Z), short.MinMagnitude(x.W, y.W));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int16x4 MinMagnitudeNumber(Int16x4 x, Int16x4 y) =>
            MinMagnitude(x, y);

        // Not supported operations

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static Int16x4 IParsable<Int16x4>.Parse(
            string s,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static Int16x4 ISpanParsable<Int16x4>.Parse(
            ReadOnlySpan<char> s,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static Int16x4 INumberBase<Int16x4>.Parse(
            ReadOnlySpan<char> s,
            NumberStyles style,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static Int16x4 INumberBase<Int16x4>.Parse(
            string s,
            NumberStyles style,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        bool ISpanFormattable.TryFormat(
            Span<char> destination,
            out int charsWritten,
            ReadOnlySpan<char> format,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool IParsable<Int16x4>.TryParse(
            string? s,
            IFormatProvider? provider,
            out Int16x4 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given span into a vectorized instance.
        /// </summary>
        static bool ISpanParsable<Int16x4>.TryParse(
            ReadOnlySpan<char> s,
            IFormatProvider? provider,
            out Int16x4 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool INumberBase<Int16x4>.TryParse(
            ReadOnlySpan<char> s,
            NumberStyles style,
            IFormatProvider? provider,
            out Int16x4 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool INumberBase<Int16x4>.TryParse(
            string? s,
            NumberStyles style,
            IFormatProvider? provider,
            out Int16x4 result) =>
            throw new NotSupportedException();

        static bool INumberBase<Int16x4>.TryConvertFromChecked<TOther>(
            TOther value,
            out Int16x4 result) =>
            throw new NotSupportedException();
        static bool INumberBase<Int16x4>.TryConvertFromSaturating<TOther>(
            TOther value,
            out Int16x4 result) =>
            throw new NotSupportedException();
        static bool INumberBase<Int16x4>.TryConvertFromTruncating<TOther>(
            TOther value,
            out Int16x4 result) =>
            throw new NotSupportedException();
        static bool INumberBase<Int16x4>.TryConvertToChecked<TOther>(
            Int16x4 value,
            out TOther result) =>
            throw new NotSupportedException();
        static bool INumberBase<Int16x4>.TryConvertToSaturating<TOther>(
            Int16x4 value,
            out TOther result) =>
            throw new NotSupportedException();
        static bool INumberBase<Int16x4>.TryConvertToTruncating<TOther>(
            Int16x4 value,
            out TOther result) =>
            throw new NotSupportedException();
    }

    /// <summary>
    /// Represents a vectorized short type with length 8.
    /// </summary>
    public readonly record struct Int16x8(
        short X, short Y, short Z, short W, short I, short J, short K, short L) :
        IVectorType<Int16x8, short>
    {
        /// <summary>
        /// The offset of the X field in bytes.
        /// </summary>
        public static readonly int OffsetX =
            sizeof(short) * 0;

        /// <summary>
        /// The offset of the X field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrX =>
            new UIntPtr((uint)OffsetX);
        /// <summary>
        /// The offset of the Y field in bytes.
        /// </summary>
        public static readonly int OffsetY =
            sizeof(short) * 1;

        /// <summary>
        /// The offset of the Y field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrY =>
            new UIntPtr((uint)OffsetY);
        /// <summary>
        /// The offset of the Z field in bytes.
        /// </summary>
        public static readonly int OffsetZ =
            sizeof(short) * 2;

        /// <summary>
        /// The offset of the Z field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrZ =>
            new UIntPtr((uint)OffsetZ);
        /// <summary>
        /// The offset of the W field in bytes.
        /// </summary>
        public static readonly int OffsetW =
            sizeof(short) * 3;

        /// <summary>
        /// The offset of the W field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrW =>
            new UIntPtr((uint)OffsetW);
        /// <summary>
        /// The offset of the I field in bytes.
        /// </summary>
        public static readonly int OffsetI =
            sizeof(short) * 4;

        /// <summary>
        /// The offset of the I field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrI =>
            new UIntPtr((uint)OffsetI);
        /// <summary>
        /// The offset of the J field in bytes.
        /// </summary>
        public static readonly int OffsetJ =
            sizeof(short) * 5;

        /// <summary>
        /// The offset of the J field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrJ =>
            new UIntPtr((uint)OffsetJ);
        /// <summary>
        /// The offset of the K field in bytes.
        /// </summary>
        public static readonly int OffsetK =
            sizeof(short) * 6;

        /// <summary>
        /// The offset of the K field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrK =>
            new UIntPtr((uint)OffsetK);
        /// <summary>
        /// The offset of the L field in bytes.
        /// </summary>
        public static readonly int OffsetL =
            sizeof(short) * 7;

        /// <summary>
        /// The offset of the L field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrL =>
            new UIntPtr((uint)OffsetL);

        /// <summary>
        /// Returns the length of this vector which is 8.
        /// </summary>
        public static int Length => 8;

        /// <summary>
        /// Returns the radix of the underlying value.
        /// </summary>
        public static int Radix => 10;

        /// <summary>
        /// Returns an invalid value (min [signed types], max value [unsigned] or NaN).
        /// </summary>
        public static Int16x8 Invalid => FromScalar(
            short.MinValue
        );

        /// <summary>
        /// Returns the value zero.
        /// </summary>
        public static Int16x8 Zero => new();

        /// <summary>
        /// Returns the value one.
        /// </summary>
        public static Int16x8 One => FromScalar((1));

        /// <summary>
        /// Returns the value zero.
        /// </summary>
        public static Int16x8 AdditiveIdentity => Zero;

        /// <summary>
        /// Returns the value one.
        /// </summary>
        public static Int16x8 MultiplicativeIdentity => One;

        /// <summary>
        /// Computes the min value of both.
        /// </summary>
        /// <param name="first">The first value.</param>
        /// <param name="second">The second value.</param>
        /// <returns>The min value.</returns>
        public static Int16x8 Min(
            Int16x8 first,
            Int16x8 second) =>
            new Int16x8((short)Math.Min(first.X, second.X), (short)Math.Min(first.Y, second.Y), (short)Math.Min(first.Z, second.Z), (short)Math.Min(first.W, second.W), (short)Math.Min(first.I, second.I), (short)Math.Min(first.J, second.J), (short)Math.Min(first.K, second.K), (short)Math.Min(first.L, second.L));

        /// <summary>
        /// Computes the max value of both.
        /// </summary>
        /// <param name="first">The first value.</param>
        /// <param name="second">The second value.</param>
        /// <returns>The max value.</returns>
        public static Int16x8 Max(
            Int16x8 first,
            Int16x8 second) =>
            new Int16x8((short)Math.Max(first.X, second.X), (short)Math.Max(first.Y, second.Y), (short)Math.Max(first.Z, second.Z), (short)Math.Max(first.W, second.W), (short)Math.Max(first.I, second.I), (short)Math.Max(first.J, second.J), (short)Math.Max(first.K, second.K), (short)Math.Max(first.L, second.L));

        /// <summary>
        /// Clamps the given value.
        /// </summary>
        /// <param name="value">The value to clamp.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The clamped value.</returns>
        public static Int16x8 Clamp(
            Int16x8 value,
            Int16x8 min,
            Int16x8 max) =>
            Max(Min(value, max), min);

        /// <summary>
        /// Creates a random scalar instance falling into the range of min max.
        /// </summary>
        /// <param name="random">The random provider to use.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The created random scalar instance.</returns>
        public static short GetRandomScalar<TRandom>(
            ref TRandom random,
            short min,
            short max)
            where TRandom : struct, IRandomProvider =>
            (short)RandomExtensions.
                Next(ref random, min, max);

        /// <summary>
        /// Creates a random vector instance falling into the range of min max.
        /// </summary>
        /// <param name="random">The random provider to use.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The created random vector instance.</returns>
        public static Int16x8 GetRandom<TRandom>(
            ref TRandom random,
            Int16x8 min,
            Int16x8 max)
            where TRandom : struct, IRandomProvider
        {
            short x = GetRandomScalar(
                ref random, min.X, max.X);
            short y = GetRandomScalar(
                ref random, min.Y, max.Y);
            short z = GetRandomScalar(
                ref random, min.Z, max.Z);
            short w = GetRandomScalar(
                ref random, min.W, max.W);
            short i = GetRandomScalar(
                ref random, min.I, max.I);
            short j = GetRandomScalar(
                ref random, min.J, max.J);
            short k = GetRandomScalar(
                ref random, min.K, max.K);
            short l = GetRandomScalar(
                ref random, min.L, max.L);
            return new Int16x8(x, y, z, w, i, j, k, l);
        }

        /// <summary>
        /// Creates a vector instance from the given source view.
        /// </summary>
        /// <typeparam name="TStride">The custom stride type.</typeparam>
        /// <param name="sourceView">The source view.</param>
        /// <param name="index">The source base index.</param>
        /// <returns>The vector instance.</returns>
        public static Int16x8 FromElementView<TStride>(
            ArrayView1D<short, TStride> sourceView,
            Index1D index)
            where TStride : struct, IStride1D =>
            new Int16x8(
                sourceView[index + 0],
                sourceView[index + 1],
                sourceView[index + 2],
                sourceView[index + 3],
                sourceView[index + 4],
                sourceView[index + 5],
                sourceView[index + 6],
                sourceView[index + 7]
                );

        /// <summary>
        /// Serializes the current vector instance into the given target view.
        /// </summary>
        /// <typeparam name="TStride">The custom stride type.</typeparam>
        /// <param name="targetView">The target view.</param>
        /// <param name="index">The target base index.</param>
        public void ToElementView<TStride>(
            ArrayView1D<short, TStride> targetView,
            Index1D index)
            where TStride : struct, IStride1D
        {
            targetView[index + 0] = X;
            targetView[index + 1] = Y;
            targetView[index + 2] = Z;
            targetView[index + 3] = W;
            targetView[index + 4] = I;
            targetView[index + 5] = J;
            targetView[index + 6] = K;
            targetView[index + 7] = L;
        }

        /// <summary>
        /// Creates a vector instance from the given source view.
        /// </summary>
        /// <param name="sourceView">The source view.</param>
        /// <param name="index">The source base index.</param>
        /// <returns>The vector instance.</returns>
        public static Int16x8 FromElementView(
            SingleVectorView<short> sourceView,
            Index1D index) =>
            new Int16x8(
                sourceView[index + 0],
                sourceView[index + 1],
                sourceView[index + 2],
                sourceView[index + 3],
                sourceView[index + 4],
                sourceView[index + 5],
                sourceView[index + 6],
                sourceView[index + 7]
                );

        /// <summary>
        /// Serializes the current vector instance into the given target view.
        /// </summary>
        /// <param name="targetView">The target view.</param>
        /// <param name="index">The target base index.</param>
        public void ToElementView(
            SingleVectorView<short> targetView,
            Index1D index)
        {
            targetView[index + 0] = X;
            targetView[index + 1] = Y;
            targetView[index + 2] = Z;
            targetView[index + 3] = W;
            targetView[index + 4] = I;
            targetView[index + 5] = J;
            targetView[index + 6] = K;
            targetView[index + 7] = L;
        }

        /// <summary>
        /// Converts a scalar value into the current vectorized type.
        /// </summary>
        /// <param name="scalar">The scalar element type.</param>
        /// <returns>The created vectorized type.</returns>
        public static Int16x8 FromScalar(short scalar) =>
            new Int16x8(scalar, scalar, scalar, scalar, scalar, scalar, scalar, scalar);

        /// <summary>
        /// Converts this instance into an unsafe span instance.
        /// </summary>
        /// <returns>The readonly span instance.</returns>
        public unsafe ReadOnlySpan<short> AsSpan() =>
            new(Unsafe.AsPointer(ref Unsafe.AsRef(this)), 8);

        /// <summary>
        /// Iterates over all elements by applying the given iterator to each element.
        /// </summary>
        /// <typeparam name="TIterator">The managed iterator type.</typeparam>
        /// <param name="iterator">The iterator to invoke.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ForEach<TIterator>(ref TIterator iterator)
            where TIterator : struct, IVectorElementIterator<
            Int16x8,
            short>
        {
            iterator.Iterate(X, 0);
            iterator.Iterate(Y, 1);
            iterator.Iterate(Z, 2);
            iterator.Iterate(W, 3);
            iterator.Iterate(I, 4);
            iterator.Iterate(J, 5);
            iterator.Iterate(K, 6);
            iterator.Iterate(L, 7);
        }

        /// <summary>
        /// Converts this vector instance to a string.
        /// </summary>
        public override string ToString() =>
            $"{X}, {Y}, {Z}, {W}, {I}, {J}, {K}, {L}";

        /// <summary>
        /// Converts this vector instance to a string.
        /// </summary>
        public string ToString(string? format, IFormatProvider? formatProvider) =>
            $"{X.ToString(format, formatProvider)}, {Y.ToString(format, formatProvider)}, {Z.ToString(format, formatProvider)}, {W.ToString(format, formatProvider)}, {I.ToString(format, formatProvider)}, {J.ToString(format, formatProvider)}, {K.ToString(format, formatProvider)}, {L.ToString(format, formatProvider)}";

        /// <summary>
        /// Returns true.
        /// </summary>
        public static bool IsCanonical(Int16x8 value) => true;

        /// <summary>
        /// Returns false.
        /// </summary>
        public static bool IsComplexNumber(Int16x8 value) => false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsEvenInteger(Int16x8 value) =>
            short.IsEvenInteger(value.X) & short.IsEvenInteger(value.Y) & short.IsEvenInteger(value.Z) & short.IsEvenInteger(value.W) & short.IsEvenInteger(value.I) & short.IsEvenInteger(value.J) & short.IsEvenInteger(value.K) & short.IsEvenInteger(value.L);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsFinite(Int16x8 value) =>
            true;

        /// <summary>
        /// Returns false.
        /// </summary>
        public static bool IsImaginaryNumber(Int16x8 value) => false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsInfinity(Int16x8 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsInteger(Int16x8 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNaN(Int16x8 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNegative(Int16x8 value) =>
            short.IsNegative(value.X) & short.IsNegative(value.Y) & short.IsNegative(value.Z) & short.IsNegative(value.W) & short.IsNegative(value.I) & short.IsNegative(value.J) & short.IsNegative(value.K) & short.IsNegative(value.L);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNegativeInfinity(Int16x8 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNormal(Int16x8 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsOddInteger(Int16x8 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsPositive(Int16x8 value) =>
            short.IsPositive(value.X) & short.IsPositive(value.Y) & short.IsPositive(value.Z) & short.IsPositive(value.W) & short.IsPositive(value.I) & short.IsPositive(value.J) & short.IsPositive(value.K) & short.IsPositive(value.L);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsPositiveInfinity(Int16x8 value) =>
            false;

        /// <summary>
        /// Returns true.
        /// </summary>
        public static bool IsRealNumber(Int16x8 value) => true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsSubnormal(Int16x8 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsZero(Int16x8 value) =>
            value == Zero;

        /// <summary>
        /// Returns the absolute value.
        /// </summary>
        public static Int16x8 Abs(Int16x8 value) =>
            new Int16x8(Math.Abs(value.X), Math.Abs(value.Y), Math.Abs(value.Z), Math.Abs(value.W), Math.Abs(value.I), Math.Abs(value.J), Math.Abs(value.K), Math.Abs(value.L));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int16x8 operator +(Int16x8 left, Int16x8 right) =>
            new Int16x8((short)(left.X + right.X), (short)(left.Y + right.Y), (short)(left.Z + right.Z), (short)(left.W + right.W), (short)(left.I + right.I), (short)(left.J + right.J), (short)(left.K + right.K), (short)(left.L + right.L));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int16x8 operator --(Int16x8 value) => value - One;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int16x8 operator /(Int16x8 left, Int16x8 right) =>
            new Int16x8((short)(left.X / right.X), (short)(left.Y / right.Y), (short)(left.Z / right.Z), (short)(left.W / right.W), (short)(left.I / right.I), (short)(left.J / right.J), (short)(left.K / right.K), (short)(left.L / right.L));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int16x8 operator ++(Int16x8 value) => value + One;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int16x8 operator *(Int16x8 left, Int16x8 right) =>
            new Int16x8((short)(left.X * right.X), (short)(left.Y * right.Y), (short)(left.Z * right.Z), (short)(left.W * right.W), (short)(left.I * right.I), (short)(left.J * right.J), (short)(left.K * right.K), (short)(left.L * right.L));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int16x8 operator -(Int16x8 left, Int16x8 right) =>
            new Int16x8((short)(left.X - right.X), (short)(left.Y - right.Y), (short)(left.Z - right.Z), (short)(left.W - right.W), (short)(left.I - right.I), (short)(left.J - right.J), (short)(left.K - right.K), (short)(left.L - right.L));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int16x8 operator -(Int16x8 value) =>
            new Int16x8((short)-value.X, (short)-value.Y, (short)-value.Z, (short)-value.W, (short)-value.I, (short)-value.J, (short)-value.K, (short)-value.L);

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int16x8 operator +(Int16x8 value) => value;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int16x8 MaxMagnitude(Int16x8 x, Int16x8 y) =>
            new Int16x8(short.MaxMagnitude(x.X, y.X), short.MaxMagnitude(x.Y, y.Y), short.MaxMagnitude(x.Z, y.Z), short.MaxMagnitude(x.W, y.W), short.MaxMagnitude(x.I, y.I), short.MaxMagnitude(x.J, y.J), short.MaxMagnitude(x.K, y.K), short.MaxMagnitude(x.L, y.L));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int16x8 MaxMagnitudeNumber(Int16x8 x, Int16x8 y) =>
            MaxMagnitude(x, y);

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int16x8 MinMagnitude(Int16x8 x, Int16x8 y) =>
            new Int16x8(short.MinMagnitude(x.X, y.X), short.MinMagnitude(x.Y, y.Y), short.MinMagnitude(x.Z, y.Z), short.MinMagnitude(x.W, y.W), short.MinMagnitude(x.I, y.I), short.MinMagnitude(x.J, y.J), short.MinMagnitude(x.K, y.K), short.MinMagnitude(x.L, y.L));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int16x8 MinMagnitudeNumber(Int16x8 x, Int16x8 y) =>
            MinMagnitude(x, y);

        // Not supported operations

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static Int16x8 IParsable<Int16x8>.Parse(
            string s,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static Int16x8 ISpanParsable<Int16x8>.Parse(
            ReadOnlySpan<char> s,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static Int16x8 INumberBase<Int16x8>.Parse(
            ReadOnlySpan<char> s,
            NumberStyles style,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static Int16x8 INumberBase<Int16x8>.Parse(
            string s,
            NumberStyles style,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        bool ISpanFormattable.TryFormat(
            Span<char> destination,
            out int charsWritten,
            ReadOnlySpan<char> format,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool IParsable<Int16x8>.TryParse(
            string? s,
            IFormatProvider? provider,
            out Int16x8 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given span into a vectorized instance.
        /// </summary>
        static bool ISpanParsable<Int16x8>.TryParse(
            ReadOnlySpan<char> s,
            IFormatProvider? provider,
            out Int16x8 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool INumberBase<Int16x8>.TryParse(
            ReadOnlySpan<char> s,
            NumberStyles style,
            IFormatProvider? provider,
            out Int16x8 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool INumberBase<Int16x8>.TryParse(
            string? s,
            NumberStyles style,
            IFormatProvider? provider,
            out Int16x8 result) =>
            throw new NotSupportedException();

        static bool INumberBase<Int16x8>.TryConvertFromChecked<TOther>(
            TOther value,
            out Int16x8 result) =>
            throw new NotSupportedException();
        static bool INumberBase<Int16x8>.TryConvertFromSaturating<TOther>(
            TOther value,
            out Int16x8 result) =>
            throw new NotSupportedException();
        static bool INumberBase<Int16x8>.TryConvertFromTruncating<TOther>(
            TOther value,
            out Int16x8 result) =>
            throw new NotSupportedException();
        static bool INumberBase<Int16x8>.TryConvertToChecked<TOther>(
            Int16x8 value,
            out TOther result) =>
            throw new NotSupportedException();
        static bool INumberBase<Int16x8>.TryConvertToSaturating<TOther>(
            Int16x8 value,
            out TOther result) =>
            throw new NotSupportedException();
        static bool INumberBase<Int16x8>.TryConvertToTruncating<TOther>(
            Int16x8 value,
            out TOther result) =>
            throw new NotSupportedException();
    }

    /// <summary>
    /// Represents a vectorized int type with length 2.
    /// </summary>
    public readonly record struct Int32x2(
        int X, int Y) :
        IVectorType<Int32x2, int>
        , IAccumulationVectorType<
            Int32x2,
            UInt8x2,
            byte>
        , IAccumulationVectorType<
            Int32x2,
            Int8x2,
            sbyte>
        , IAccumulationVectorType<
            Int32x2,
            Int16x2,
            short>
        , IAccumulationVectorType<
            Int32x2,
            UInt16x2,
            ushort>
        , IAccumulationVectorType<
            Int32x2,
            Int32x2,
            int>
        , IAccumulationVectorType<
            Int32x2,
            Float32x2,
            float>
        , IAccumulationVectorType<
            Int32x2,
            Float64x2,
            double>
    {
        /// <summary>
        /// The offset of the X field in bytes.
        /// </summary>
        public static readonly int OffsetX =
            sizeof(int) * 0;

        /// <summary>
        /// The offset of the X field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrX =>
            new UIntPtr((uint)OffsetX);
        /// <summary>
        /// The offset of the Y field in bytes.
        /// </summary>
        public static readonly int OffsetY =
            sizeof(int) * 1;

        /// <summary>
        /// The offset of the Y field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrY =>
            new UIntPtr((uint)OffsetY);

        /// <summary>
        /// Returns the length of this vector which is 2.
        /// </summary>
        public static int Length => 2;

        /// <summary>
        /// Returns the radix of the underlying value.
        /// </summary>
        public static int Radix => 10;

        /// <summary>
        /// Returns an invalid value (min [signed types], max value [unsigned] or NaN).
        /// </summary>
        public static Int32x2 Invalid => FromScalar(
            int.MinValue
        );

        /// <summary>
        /// Returns the value zero.
        /// </summary>
        public static Int32x2 Zero => new();

        /// <summary>
        /// Returns the value one.
        /// </summary>
        public static Int32x2 One => FromScalar((1));

        /// <summary>
        /// Returns the value zero.
        /// </summary>
        public static Int32x2 AdditiveIdentity => Zero;

        /// <summary>
        /// Returns the value one.
        /// </summary>
        public static Int32x2 MultiplicativeIdentity => One;

        /// <summary>
        /// Computes the min value of both.
        /// </summary>
        /// <param name="first">The first value.</param>
        /// <param name="second">The second value.</param>
        /// <returns>The min value.</returns>
        public static Int32x2 Min(
            Int32x2 first,
            Int32x2 second) =>
            new Int32x2((int)Math.Min(first.X, second.X), (int)Math.Min(first.Y, second.Y));

        /// <summary>
        /// Computes the max value of both.
        /// </summary>
        /// <param name="first">The first value.</param>
        /// <param name="second">The second value.</param>
        /// <returns>The max value.</returns>
        public static Int32x2 Max(
            Int32x2 first,
            Int32x2 second) =>
            new Int32x2((int)Math.Max(first.X, second.X), (int)Math.Max(first.Y, second.Y));

        /// <summary>
        /// Clamps the given value.
        /// </summary>
        /// <param name="value">The value to clamp.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The clamped value.</returns>
        public static Int32x2 Clamp(
            Int32x2 value,
            Int32x2 min,
            Int32x2 max) =>
            Max(Min(value, max), min);

        /// <summary>
        /// Creates a random scalar instance falling into the range of min max.
        /// </summary>
        /// <param name="random">The random provider to use.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The created random scalar instance.</returns>
        public static int GetRandomScalar<TRandom>(
            ref TRandom random,
            int min,
            int max)
            where TRandom : struct, IRandomProvider =>
            (int)RandomExtensions.
                Next(ref random, min, max);

        /// <summary>
        /// Creates a random vector instance falling into the range of min max.
        /// </summary>
        /// <param name="random">The random provider to use.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The created random vector instance.</returns>
        public static Int32x2 GetRandom<TRandom>(
            ref TRandom random,
            Int32x2 min,
            Int32x2 max)
            where TRandom : struct, IRandomProvider
        {
            int x = GetRandomScalar(
                ref random, min.X, max.X);
            int y = GetRandomScalar(
                ref random, min.Y, max.Y);
            return new Int32x2(x, y);
        }

        /// <summary>
        /// Creates a vector instance from the given source view.
        /// </summary>
        /// <typeparam name="TStride">The custom stride type.</typeparam>
        /// <param name="sourceView">The source view.</param>
        /// <param name="index">The source base index.</param>
        /// <returns>The vector instance.</returns>
        public static Int32x2 FromElementView<TStride>(
            ArrayView1D<int, TStride> sourceView,
            Index1D index)
            where TStride : struct, IStride1D =>
            new Int32x2(
                sourceView[index + 0],
                sourceView[index + 1]
                );

        /// <summary>
        /// Serializes the current vector instance into the given target view.
        /// </summary>
        /// <typeparam name="TStride">The custom stride type.</typeparam>
        /// <param name="targetView">The target view.</param>
        /// <param name="index">The target base index.</param>
        public void ToElementView<TStride>(
            ArrayView1D<int, TStride> targetView,
            Index1D index)
            where TStride : struct, IStride1D
        {
            targetView[index + 0] = X;
            targetView[index + 1] = Y;
        }

        /// <summary>
        /// Creates a vector instance from the given source view.
        /// </summary>
        /// <param name="sourceView">The source view.</param>
        /// <param name="index">The source base index.</param>
        /// <returns>The vector instance.</returns>
        public static Int32x2 FromElementView(
            SingleVectorView<int> sourceView,
            Index1D index) =>
            new Int32x2(
                sourceView[index + 0],
                sourceView[index + 1]
                );

        /// <summary>
        /// Serializes the current vector instance into the given target view.
        /// </summary>
        /// <param name="targetView">The target view.</param>
        /// <param name="index">The target base index.</param>
        public void ToElementView(
            SingleVectorView<int> targetView,
            Index1D index)
        {
            targetView[index + 0] = X;
            targetView[index + 1] = Y;
        }

        /// <summary>
        /// Converts a scalar value into the current vectorized type.
        /// </summary>
        /// <param name="scalar">The scalar element type.</param>
        /// <returns>The created vectorized type.</returns>
        public static Int32x2 FromScalar(int scalar) =>
            new Int32x2(scalar, scalar);

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        public static void AtomicAdd(ref Int32x2 target, Int32x2 value)
        {
            ref var elementRef = ref Unsafe.As<Int32x2, int>(
                ref target);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrX),
                value.X);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrY),
                value.Y);
        }

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        public Int32x2 ComputeAverage(long denominator) =>
            this / FromScalar((int)denominator);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int32x2 operator +(
            Int32x2 current,
            UInt8x2 toAccumulate) =>
            current + ConvertFrom_byte(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int32x2 operator +(
            UInt8x2 toAccumulate,
            Int32x2 current) =>
            ConvertFrom_byte(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int32x2 operator -(
            Int32x2 current,
            UInt8x2 toAccumulate) =>
            current - ConvertFrom_byte(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int32x2 operator -(
            UInt8x2 toAccumulate,
            Int32x2 current) =>
            ConvertFrom_byte(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref Int32x2 target,
            UInt8x2 value) =>
            AtomicAdd(ref target, ConvertFrom_byte(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int32x2 ConvertFrom_byte(
            UInt8x2 other) =>
            new Int32x2((int)other.X, (int)other.Y);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt8x2 ConvertTo_byte(
            Int32x2 current) =>
            new UInt8x2((byte)current.X, (byte)current.Y);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int32x2 IAccumulationVectorType<
            Int32x2,
            UInt8x2,
            byte>.ConvertFromBase(UInt8x2 other) =>
            ConvertFrom_byte(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt8x2 IAccumulationVectorType<
            Int32x2,
            UInt8x2,
            byte>.ConvertToBase(Int32x2 current) =>
            ConvertTo_byte(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public Int32x2 ComputeAverage(byte denominator) =>
            this / FromScalar((int)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int32x2 operator +(
            Int32x2 current,
            Int8x2 toAccumulate) =>
            current + ConvertFrom_sbyte(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int32x2 operator +(
            Int8x2 toAccumulate,
            Int32x2 current) =>
            ConvertFrom_sbyte(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int32x2 operator -(
            Int32x2 current,
            Int8x2 toAccumulate) =>
            current - ConvertFrom_sbyte(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int32x2 operator -(
            Int8x2 toAccumulate,
            Int32x2 current) =>
            ConvertFrom_sbyte(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref Int32x2 target,
            Int8x2 value) =>
            AtomicAdd(ref target, ConvertFrom_sbyte(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int32x2 ConvertFrom_sbyte(
            Int8x2 other) =>
            new Int32x2((int)other.X, (int)other.Y);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int8x2 ConvertTo_sbyte(
            Int32x2 current) =>
            new Int8x2((sbyte)current.X, (sbyte)current.Y);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int32x2 IAccumulationVectorType<
            Int32x2,
            Int8x2,
            sbyte>.ConvertFromBase(Int8x2 other) =>
            ConvertFrom_sbyte(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int8x2 IAccumulationVectorType<
            Int32x2,
            Int8x2,
            sbyte>.ConvertToBase(Int32x2 current) =>
            ConvertTo_sbyte(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public Int32x2 ComputeAverage(sbyte denominator) =>
            this / FromScalar((int)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int32x2 operator +(
            Int32x2 current,
            Int16x2 toAccumulate) =>
            current + ConvertFrom_short(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int32x2 operator +(
            Int16x2 toAccumulate,
            Int32x2 current) =>
            ConvertFrom_short(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int32x2 operator -(
            Int32x2 current,
            Int16x2 toAccumulate) =>
            current - ConvertFrom_short(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int32x2 operator -(
            Int16x2 toAccumulate,
            Int32x2 current) =>
            ConvertFrom_short(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(true)]
        public static void AtomicAdd(
            ref Int32x2 target,
            Int16x2 value) =>
            AtomicAdd(ref target, ConvertFrom_short(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int32x2 ConvertFrom_short(
            Int16x2 other) =>
            new Int32x2((int)other.X, (int)other.Y);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int16x2 ConvertTo_short(
            Int32x2 current) =>
            new Int16x2((short)current.X, (short)current.Y);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int32x2 IAccumulationVectorType<
            Int32x2,
            Int16x2,
            short>.ConvertFromBase(Int16x2 other) =>
            ConvertFrom_short(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int16x2 IAccumulationVectorType<
            Int32x2,
            Int16x2,
            short>.ConvertToBase(Int32x2 current) =>
            ConvertTo_short(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(true)]
        public Int32x2 ComputeAverage(short denominator) =>
            this / FromScalar((int)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int32x2 operator +(
            Int32x2 current,
            UInt16x2 toAccumulate) =>
            current + ConvertFrom_ushort(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int32x2 operator +(
            UInt16x2 toAccumulate,
            Int32x2 current) =>
            ConvertFrom_ushort(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int32x2 operator -(
            Int32x2 current,
            UInt16x2 toAccumulate) =>
            current - ConvertFrom_ushort(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int32x2 operator -(
            UInt16x2 toAccumulate,
            Int32x2 current) =>
            ConvertFrom_ushort(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref Int32x2 target,
            UInt16x2 value) =>
            AtomicAdd(ref target, ConvertFrom_ushort(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int32x2 ConvertFrom_ushort(
            UInt16x2 other) =>
            new Int32x2((int)other.X, (int)other.Y);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt16x2 ConvertTo_ushort(
            Int32x2 current) =>
            new UInt16x2((ushort)current.X, (ushort)current.Y);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int32x2 IAccumulationVectorType<
            Int32x2,
            UInt16x2,
            ushort>.ConvertFromBase(UInt16x2 other) =>
            ConvertFrom_ushort(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt16x2 IAccumulationVectorType<
            Int32x2,
            UInt16x2,
            ushort>.ConvertToBase(Int32x2 current) =>
            ConvertTo_ushort(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public Int32x2 ComputeAverage(ushort denominator) =>
            this / FromScalar((int)denominator);


        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int32x2 ConvertFrom_int(
            Int32x2 other) =>
            new Int32x2((int)other.X, (int)other.Y);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int32x2 ConvertTo_int(
            Int32x2 current) =>
            new Int32x2((int)current.X, (int)current.Y);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int32x2 IAccumulationVectorType<
            Int32x2,
            Int32x2,
            int>.ConvertFromBase(Int32x2 other) =>
            ConvertFrom_int(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int32x2 IAccumulationVectorType<
            Int32x2,
            Int32x2,
            int>.ConvertToBase(Int32x2 current) =>
            ConvertTo_int(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(true)]
        public Int32x2 ComputeAverage(int denominator) =>
            this / FromScalar((int)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int32x2 operator +(
            Int32x2 current,
            Float32x2 toAccumulate) =>
            current + ConvertFrom_float(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int32x2 operator +(
            Float32x2 toAccumulate,
            Int32x2 current) =>
            ConvertFrom_float(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int32x2 operator -(
            Int32x2 current,
            Float32x2 toAccumulate) =>
            current - ConvertFrom_float(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int32x2 operator -(
            Float32x2 toAccumulate,
            Int32x2 current) =>
            ConvertFrom_float(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(true)]
        public static void AtomicAdd(
            ref Int32x2 target,
            Float32x2 value) =>
            AtomicAdd(ref target, ConvertFrom_float(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int32x2 ConvertFrom_float(
            Float32x2 other) =>
            new Int32x2((int)other.X, (int)other.Y);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float32x2 ConvertTo_float(
            Int32x2 current) =>
            new Float32x2((float)current.X, (float)current.Y);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int32x2 IAccumulationVectorType<
            Int32x2,
            Float32x2,
            float>.ConvertFromBase(Float32x2 other) =>
            ConvertFrom_float(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float32x2 IAccumulationVectorType<
            Int32x2,
            Float32x2,
            float>.ConvertToBase(Int32x2 current) =>
            ConvertTo_float(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(true)]
        public Int32x2 ComputeAverage(float denominator) =>
            this / FromScalar((int)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int32x2 operator +(
            Int32x2 current,
            Float64x2 toAccumulate) =>
            current + ConvertFrom_double(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int32x2 operator +(
            Float64x2 toAccumulate,
            Int32x2 current) =>
            ConvertFrom_double(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int32x2 operator -(
            Int32x2 current,
            Float64x2 toAccumulate) =>
            current - ConvertFrom_double(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int32x2 operator -(
            Float64x2 toAccumulate,
            Int32x2 current) =>
            ConvertFrom_double(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(true)]
        public static void AtomicAdd(
            ref Int32x2 target,
            Float64x2 value) =>
            AtomicAdd(ref target, ConvertFrom_double(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int32x2 ConvertFrom_double(
            Float64x2 other) =>
            new Int32x2((int)other.X, (int)other.Y);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float64x2 ConvertTo_double(
            Int32x2 current) =>
            new Float64x2((double)current.X, (double)current.Y);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int32x2 IAccumulationVectorType<
            Int32x2,
            Float64x2,
            double>.ConvertFromBase(Float64x2 other) =>
            ConvertFrom_double(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float64x2 IAccumulationVectorType<
            Int32x2,
            Float64x2,
            double>.ConvertToBase(Int32x2 current) =>
            ConvertTo_double(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(true)]
        public Int32x2 ComputeAverage(double denominator) =>
            this / FromScalar((int)denominator);

        /// <summary>
        /// Converts this instance into an unsafe span instance.
        /// </summary>
        /// <returns>The readonly span instance.</returns>
        public unsafe ReadOnlySpan<int> AsSpan() =>
            new(Unsafe.AsPointer(ref Unsafe.AsRef(this)), 2);

        /// <summary>
        /// Iterates over all elements by applying the given iterator to each element.
        /// </summary>
        /// <typeparam name="TIterator">The managed iterator type.</typeparam>
        /// <param name="iterator">The iterator to invoke.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ForEach<TIterator>(ref TIterator iterator)
            where TIterator : struct, IVectorElementIterator<
            Int32x2,
            int>
        {
            iterator.Iterate(X, 0);
            iterator.Iterate(Y, 1);
        }

        /// <summary>
        /// Converts this vector instance to a string.
        /// </summary>
        public override string ToString() =>
            $"{X}, {Y}";

        /// <summary>
        /// Converts this vector instance to a string.
        /// </summary>
        public string ToString(string? format, IFormatProvider? formatProvider) =>
            $"{X.ToString(format, formatProvider)}, {Y.ToString(format, formatProvider)}";

        /// <summary>
        /// Returns true.
        /// </summary>
        public static bool IsCanonical(Int32x2 value) => true;

        /// <summary>
        /// Returns false.
        /// </summary>
        public static bool IsComplexNumber(Int32x2 value) => false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsEvenInteger(Int32x2 value) =>
            int.IsEvenInteger(value.X) & int.IsEvenInteger(value.Y);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsFinite(Int32x2 value) =>
            true;

        /// <summary>
        /// Returns false.
        /// </summary>
        public static bool IsImaginaryNumber(Int32x2 value) => false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsInfinity(Int32x2 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsInteger(Int32x2 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNaN(Int32x2 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNegative(Int32x2 value) =>
            int.IsNegative(value.X) & int.IsNegative(value.Y);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNegativeInfinity(Int32x2 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNormal(Int32x2 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsOddInteger(Int32x2 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsPositive(Int32x2 value) =>
            int.IsPositive(value.X) & int.IsPositive(value.Y);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsPositiveInfinity(Int32x2 value) =>
            false;

        /// <summary>
        /// Returns true.
        /// </summary>
        public static bool IsRealNumber(Int32x2 value) => true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsSubnormal(Int32x2 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsZero(Int32x2 value) =>
            value == Zero;

        /// <summary>
        /// Returns the absolute value.
        /// </summary>
        public static Int32x2 Abs(Int32x2 value) =>
            new Int32x2(Math.Abs(value.X), Math.Abs(value.Y));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int32x2 operator +(Int32x2 left, Int32x2 right) =>
            new Int32x2((int)(left.X + right.X), (int)(left.Y + right.Y));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int32x2 operator --(Int32x2 value) => value - One;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int32x2 operator /(Int32x2 left, Int32x2 right) =>
            new Int32x2((int)(left.X / right.X), (int)(left.Y / right.Y));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int32x2 operator ++(Int32x2 value) => value + One;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int32x2 operator *(Int32x2 left, Int32x2 right) =>
            new Int32x2((int)(left.X * right.X), (int)(left.Y * right.Y));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int32x2 operator -(Int32x2 left, Int32x2 right) =>
            new Int32x2((int)(left.X - right.X), (int)(left.Y - right.Y));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int32x2 operator -(Int32x2 value) =>
            new Int32x2((int)-value.X, (int)-value.Y);

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int32x2 operator +(Int32x2 value) => value;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int32x2 MaxMagnitude(Int32x2 x, Int32x2 y) =>
            new Int32x2(int.MaxMagnitude(x.X, y.X), int.MaxMagnitude(x.Y, y.Y));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int32x2 MaxMagnitudeNumber(Int32x2 x, Int32x2 y) =>
            MaxMagnitude(x, y);

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int32x2 MinMagnitude(Int32x2 x, Int32x2 y) =>
            new Int32x2(int.MinMagnitude(x.X, y.X), int.MinMagnitude(x.Y, y.Y));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int32x2 MinMagnitudeNumber(Int32x2 x, Int32x2 y) =>
            MinMagnitude(x, y);

        // Not supported operations

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static Int32x2 IParsable<Int32x2>.Parse(
            string s,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static Int32x2 ISpanParsable<Int32x2>.Parse(
            ReadOnlySpan<char> s,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static Int32x2 INumberBase<Int32x2>.Parse(
            ReadOnlySpan<char> s,
            NumberStyles style,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static Int32x2 INumberBase<Int32x2>.Parse(
            string s,
            NumberStyles style,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        bool ISpanFormattable.TryFormat(
            Span<char> destination,
            out int charsWritten,
            ReadOnlySpan<char> format,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool IParsable<Int32x2>.TryParse(
            string? s,
            IFormatProvider? provider,
            out Int32x2 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given span into a vectorized instance.
        /// </summary>
        static bool ISpanParsable<Int32x2>.TryParse(
            ReadOnlySpan<char> s,
            IFormatProvider? provider,
            out Int32x2 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool INumberBase<Int32x2>.TryParse(
            ReadOnlySpan<char> s,
            NumberStyles style,
            IFormatProvider? provider,
            out Int32x2 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool INumberBase<Int32x2>.TryParse(
            string? s,
            NumberStyles style,
            IFormatProvider? provider,
            out Int32x2 result) =>
            throw new NotSupportedException();

        static bool INumberBase<Int32x2>.TryConvertFromChecked<TOther>(
            TOther value,
            out Int32x2 result) =>
            throw new NotSupportedException();
        static bool INumberBase<Int32x2>.TryConvertFromSaturating<TOther>(
            TOther value,
            out Int32x2 result) =>
            throw new NotSupportedException();
        static bool INumberBase<Int32x2>.TryConvertFromTruncating<TOther>(
            TOther value,
            out Int32x2 result) =>
            throw new NotSupportedException();
        static bool INumberBase<Int32x2>.TryConvertToChecked<TOther>(
            Int32x2 value,
            out TOther result) =>
            throw new NotSupportedException();
        static bool INumberBase<Int32x2>.TryConvertToSaturating<TOther>(
            Int32x2 value,
            out TOther result) =>
            throw new NotSupportedException();
        static bool INumberBase<Int32x2>.TryConvertToTruncating<TOther>(
            Int32x2 value,
            out TOther result) =>
            throw new NotSupportedException();
    }

    /// <summary>
    /// Represents a vectorized int type with length 4.
    /// </summary>
    public readonly record struct Int32x4(
        int X, int Y, int Z, int W) :
        IVectorType<Int32x4, int>
        , IAccumulationVectorType<
            Int32x4,
            UInt8x4,
            byte>
        , IAccumulationVectorType<
            Int32x4,
            Int8x4,
            sbyte>
        , IAccumulationVectorType<
            Int32x4,
            Int16x4,
            short>
        , IAccumulationVectorType<
            Int32x4,
            UInt16x4,
            ushort>
        , IAccumulationVectorType<
            Int32x4,
            Int32x4,
            int>
        , IAccumulationVectorType<
            Int32x4,
            Float32x4,
            float>
        , IAccumulationVectorType<
            Int32x4,
            Float64x4,
            double>
    {
        /// <summary>
        /// The offset of the X field in bytes.
        /// </summary>
        public static readonly int OffsetX =
            sizeof(int) * 0;

        /// <summary>
        /// The offset of the X field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrX =>
            new UIntPtr((uint)OffsetX);
        /// <summary>
        /// The offset of the Y field in bytes.
        /// </summary>
        public static readonly int OffsetY =
            sizeof(int) * 1;

        /// <summary>
        /// The offset of the Y field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrY =>
            new UIntPtr((uint)OffsetY);
        /// <summary>
        /// The offset of the Z field in bytes.
        /// </summary>
        public static readonly int OffsetZ =
            sizeof(int) * 2;

        /// <summary>
        /// The offset of the Z field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrZ =>
            new UIntPtr((uint)OffsetZ);
        /// <summary>
        /// The offset of the W field in bytes.
        /// </summary>
        public static readonly int OffsetW =
            sizeof(int) * 3;

        /// <summary>
        /// The offset of the W field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrW =>
            new UIntPtr((uint)OffsetW);

        /// <summary>
        /// Returns the length of this vector which is 4.
        /// </summary>
        public static int Length => 4;

        /// <summary>
        /// Returns the radix of the underlying value.
        /// </summary>
        public static int Radix => 10;

        /// <summary>
        /// Returns an invalid value (min [signed types], max value [unsigned] or NaN).
        /// </summary>
        public static Int32x4 Invalid => FromScalar(
            int.MinValue
        );

        /// <summary>
        /// Returns the value zero.
        /// </summary>
        public static Int32x4 Zero => new();

        /// <summary>
        /// Returns the value one.
        /// </summary>
        public static Int32x4 One => FromScalar((1));

        /// <summary>
        /// Returns the value zero.
        /// </summary>
        public static Int32x4 AdditiveIdentity => Zero;

        /// <summary>
        /// Returns the value one.
        /// </summary>
        public static Int32x4 MultiplicativeIdentity => One;

        /// <summary>
        /// Computes the min value of both.
        /// </summary>
        /// <param name="first">The first value.</param>
        /// <param name="second">The second value.</param>
        /// <returns>The min value.</returns>
        public static Int32x4 Min(
            Int32x4 first,
            Int32x4 second) =>
            new Int32x4((int)Math.Min(first.X, second.X), (int)Math.Min(first.Y, second.Y), (int)Math.Min(first.Z, second.Z), (int)Math.Min(first.W, second.W));

        /// <summary>
        /// Computes the max value of both.
        /// </summary>
        /// <param name="first">The first value.</param>
        /// <param name="second">The second value.</param>
        /// <returns>The max value.</returns>
        public static Int32x4 Max(
            Int32x4 first,
            Int32x4 second) =>
            new Int32x4((int)Math.Max(first.X, second.X), (int)Math.Max(first.Y, second.Y), (int)Math.Max(first.Z, second.Z), (int)Math.Max(first.W, second.W));

        /// <summary>
        /// Clamps the given value.
        /// </summary>
        /// <param name="value">The value to clamp.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The clamped value.</returns>
        public static Int32x4 Clamp(
            Int32x4 value,
            Int32x4 min,
            Int32x4 max) =>
            Max(Min(value, max), min);

        /// <summary>
        /// Creates a random scalar instance falling into the range of min max.
        /// </summary>
        /// <param name="random">The random provider to use.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The created random scalar instance.</returns>
        public static int GetRandomScalar<TRandom>(
            ref TRandom random,
            int min,
            int max)
            where TRandom : struct, IRandomProvider =>
            (int)RandomExtensions.
                Next(ref random, min, max);

        /// <summary>
        /// Creates a random vector instance falling into the range of min max.
        /// </summary>
        /// <param name="random">The random provider to use.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The created random vector instance.</returns>
        public static Int32x4 GetRandom<TRandom>(
            ref TRandom random,
            Int32x4 min,
            Int32x4 max)
            where TRandom : struct, IRandomProvider
        {
            int x = GetRandomScalar(
                ref random, min.X, max.X);
            int y = GetRandomScalar(
                ref random, min.Y, max.Y);
            int z = GetRandomScalar(
                ref random, min.Z, max.Z);
            int w = GetRandomScalar(
                ref random, min.W, max.W);
            return new Int32x4(x, y, z, w);
        }

        /// <summary>
        /// Creates a vector instance from the given source view.
        /// </summary>
        /// <typeparam name="TStride">The custom stride type.</typeparam>
        /// <param name="sourceView">The source view.</param>
        /// <param name="index">The source base index.</param>
        /// <returns>The vector instance.</returns>
        public static Int32x4 FromElementView<TStride>(
            ArrayView1D<int, TStride> sourceView,
            Index1D index)
            where TStride : struct, IStride1D =>
            new Int32x4(
                sourceView[index + 0],
                sourceView[index + 1],
                sourceView[index + 2],
                sourceView[index + 3]
                );

        /// <summary>
        /// Serializes the current vector instance into the given target view.
        /// </summary>
        /// <typeparam name="TStride">The custom stride type.</typeparam>
        /// <param name="targetView">The target view.</param>
        /// <param name="index">The target base index.</param>
        public void ToElementView<TStride>(
            ArrayView1D<int, TStride> targetView,
            Index1D index)
            where TStride : struct, IStride1D
        {
            targetView[index + 0] = X;
            targetView[index + 1] = Y;
            targetView[index + 2] = Z;
            targetView[index + 3] = W;
        }

        /// <summary>
        /// Creates a vector instance from the given source view.
        /// </summary>
        /// <param name="sourceView">The source view.</param>
        /// <param name="index">The source base index.</param>
        /// <returns>The vector instance.</returns>
        public static Int32x4 FromElementView(
            SingleVectorView<int> sourceView,
            Index1D index) =>
            new Int32x4(
                sourceView[index + 0],
                sourceView[index + 1],
                sourceView[index + 2],
                sourceView[index + 3]
                );

        /// <summary>
        /// Serializes the current vector instance into the given target view.
        /// </summary>
        /// <param name="targetView">The target view.</param>
        /// <param name="index">The target base index.</param>
        public void ToElementView(
            SingleVectorView<int> targetView,
            Index1D index)
        {
            targetView[index + 0] = X;
            targetView[index + 1] = Y;
            targetView[index + 2] = Z;
            targetView[index + 3] = W;
        }

        /// <summary>
        /// Converts a scalar value into the current vectorized type.
        /// </summary>
        /// <param name="scalar">The scalar element type.</param>
        /// <returns>The created vectorized type.</returns>
        public static Int32x4 FromScalar(int scalar) =>
            new Int32x4(scalar, scalar, scalar, scalar);

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        public static void AtomicAdd(ref Int32x4 target, Int32x4 value)
        {
            ref var elementRef = ref Unsafe.As<Int32x4, int>(
                ref target);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrX),
                value.X);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrY),
                value.Y);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrZ),
                value.Z);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrW),
                value.W);
        }

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        public Int32x4 ComputeAverage(long denominator) =>
            this / FromScalar((int)denominator);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int32x4 operator +(
            Int32x4 current,
            UInt8x4 toAccumulate) =>
            current + ConvertFrom_byte(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int32x4 operator +(
            UInt8x4 toAccumulate,
            Int32x4 current) =>
            ConvertFrom_byte(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int32x4 operator -(
            Int32x4 current,
            UInt8x4 toAccumulate) =>
            current - ConvertFrom_byte(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int32x4 operator -(
            UInt8x4 toAccumulate,
            Int32x4 current) =>
            ConvertFrom_byte(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref Int32x4 target,
            UInt8x4 value) =>
            AtomicAdd(ref target, ConvertFrom_byte(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int32x4 ConvertFrom_byte(
            UInt8x4 other) =>
            new Int32x4((int)other.X, (int)other.Y, (int)other.Z, (int)other.W);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt8x4 ConvertTo_byte(
            Int32x4 current) =>
            new UInt8x4((byte)current.X, (byte)current.Y, (byte)current.Z, (byte)current.W);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int32x4 IAccumulationVectorType<
            Int32x4,
            UInt8x4,
            byte>.ConvertFromBase(UInt8x4 other) =>
            ConvertFrom_byte(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt8x4 IAccumulationVectorType<
            Int32x4,
            UInt8x4,
            byte>.ConvertToBase(Int32x4 current) =>
            ConvertTo_byte(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public Int32x4 ComputeAverage(byte denominator) =>
            this / FromScalar((int)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int32x4 operator +(
            Int32x4 current,
            Int8x4 toAccumulate) =>
            current + ConvertFrom_sbyte(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int32x4 operator +(
            Int8x4 toAccumulate,
            Int32x4 current) =>
            ConvertFrom_sbyte(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int32x4 operator -(
            Int32x4 current,
            Int8x4 toAccumulate) =>
            current - ConvertFrom_sbyte(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int32x4 operator -(
            Int8x4 toAccumulate,
            Int32x4 current) =>
            ConvertFrom_sbyte(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref Int32x4 target,
            Int8x4 value) =>
            AtomicAdd(ref target, ConvertFrom_sbyte(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int32x4 ConvertFrom_sbyte(
            Int8x4 other) =>
            new Int32x4((int)other.X, (int)other.Y, (int)other.Z, (int)other.W);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int8x4 ConvertTo_sbyte(
            Int32x4 current) =>
            new Int8x4((sbyte)current.X, (sbyte)current.Y, (sbyte)current.Z, (sbyte)current.W);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int32x4 IAccumulationVectorType<
            Int32x4,
            Int8x4,
            sbyte>.ConvertFromBase(Int8x4 other) =>
            ConvertFrom_sbyte(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int8x4 IAccumulationVectorType<
            Int32x4,
            Int8x4,
            sbyte>.ConvertToBase(Int32x4 current) =>
            ConvertTo_sbyte(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public Int32x4 ComputeAverage(sbyte denominator) =>
            this / FromScalar((int)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int32x4 operator +(
            Int32x4 current,
            Int16x4 toAccumulate) =>
            current + ConvertFrom_short(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int32x4 operator +(
            Int16x4 toAccumulate,
            Int32x4 current) =>
            ConvertFrom_short(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int32x4 operator -(
            Int32x4 current,
            Int16x4 toAccumulate) =>
            current - ConvertFrom_short(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int32x4 operator -(
            Int16x4 toAccumulate,
            Int32x4 current) =>
            ConvertFrom_short(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(true)]
        public static void AtomicAdd(
            ref Int32x4 target,
            Int16x4 value) =>
            AtomicAdd(ref target, ConvertFrom_short(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int32x4 ConvertFrom_short(
            Int16x4 other) =>
            new Int32x4((int)other.X, (int)other.Y, (int)other.Z, (int)other.W);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int16x4 ConvertTo_short(
            Int32x4 current) =>
            new Int16x4((short)current.X, (short)current.Y, (short)current.Z, (short)current.W);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int32x4 IAccumulationVectorType<
            Int32x4,
            Int16x4,
            short>.ConvertFromBase(Int16x4 other) =>
            ConvertFrom_short(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int16x4 IAccumulationVectorType<
            Int32x4,
            Int16x4,
            short>.ConvertToBase(Int32x4 current) =>
            ConvertTo_short(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(true)]
        public Int32x4 ComputeAverage(short denominator) =>
            this / FromScalar((int)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int32x4 operator +(
            Int32x4 current,
            UInt16x4 toAccumulate) =>
            current + ConvertFrom_ushort(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int32x4 operator +(
            UInt16x4 toAccumulate,
            Int32x4 current) =>
            ConvertFrom_ushort(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int32x4 operator -(
            Int32x4 current,
            UInt16x4 toAccumulate) =>
            current - ConvertFrom_ushort(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int32x4 operator -(
            UInt16x4 toAccumulate,
            Int32x4 current) =>
            ConvertFrom_ushort(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref Int32x4 target,
            UInt16x4 value) =>
            AtomicAdd(ref target, ConvertFrom_ushort(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int32x4 ConvertFrom_ushort(
            UInt16x4 other) =>
            new Int32x4((int)other.X, (int)other.Y, (int)other.Z, (int)other.W);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt16x4 ConvertTo_ushort(
            Int32x4 current) =>
            new UInt16x4((ushort)current.X, (ushort)current.Y, (ushort)current.Z, (ushort)current.W);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int32x4 IAccumulationVectorType<
            Int32x4,
            UInt16x4,
            ushort>.ConvertFromBase(UInt16x4 other) =>
            ConvertFrom_ushort(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt16x4 IAccumulationVectorType<
            Int32x4,
            UInt16x4,
            ushort>.ConvertToBase(Int32x4 current) =>
            ConvertTo_ushort(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public Int32x4 ComputeAverage(ushort denominator) =>
            this / FromScalar((int)denominator);


        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int32x4 ConvertFrom_int(
            Int32x4 other) =>
            new Int32x4((int)other.X, (int)other.Y, (int)other.Z, (int)other.W);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int32x4 ConvertTo_int(
            Int32x4 current) =>
            new Int32x4((int)current.X, (int)current.Y, (int)current.Z, (int)current.W);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int32x4 IAccumulationVectorType<
            Int32x4,
            Int32x4,
            int>.ConvertFromBase(Int32x4 other) =>
            ConvertFrom_int(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int32x4 IAccumulationVectorType<
            Int32x4,
            Int32x4,
            int>.ConvertToBase(Int32x4 current) =>
            ConvertTo_int(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(true)]
        public Int32x4 ComputeAverage(int denominator) =>
            this / FromScalar((int)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int32x4 operator +(
            Int32x4 current,
            Float32x4 toAccumulate) =>
            current + ConvertFrom_float(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int32x4 operator +(
            Float32x4 toAccumulate,
            Int32x4 current) =>
            ConvertFrom_float(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int32x4 operator -(
            Int32x4 current,
            Float32x4 toAccumulate) =>
            current - ConvertFrom_float(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int32x4 operator -(
            Float32x4 toAccumulate,
            Int32x4 current) =>
            ConvertFrom_float(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(true)]
        public static void AtomicAdd(
            ref Int32x4 target,
            Float32x4 value) =>
            AtomicAdd(ref target, ConvertFrom_float(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int32x4 ConvertFrom_float(
            Float32x4 other) =>
            new Int32x4((int)other.X, (int)other.Y, (int)other.Z, (int)other.W);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float32x4 ConvertTo_float(
            Int32x4 current) =>
            new Float32x4((float)current.X, (float)current.Y, (float)current.Z, (float)current.W);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int32x4 IAccumulationVectorType<
            Int32x4,
            Float32x4,
            float>.ConvertFromBase(Float32x4 other) =>
            ConvertFrom_float(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float32x4 IAccumulationVectorType<
            Int32x4,
            Float32x4,
            float>.ConvertToBase(Int32x4 current) =>
            ConvertTo_float(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(true)]
        public Int32x4 ComputeAverage(float denominator) =>
            this / FromScalar((int)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int32x4 operator +(
            Int32x4 current,
            Float64x4 toAccumulate) =>
            current + ConvertFrom_double(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int32x4 operator +(
            Float64x4 toAccumulate,
            Int32x4 current) =>
            ConvertFrom_double(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int32x4 operator -(
            Int32x4 current,
            Float64x4 toAccumulate) =>
            current - ConvertFrom_double(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int32x4 operator -(
            Float64x4 toAccumulate,
            Int32x4 current) =>
            ConvertFrom_double(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(true)]
        public static void AtomicAdd(
            ref Int32x4 target,
            Float64x4 value) =>
            AtomicAdd(ref target, ConvertFrom_double(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int32x4 ConvertFrom_double(
            Float64x4 other) =>
            new Int32x4((int)other.X, (int)other.Y, (int)other.Z, (int)other.W);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float64x4 ConvertTo_double(
            Int32x4 current) =>
            new Float64x4((double)current.X, (double)current.Y, (double)current.Z, (double)current.W);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int32x4 IAccumulationVectorType<
            Int32x4,
            Float64x4,
            double>.ConvertFromBase(Float64x4 other) =>
            ConvertFrom_double(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float64x4 IAccumulationVectorType<
            Int32x4,
            Float64x4,
            double>.ConvertToBase(Int32x4 current) =>
            ConvertTo_double(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(true)]
        public Int32x4 ComputeAverage(double denominator) =>
            this / FromScalar((int)denominator);

        /// <summary>
        /// Converts this instance into an unsafe span instance.
        /// </summary>
        /// <returns>The readonly span instance.</returns>
        public unsafe ReadOnlySpan<int> AsSpan() =>
            new(Unsafe.AsPointer(ref Unsafe.AsRef(this)), 4);

        /// <summary>
        /// Iterates over all elements by applying the given iterator to each element.
        /// </summary>
        /// <typeparam name="TIterator">The managed iterator type.</typeparam>
        /// <param name="iterator">The iterator to invoke.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ForEach<TIterator>(ref TIterator iterator)
            where TIterator : struct, IVectorElementIterator<
            Int32x4,
            int>
        {
            iterator.Iterate(X, 0);
            iterator.Iterate(Y, 1);
            iterator.Iterate(Z, 2);
            iterator.Iterate(W, 3);
        }

        /// <summary>
        /// Converts this vector instance to a string.
        /// </summary>
        public override string ToString() =>
            $"{X}, {Y}, {Z}, {W}";

        /// <summary>
        /// Converts this vector instance to a string.
        /// </summary>
        public string ToString(string? format, IFormatProvider? formatProvider) =>
            $"{X.ToString(format, formatProvider)}, {Y.ToString(format, formatProvider)}, {Z.ToString(format, formatProvider)}, {W.ToString(format, formatProvider)}";

        /// <summary>
        /// Returns true.
        /// </summary>
        public static bool IsCanonical(Int32x4 value) => true;

        /// <summary>
        /// Returns false.
        /// </summary>
        public static bool IsComplexNumber(Int32x4 value) => false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsEvenInteger(Int32x4 value) =>
            int.IsEvenInteger(value.X) & int.IsEvenInteger(value.Y) & int.IsEvenInteger(value.Z) & int.IsEvenInteger(value.W);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsFinite(Int32x4 value) =>
            true;

        /// <summary>
        /// Returns false.
        /// </summary>
        public static bool IsImaginaryNumber(Int32x4 value) => false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsInfinity(Int32x4 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsInteger(Int32x4 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNaN(Int32x4 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNegative(Int32x4 value) =>
            int.IsNegative(value.X) & int.IsNegative(value.Y) & int.IsNegative(value.Z) & int.IsNegative(value.W);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNegativeInfinity(Int32x4 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNormal(Int32x4 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsOddInteger(Int32x4 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsPositive(Int32x4 value) =>
            int.IsPositive(value.X) & int.IsPositive(value.Y) & int.IsPositive(value.Z) & int.IsPositive(value.W);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsPositiveInfinity(Int32x4 value) =>
            false;

        /// <summary>
        /// Returns true.
        /// </summary>
        public static bool IsRealNumber(Int32x4 value) => true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsSubnormal(Int32x4 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsZero(Int32x4 value) =>
            value == Zero;

        /// <summary>
        /// Returns the absolute value.
        /// </summary>
        public static Int32x4 Abs(Int32x4 value) =>
            new Int32x4(Math.Abs(value.X), Math.Abs(value.Y), Math.Abs(value.Z), Math.Abs(value.W));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int32x4 operator +(Int32x4 left, Int32x4 right) =>
            new Int32x4((int)(left.X + right.X), (int)(left.Y + right.Y), (int)(left.Z + right.Z), (int)(left.W + right.W));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int32x4 operator --(Int32x4 value) => value - One;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int32x4 operator /(Int32x4 left, Int32x4 right) =>
            new Int32x4((int)(left.X / right.X), (int)(left.Y / right.Y), (int)(left.Z / right.Z), (int)(left.W / right.W));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int32x4 operator ++(Int32x4 value) => value + One;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int32x4 operator *(Int32x4 left, Int32x4 right) =>
            new Int32x4((int)(left.X * right.X), (int)(left.Y * right.Y), (int)(left.Z * right.Z), (int)(left.W * right.W));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int32x4 operator -(Int32x4 left, Int32x4 right) =>
            new Int32x4((int)(left.X - right.X), (int)(left.Y - right.Y), (int)(left.Z - right.Z), (int)(left.W - right.W));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int32x4 operator -(Int32x4 value) =>
            new Int32x4((int)-value.X, (int)-value.Y, (int)-value.Z, (int)-value.W);

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int32x4 operator +(Int32x4 value) => value;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int32x4 MaxMagnitude(Int32x4 x, Int32x4 y) =>
            new Int32x4(int.MaxMagnitude(x.X, y.X), int.MaxMagnitude(x.Y, y.Y), int.MaxMagnitude(x.Z, y.Z), int.MaxMagnitude(x.W, y.W));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int32x4 MaxMagnitudeNumber(Int32x4 x, Int32x4 y) =>
            MaxMagnitude(x, y);

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int32x4 MinMagnitude(Int32x4 x, Int32x4 y) =>
            new Int32x4(int.MinMagnitude(x.X, y.X), int.MinMagnitude(x.Y, y.Y), int.MinMagnitude(x.Z, y.Z), int.MinMagnitude(x.W, y.W));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int32x4 MinMagnitudeNumber(Int32x4 x, Int32x4 y) =>
            MinMagnitude(x, y);

        // Not supported operations

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static Int32x4 IParsable<Int32x4>.Parse(
            string s,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static Int32x4 ISpanParsable<Int32x4>.Parse(
            ReadOnlySpan<char> s,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static Int32x4 INumberBase<Int32x4>.Parse(
            ReadOnlySpan<char> s,
            NumberStyles style,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static Int32x4 INumberBase<Int32x4>.Parse(
            string s,
            NumberStyles style,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        bool ISpanFormattable.TryFormat(
            Span<char> destination,
            out int charsWritten,
            ReadOnlySpan<char> format,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool IParsable<Int32x4>.TryParse(
            string? s,
            IFormatProvider? provider,
            out Int32x4 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given span into a vectorized instance.
        /// </summary>
        static bool ISpanParsable<Int32x4>.TryParse(
            ReadOnlySpan<char> s,
            IFormatProvider? provider,
            out Int32x4 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool INumberBase<Int32x4>.TryParse(
            ReadOnlySpan<char> s,
            NumberStyles style,
            IFormatProvider? provider,
            out Int32x4 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool INumberBase<Int32x4>.TryParse(
            string? s,
            NumberStyles style,
            IFormatProvider? provider,
            out Int32x4 result) =>
            throw new NotSupportedException();

        static bool INumberBase<Int32x4>.TryConvertFromChecked<TOther>(
            TOther value,
            out Int32x4 result) =>
            throw new NotSupportedException();
        static bool INumberBase<Int32x4>.TryConvertFromSaturating<TOther>(
            TOther value,
            out Int32x4 result) =>
            throw new NotSupportedException();
        static bool INumberBase<Int32x4>.TryConvertFromTruncating<TOther>(
            TOther value,
            out Int32x4 result) =>
            throw new NotSupportedException();
        static bool INumberBase<Int32x4>.TryConvertToChecked<TOther>(
            Int32x4 value,
            out TOther result) =>
            throw new NotSupportedException();
        static bool INumberBase<Int32x4>.TryConvertToSaturating<TOther>(
            Int32x4 value,
            out TOther result) =>
            throw new NotSupportedException();
        static bool INumberBase<Int32x4>.TryConvertToTruncating<TOther>(
            Int32x4 value,
            out TOther result) =>
            throw new NotSupportedException();
    }

    /// <summary>
    /// Represents a vectorized int type with length 8.
    /// </summary>
    public readonly record struct Int32x8(
        int X, int Y, int Z, int W, int I, int J, int K, int L) :
        IVectorType<Int32x8, int>
        , IAccumulationVectorType<
            Int32x8,
            UInt8x8,
            byte>
        , IAccumulationVectorType<
            Int32x8,
            Int8x8,
            sbyte>
        , IAccumulationVectorType<
            Int32x8,
            Int16x8,
            short>
        , IAccumulationVectorType<
            Int32x8,
            UInt16x8,
            ushort>
        , IAccumulationVectorType<
            Int32x8,
            Int32x8,
            int>
        , IAccumulationVectorType<
            Int32x8,
            Float32x8,
            float>
        , IAccumulationVectorType<
            Int32x8,
            Float64x8,
            double>
    {
        /// <summary>
        /// The offset of the X field in bytes.
        /// </summary>
        public static readonly int OffsetX =
            sizeof(int) * 0;

        /// <summary>
        /// The offset of the X field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrX =>
            new UIntPtr((uint)OffsetX);
        /// <summary>
        /// The offset of the Y field in bytes.
        /// </summary>
        public static readonly int OffsetY =
            sizeof(int) * 1;

        /// <summary>
        /// The offset of the Y field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrY =>
            new UIntPtr((uint)OffsetY);
        /// <summary>
        /// The offset of the Z field in bytes.
        /// </summary>
        public static readonly int OffsetZ =
            sizeof(int) * 2;

        /// <summary>
        /// The offset of the Z field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrZ =>
            new UIntPtr((uint)OffsetZ);
        /// <summary>
        /// The offset of the W field in bytes.
        /// </summary>
        public static readonly int OffsetW =
            sizeof(int) * 3;

        /// <summary>
        /// The offset of the W field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrW =>
            new UIntPtr((uint)OffsetW);
        /// <summary>
        /// The offset of the I field in bytes.
        /// </summary>
        public static readonly int OffsetI =
            sizeof(int) * 4;

        /// <summary>
        /// The offset of the I field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrI =>
            new UIntPtr((uint)OffsetI);
        /// <summary>
        /// The offset of the J field in bytes.
        /// </summary>
        public static readonly int OffsetJ =
            sizeof(int) * 5;

        /// <summary>
        /// The offset of the J field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrJ =>
            new UIntPtr((uint)OffsetJ);
        /// <summary>
        /// The offset of the K field in bytes.
        /// </summary>
        public static readonly int OffsetK =
            sizeof(int) * 6;

        /// <summary>
        /// The offset of the K field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrK =>
            new UIntPtr((uint)OffsetK);
        /// <summary>
        /// The offset of the L field in bytes.
        /// </summary>
        public static readonly int OffsetL =
            sizeof(int) * 7;

        /// <summary>
        /// The offset of the L field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrL =>
            new UIntPtr((uint)OffsetL);

        /// <summary>
        /// Returns the length of this vector which is 8.
        /// </summary>
        public static int Length => 8;

        /// <summary>
        /// Returns the radix of the underlying value.
        /// </summary>
        public static int Radix => 10;

        /// <summary>
        /// Returns an invalid value (min [signed types], max value [unsigned] or NaN).
        /// </summary>
        public static Int32x8 Invalid => FromScalar(
            int.MinValue
        );

        /// <summary>
        /// Returns the value zero.
        /// </summary>
        public static Int32x8 Zero => new();

        /// <summary>
        /// Returns the value one.
        /// </summary>
        public static Int32x8 One => FromScalar((1));

        /// <summary>
        /// Returns the value zero.
        /// </summary>
        public static Int32x8 AdditiveIdentity => Zero;

        /// <summary>
        /// Returns the value one.
        /// </summary>
        public static Int32x8 MultiplicativeIdentity => One;

        /// <summary>
        /// Computes the min value of both.
        /// </summary>
        /// <param name="first">The first value.</param>
        /// <param name="second">The second value.</param>
        /// <returns>The min value.</returns>
        public static Int32x8 Min(
            Int32x8 first,
            Int32x8 second) =>
            new Int32x8((int)Math.Min(first.X, second.X), (int)Math.Min(first.Y, second.Y), (int)Math.Min(first.Z, second.Z), (int)Math.Min(first.W, second.W), (int)Math.Min(first.I, second.I), (int)Math.Min(first.J, second.J), (int)Math.Min(first.K, second.K), (int)Math.Min(first.L, second.L));

        /// <summary>
        /// Computes the max value of both.
        /// </summary>
        /// <param name="first">The first value.</param>
        /// <param name="second">The second value.</param>
        /// <returns>The max value.</returns>
        public static Int32x8 Max(
            Int32x8 first,
            Int32x8 second) =>
            new Int32x8((int)Math.Max(first.X, second.X), (int)Math.Max(first.Y, second.Y), (int)Math.Max(first.Z, second.Z), (int)Math.Max(first.W, second.W), (int)Math.Max(first.I, second.I), (int)Math.Max(first.J, second.J), (int)Math.Max(first.K, second.K), (int)Math.Max(first.L, second.L));

        /// <summary>
        /// Clamps the given value.
        /// </summary>
        /// <param name="value">The value to clamp.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The clamped value.</returns>
        public static Int32x8 Clamp(
            Int32x8 value,
            Int32x8 min,
            Int32x8 max) =>
            Max(Min(value, max), min);

        /// <summary>
        /// Creates a random scalar instance falling into the range of min max.
        /// </summary>
        /// <param name="random">The random provider to use.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The created random scalar instance.</returns>
        public static int GetRandomScalar<TRandom>(
            ref TRandom random,
            int min,
            int max)
            where TRandom : struct, IRandomProvider =>
            (int)RandomExtensions.
                Next(ref random, min, max);

        /// <summary>
        /// Creates a random vector instance falling into the range of min max.
        /// </summary>
        /// <param name="random">The random provider to use.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The created random vector instance.</returns>
        public static Int32x8 GetRandom<TRandom>(
            ref TRandom random,
            Int32x8 min,
            Int32x8 max)
            where TRandom : struct, IRandomProvider
        {
            int x = GetRandomScalar(
                ref random, min.X, max.X);
            int y = GetRandomScalar(
                ref random, min.Y, max.Y);
            int z = GetRandomScalar(
                ref random, min.Z, max.Z);
            int w = GetRandomScalar(
                ref random, min.W, max.W);
            int i = GetRandomScalar(
                ref random, min.I, max.I);
            int j = GetRandomScalar(
                ref random, min.J, max.J);
            int k = GetRandomScalar(
                ref random, min.K, max.K);
            int l = GetRandomScalar(
                ref random, min.L, max.L);
            return new Int32x8(x, y, z, w, i, j, k, l);
        }

        /// <summary>
        /// Creates a vector instance from the given source view.
        /// </summary>
        /// <typeparam name="TStride">The custom stride type.</typeparam>
        /// <param name="sourceView">The source view.</param>
        /// <param name="index">The source base index.</param>
        /// <returns>The vector instance.</returns>
        public static Int32x8 FromElementView<TStride>(
            ArrayView1D<int, TStride> sourceView,
            Index1D index)
            where TStride : struct, IStride1D =>
            new Int32x8(
                sourceView[index + 0],
                sourceView[index + 1],
                sourceView[index + 2],
                sourceView[index + 3],
                sourceView[index + 4],
                sourceView[index + 5],
                sourceView[index + 6],
                sourceView[index + 7]
                );

        /// <summary>
        /// Serializes the current vector instance into the given target view.
        /// </summary>
        /// <typeparam name="TStride">The custom stride type.</typeparam>
        /// <param name="targetView">The target view.</param>
        /// <param name="index">The target base index.</param>
        public void ToElementView<TStride>(
            ArrayView1D<int, TStride> targetView,
            Index1D index)
            where TStride : struct, IStride1D
        {
            targetView[index + 0] = X;
            targetView[index + 1] = Y;
            targetView[index + 2] = Z;
            targetView[index + 3] = W;
            targetView[index + 4] = I;
            targetView[index + 5] = J;
            targetView[index + 6] = K;
            targetView[index + 7] = L;
        }

        /// <summary>
        /// Creates a vector instance from the given source view.
        /// </summary>
        /// <param name="sourceView">The source view.</param>
        /// <param name="index">The source base index.</param>
        /// <returns>The vector instance.</returns>
        public static Int32x8 FromElementView(
            SingleVectorView<int> sourceView,
            Index1D index) =>
            new Int32x8(
                sourceView[index + 0],
                sourceView[index + 1],
                sourceView[index + 2],
                sourceView[index + 3],
                sourceView[index + 4],
                sourceView[index + 5],
                sourceView[index + 6],
                sourceView[index + 7]
                );

        /// <summary>
        /// Serializes the current vector instance into the given target view.
        /// </summary>
        /// <param name="targetView">The target view.</param>
        /// <param name="index">The target base index.</param>
        public void ToElementView(
            SingleVectorView<int> targetView,
            Index1D index)
        {
            targetView[index + 0] = X;
            targetView[index + 1] = Y;
            targetView[index + 2] = Z;
            targetView[index + 3] = W;
            targetView[index + 4] = I;
            targetView[index + 5] = J;
            targetView[index + 6] = K;
            targetView[index + 7] = L;
        }

        /// <summary>
        /// Converts a scalar value into the current vectorized type.
        /// </summary>
        /// <param name="scalar">The scalar element type.</param>
        /// <returns>The created vectorized type.</returns>
        public static Int32x8 FromScalar(int scalar) =>
            new Int32x8(scalar, scalar, scalar, scalar, scalar, scalar, scalar, scalar);

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        public static void AtomicAdd(ref Int32x8 target, Int32x8 value)
        {
            ref var elementRef = ref Unsafe.As<Int32x8, int>(
                ref target);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrX),
                value.X);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrY),
                value.Y);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrZ),
                value.Z);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrW),
                value.W);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrI),
                value.I);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrJ),
                value.J);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrK),
                value.K);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrL),
                value.L);
        }

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        public Int32x8 ComputeAverage(long denominator) =>
            this / FromScalar((int)denominator);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int32x8 operator +(
            Int32x8 current,
            UInt8x8 toAccumulate) =>
            current + ConvertFrom_byte(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int32x8 operator +(
            UInt8x8 toAccumulate,
            Int32x8 current) =>
            ConvertFrom_byte(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int32x8 operator -(
            Int32x8 current,
            UInt8x8 toAccumulate) =>
            current - ConvertFrom_byte(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int32x8 operator -(
            UInt8x8 toAccumulate,
            Int32x8 current) =>
            ConvertFrom_byte(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref Int32x8 target,
            UInt8x8 value) =>
            AtomicAdd(ref target, ConvertFrom_byte(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int32x8 ConvertFrom_byte(
            UInt8x8 other) =>
            new Int32x8((int)other.X, (int)other.Y, (int)other.Z, (int)other.W, (int)other.I, (int)other.J, (int)other.K, (int)other.L);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt8x8 ConvertTo_byte(
            Int32x8 current) =>
            new UInt8x8((byte)current.X, (byte)current.Y, (byte)current.Z, (byte)current.W, (byte)current.I, (byte)current.J, (byte)current.K, (byte)current.L);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int32x8 IAccumulationVectorType<
            Int32x8,
            UInt8x8,
            byte>.ConvertFromBase(UInt8x8 other) =>
            ConvertFrom_byte(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt8x8 IAccumulationVectorType<
            Int32x8,
            UInt8x8,
            byte>.ConvertToBase(Int32x8 current) =>
            ConvertTo_byte(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public Int32x8 ComputeAverage(byte denominator) =>
            this / FromScalar((int)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int32x8 operator +(
            Int32x8 current,
            Int8x8 toAccumulate) =>
            current + ConvertFrom_sbyte(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int32x8 operator +(
            Int8x8 toAccumulate,
            Int32x8 current) =>
            ConvertFrom_sbyte(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int32x8 operator -(
            Int32x8 current,
            Int8x8 toAccumulate) =>
            current - ConvertFrom_sbyte(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int32x8 operator -(
            Int8x8 toAccumulate,
            Int32x8 current) =>
            ConvertFrom_sbyte(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref Int32x8 target,
            Int8x8 value) =>
            AtomicAdd(ref target, ConvertFrom_sbyte(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int32x8 ConvertFrom_sbyte(
            Int8x8 other) =>
            new Int32x8((int)other.X, (int)other.Y, (int)other.Z, (int)other.W, (int)other.I, (int)other.J, (int)other.K, (int)other.L);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int8x8 ConvertTo_sbyte(
            Int32x8 current) =>
            new Int8x8((sbyte)current.X, (sbyte)current.Y, (sbyte)current.Z, (sbyte)current.W, (sbyte)current.I, (sbyte)current.J, (sbyte)current.K, (sbyte)current.L);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int32x8 IAccumulationVectorType<
            Int32x8,
            Int8x8,
            sbyte>.ConvertFromBase(Int8x8 other) =>
            ConvertFrom_sbyte(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int8x8 IAccumulationVectorType<
            Int32x8,
            Int8x8,
            sbyte>.ConvertToBase(Int32x8 current) =>
            ConvertTo_sbyte(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public Int32x8 ComputeAverage(sbyte denominator) =>
            this / FromScalar((int)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int32x8 operator +(
            Int32x8 current,
            Int16x8 toAccumulate) =>
            current + ConvertFrom_short(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int32x8 operator +(
            Int16x8 toAccumulate,
            Int32x8 current) =>
            ConvertFrom_short(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int32x8 operator -(
            Int32x8 current,
            Int16x8 toAccumulate) =>
            current - ConvertFrom_short(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int32x8 operator -(
            Int16x8 toAccumulate,
            Int32x8 current) =>
            ConvertFrom_short(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(true)]
        public static void AtomicAdd(
            ref Int32x8 target,
            Int16x8 value) =>
            AtomicAdd(ref target, ConvertFrom_short(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int32x8 ConvertFrom_short(
            Int16x8 other) =>
            new Int32x8((int)other.X, (int)other.Y, (int)other.Z, (int)other.W, (int)other.I, (int)other.J, (int)other.K, (int)other.L);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int16x8 ConvertTo_short(
            Int32x8 current) =>
            new Int16x8((short)current.X, (short)current.Y, (short)current.Z, (short)current.W, (short)current.I, (short)current.J, (short)current.K, (short)current.L);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int32x8 IAccumulationVectorType<
            Int32x8,
            Int16x8,
            short>.ConvertFromBase(Int16x8 other) =>
            ConvertFrom_short(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int16x8 IAccumulationVectorType<
            Int32x8,
            Int16x8,
            short>.ConvertToBase(Int32x8 current) =>
            ConvertTo_short(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(true)]
        public Int32x8 ComputeAverage(short denominator) =>
            this / FromScalar((int)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int32x8 operator +(
            Int32x8 current,
            UInt16x8 toAccumulate) =>
            current + ConvertFrom_ushort(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int32x8 operator +(
            UInt16x8 toAccumulate,
            Int32x8 current) =>
            ConvertFrom_ushort(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int32x8 operator -(
            Int32x8 current,
            UInt16x8 toAccumulate) =>
            current - ConvertFrom_ushort(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int32x8 operator -(
            UInt16x8 toAccumulate,
            Int32x8 current) =>
            ConvertFrom_ushort(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref Int32x8 target,
            UInt16x8 value) =>
            AtomicAdd(ref target, ConvertFrom_ushort(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int32x8 ConvertFrom_ushort(
            UInt16x8 other) =>
            new Int32x8((int)other.X, (int)other.Y, (int)other.Z, (int)other.W, (int)other.I, (int)other.J, (int)other.K, (int)other.L);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt16x8 ConvertTo_ushort(
            Int32x8 current) =>
            new UInt16x8((ushort)current.X, (ushort)current.Y, (ushort)current.Z, (ushort)current.W, (ushort)current.I, (ushort)current.J, (ushort)current.K, (ushort)current.L);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int32x8 IAccumulationVectorType<
            Int32x8,
            UInt16x8,
            ushort>.ConvertFromBase(UInt16x8 other) =>
            ConvertFrom_ushort(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt16x8 IAccumulationVectorType<
            Int32x8,
            UInt16x8,
            ushort>.ConvertToBase(Int32x8 current) =>
            ConvertTo_ushort(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public Int32x8 ComputeAverage(ushort denominator) =>
            this / FromScalar((int)denominator);


        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int32x8 ConvertFrom_int(
            Int32x8 other) =>
            new Int32x8((int)other.X, (int)other.Y, (int)other.Z, (int)other.W, (int)other.I, (int)other.J, (int)other.K, (int)other.L);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int32x8 ConvertTo_int(
            Int32x8 current) =>
            new Int32x8((int)current.X, (int)current.Y, (int)current.Z, (int)current.W, (int)current.I, (int)current.J, (int)current.K, (int)current.L);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int32x8 IAccumulationVectorType<
            Int32x8,
            Int32x8,
            int>.ConvertFromBase(Int32x8 other) =>
            ConvertFrom_int(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int32x8 IAccumulationVectorType<
            Int32x8,
            Int32x8,
            int>.ConvertToBase(Int32x8 current) =>
            ConvertTo_int(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(true)]
        public Int32x8 ComputeAverage(int denominator) =>
            this / FromScalar((int)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int32x8 operator +(
            Int32x8 current,
            Float32x8 toAccumulate) =>
            current + ConvertFrom_float(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int32x8 operator +(
            Float32x8 toAccumulate,
            Int32x8 current) =>
            ConvertFrom_float(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int32x8 operator -(
            Int32x8 current,
            Float32x8 toAccumulate) =>
            current - ConvertFrom_float(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int32x8 operator -(
            Float32x8 toAccumulate,
            Int32x8 current) =>
            ConvertFrom_float(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(true)]
        public static void AtomicAdd(
            ref Int32x8 target,
            Float32x8 value) =>
            AtomicAdd(ref target, ConvertFrom_float(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int32x8 ConvertFrom_float(
            Float32x8 other) =>
            new Int32x8((int)other.X, (int)other.Y, (int)other.Z, (int)other.W, (int)other.I, (int)other.J, (int)other.K, (int)other.L);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float32x8 ConvertTo_float(
            Int32x8 current) =>
            new Float32x8((float)current.X, (float)current.Y, (float)current.Z, (float)current.W, (float)current.I, (float)current.J, (float)current.K, (float)current.L);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int32x8 IAccumulationVectorType<
            Int32x8,
            Float32x8,
            float>.ConvertFromBase(Float32x8 other) =>
            ConvertFrom_float(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float32x8 IAccumulationVectorType<
            Int32x8,
            Float32x8,
            float>.ConvertToBase(Int32x8 current) =>
            ConvertTo_float(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(true)]
        public Int32x8 ComputeAverage(float denominator) =>
            this / FromScalar((int)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int32x8 operator +(
            Int32x8 current,
            Float64x8 toAccumulate) =>
            current + ConvertFrom_double(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int32x8 operator +(
            Float64x8 toAccumulate,
            Int32x8 current) =>
            ConvertFrom_double(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int32x8 operator -(
            Int32x8 current,
            Float64x8 toAccumulate) =>
            current - ConvertFrom_double(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int32x8 operator -(
            Float64x8 toAccumulate,
            Int32x8 current) =>
            ConvertFrom_double(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(true)]
        public static void AtomicAdd(
            ref Int32x8 target,
            Float64x8 value) =>
            AtomicAdd(ref target, ConvertFrom_double(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int32x8 ConvertFrom_double(
            Float64x8 other) =>
            new Int32x8((int)other.X, (int)other.Y, (int)other.Z, (int)other.W, (int)other.I, (int)other.J, (int)other.K, (int)other.L);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float64x8 ConvertTo_double(
            Int32x8 current) =>
            new Float64x8((double)current.X, (double)current.Y, (double)current.Z, (double)current.W, (double)current.I, (double)current.J, (double)current.K, (double)current.L);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int32x8 IAccumulationVectorType<
            Int32x8,
            Float64x8,
            double>.ConvertFromBase(Float64x8 other) =>
            ConvertFrom_double(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float64x8 IAccumulationVectorType<
            Int32x8,
            Float64x8,
            double>.ConvertToBase(Int32x8 current) =>
            ConvertTo_double(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(true)]
        public Int32x8 ComputeAverage(double denominator) =>
            this / FromScalar((int)denominator);

        /// <summary>
        /// Converts this instance into an unsafe span instance.
        /// </summary>
        /// <returns>The readonly span instance.</returns>
        public unsafe ReadOnlySpan<int> AsSpan() =>
            new(Unsafe.AsPointer(ref Unsafe.AsRef(this)), 8);

        /// <summary>
        /// Iterates over all elements by applying the given iterator to each element.
        /// </summary>
        /// <typeparam name="TIterator">The managed iterator type.</typeparam>
        /// <param name="iterator">The iterator to invoke.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ForEach<TIterator>(ref TIterator iterator)
            where TIterator : struct, IVectorElementIterator<
            Int32x8,
            int>
        {
            iterator.Iterate(X, 0);
            iterator.Iterate(Y, 1);
            iterator.Iterate(Z, 2);
            iterator.Iterate(W, 3);
            iterator.Iterate(I, 4);
            iterator.Iterate(J, 5);
            iterator.Iterate(K, 6);
            iterator.Iterate(L, 7);
        }

        /// <summary>
        /// Converts this vector instance to a string.
        /// </summary>
        public override string ToString() =>
            $"{X}, {Y}, {Z}, {W}, {I}, {J}, {K}, {L}";

        /// <summary>
        /// Converts this vector instance to a string.
        /// </summary>
        public string ToString(string? format, IFormatProvider? formatProvider) =>
            $"{X.ToString(format, formatProvider)}, {Y.ToString(format, formatProvider)}, {Z.ToString(format, formatProvider)}, {W.ToString(format, formatProvider)}, {I.ToString(format, formatProvider)}, {J.ToString(format, formatProvider)}, {K.ToString(format, formatProvider)}, {L.ToString(format, formatProvider)}";

        /// <summary>
        /// Returns true.
        /// </summary>
        public static bool IsCanonical(Int32x8 value) => true;

        /// <summary>
        /// Returns false.
        /// </summary>
        public static bool IsComplexNumber(Int32x8 value) => false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsEvenInteger(Int32x8 value) =>
            int.IsEvenInteger(value.X) & int.IsEvenInteger(value.Y) & int.IsEvenInteger(value.Z) & int.IsEvenInteger(value.W) & int.IsEvenInteger(value.I) & int.IsEvenInteger(value.J) & int.IsEvenInteger(value.K) & int.IsEvenInteger(value.L);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsFinite(Int32x8 value) =>
            true;

        /// <summary>
        /// Returns false.
        /// </summary>
        public static bool IsImaginaryNumber(Int32x8 value) => false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsInfinity(Int32x8 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsInteger(Int32x8 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNaN(Int32x8 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNegative(Int32x8 value) =>
            int.IsNegative(value.X) & int.IsNegative(value.Y) & int.IsNegative(value.Z) & int.IsNegative(value.W) & int.IsNegative(value.I) & int.IsNegative(value.J) & int.IsNegative(value.K) & int.IsNegative(value.L);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNegativeInfinity(Int32x8 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNormal(Int32x8 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsOddInteger(Int32x8 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsPositive(Int32x8 value) =>
            int.IsPositive(value.X) & int.IsPositive(value.Y) & int.IsPositive(value.Z) & int.IsPositive(value.W) & int.IsPositive(value.I) & int.IsPositive(value.J) & int.IsPositive(value.K) & int.IsPositive(value.L);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsPositiveInfinity(Int32x8 value) =>
            false;

        /// <summary>
        /// Returns true.
        /// </summary>
        public static bool IsRealNumber(Int32x8 value) => true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsSubnormal(Int32x8 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsZero(Int32x8 value) =>
            value == Zero;

        /// <summary>
        /// Returns the absolute value.
        /// </summary>
        public static Int32x8 Abs(Int32x8 value) =>
            new Int32x8(Math.Abs(value.X), Math.Abs(value.Y), Math.Abs(value.Z), Math.Abs(value.W), Math.Abs(value.I), Math.Abs(value.J), Math.Abs(value.K), Math.Abs(value.L));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int32x8 operator +(Int32x8 left, Int32x8 right) =>
            new Int32x8((int)(left.X + right.X), (int)(left.Y + right.Y), (int)(left.Z + right.Z), (int)(left.W + right.W), (int)(left.I + right.I), (int)(left.J + right.J), (int)(left.K + right.K), (int)(left.L + right.L));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int32x8 operator --(Int32x8 value) => value - One;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int32x8 operator /(Int32x8 left, Int32x8 right) =>
            new Int32x8((int)(left.X / right.X), (int)(left.Y / right.Y), (int)(left.Z / right.Z), (int)(left.W / right.W), (int)(left.I / right.I), (int)(left.J / right.J), (int)(left.K / right.K), (int)(left.L / right.L));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int32x8 operator ++(Int32x8 value) => value + One;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int32x8 operator *(Int32x8 left, Int32x8 right) =>
            new Int32x8((int)(left.X * right.X), (int)(left.Y * right.Y), (int)(left.Z * right.Z), (int)(left.W * right.W), (int)(left.I * right.I), (int)(left.J * right.J), (int)(left.K * right.K), (int)(left.L * right.L));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int32x8 operator -(Int32x8 left, Int32x8 right) =>
            new Int32x8((int)(left.X - right.X), (int)(left.Y - right.Y), (int)(left.Z - right.Z), (int)(left.W - right.W), (int)(left.I - right.I), (int)(left.J - right.J), (int)(left.K - right.K), (int)(left.L - right.L));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int32x8 operator -(Int32x8 value) =>
            new Int32x8((int)-value.X, (int)-value.Y, (int)-value.Z, (int)-value.W, (int)-value.I, (int)-value.J, (int)-value.K, (int)-value.L);

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int32x8 operator +(Int32x8 value) => value;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int32x8 MaxMagnitude(Int32x8 x, Int32x8 y) =>
            new Int32x8(int.MaxMagnitude(x.X, y.X), int.MaxMagnitude(x.Y, y.Y), int.MaxMagnitude(x.Z, y.Z), int.MaxMagnitude(x.W, y.W), int.MaxMagnitude(x.I, y.I), int.MaxMagnitude(x.J, y.J), int.MaxMagnitude(x.K, y.K), int.MaxMagnitude(x.L, y.L));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int32x8 MaxMagnitudeNumber(Int32x8 x, Int32x8 y) =>
            MaxMagnitude(x, y);

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int32x8 MinMagnitude(Int32x8 x, Int32x8 y) =>
            new Int32x8(int.MinMagnitude(x.X, y.X), int.MinMagnitude(x.Y, y.Y), int.MinMagnitude(x.Z, y.Z), int.MinMagnitude(x.W, y.W), int.MinMagnitude(x.I, y.I), int.MinMagnitude(x.J, y.J), int.MinMagnitude(x.K, y.K), int.MinMagnitude(x.L, y.L));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int32x8 MinMagnitudeNumber(Int32x8 x, Int32x8 y) =>
            MinMagnitude(x, y);

        // Not supported operations

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static Int32x8 IParsable<Int32x8>.Parse(
            string s,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static Int32x8 ISpanParsable<Int32x8>.Parse(
            ReadOnlySpan<char> s,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static Int32x8 INumberBase<Int32x8>.Parse(
            ReadOnlySpan<char> s,
            NumberStyles style,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static Int32x8 INumberBase<Int32x8>.Parse(
            string s,
            NumberStyles style,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        bool ISpanFormattable.TryFormat(
            Span<char> destination,
            out int charsWritten,
            ReadOnlySpan<char> format,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool IParsable<Int32x8>.TryParse(
            string? s,
            IFormatProvider? provider,
            out Int32x8 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given span into a vectorized instance.
        /// </summary>
        static bool ISpanParsable<Int32x8>.TryParse(
            ReadOnlySpan<char> s,
            IFormatProvider? provider,
            out Int32x8 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool INumberBase<Int32x8>.TryParse(
            ReadOnlySpan<char> s,
            NumberStyles style,
            IFormatProvider? provider,
            out Int32x8 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool INumberBase<Int32x8>.TryParse(
            string? s,
            NumberStyles style,
            IFormatProvider? provider,
            out Int32x8 result) =>
            throw new NotSupportedException();

        static bool INumberBase<Int32x8>.TryConvertFromChecked<TOther>(
            TOther value,
            out Int32x8 result) =>
            throw new NotSupportedException();
        static bool INumberBase<Int32x8>.TryConvertFromSaturating<TOther>(
            TOther value,
            out Int32x8 result) =>
            throw new NotSupportedException();
        static bool INumberBase<Int32x8>.TryConvertFromTruncating<TOther>(
            TOther value,
            out Int32x8 result) =>
            throw new NotSupportedException();
        static bool INumberBase<Int32x8>.TryConvertToChecked<TOther>(
            Int32x8 value,
            out TOther result) =>
            throw new NotSupportedException();
        static bool INumberBase<Int32x8>.TryConvertToSaturating<TOther>(
            Int32x8 value,
            out TOther result) =>
            throw new NotSupportedException();
        static bool INumberBase<Int32x8>.TryConvertToTruncating<TOther>(
            Int32x8 value,
            out TOther result) =>
            throw new NotSupportedException();
    }

    /// <summary>
    /// Represents a vectorized long type with length 2.
    /// </summary>
    public readonly record struct Int64x2(
        long X, long Y) :
        IVectorType<Int64x2, long>
        , IAccumulationVectorType<
            Int64x2,
            UInt8x2,
            byte>
        , IAccumulationVectorType<
            Int64x2,
            Int8x2,
            sbyte>
        , IAccumulationVectorType<
            Int64x2,
            Int16x2,
            short>
        , IAccumulationVectorType<
            Int64x2,
            UInt16x2,
            ushort>
        , IAccumulationVectorType<
            Int64x2,
            Int32x2,
            int>
        , IAccumulationVectorType<
            Int64x2,
            UInt32x2,
            uint>
        , IAccumulationVectorType<
            Int64x2,
            Float32x2,
            float>
        , IAccumulationVectorType<
            Int64x2,
            Float64x2,
            double>
    {
        /// <summary>
        /// The offset of the X field in bytes.
        /// </summary>
        public static readonly int OffsetX =
            sizeof(long) * 0;

        /// <summary>
        /// The offset of the X field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrX =>
            new UIntPtr((uint)OffsetX);
        /// <summary>
        /// The offset of the Y field in bytes.
        /// </summary>
        public static readonly int OffsetY =
            sizeof(long) * 1;

        /// <summary>
        /// The offset of the Y field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrY =>
            new UIntPtr((uint)OffsetY);

        /// <summary>
        /// Returns the length of this vector which is 2.
        /// </summary>
        public static int Length => 2;

        /// <summary>
        /// Returns the radix of the underlying value.
        /// </summary>
        public static int Radix => 10;

        /// <summary>
        /// Returns an invalid value (min [signed types], max value [unsigned] or NaN).
        /// </summary>
        public static Int64x2 Invalid => FromScalar(
            long.MinValue
        );

        /// <summary>
        /// Returns the value zero.
        /// </summary>
        public static Int64x2 Zero => new();

        /// <summary>
        /// Returns the value one.
        /// </summary>
        public static Int64x2 One => FromScalar((1));

        /// <summary>
        /// Returns the value zero.
        /// </summary>
        public static Int64x2 AdditiveIdentity => Zero;

        /// <summary>
        /// Returns the value one.
        /// </summary>
        public static Int64x2 MultiplicativeIdentity => One;

        /// <summary>
        /// Computes the min value of both.
        /// </summary>
        /// <param name="first">The first value.</param>
        /// <param name="second">The second value.</param>
        /// <returns>The min value.</returns>
        public static Int64x2 Min(
            Int64x2 first,
            Int64x2 second) =>
            new Int64x2((long)Math.Min(first.X, second.X), (long)Math.Min(first.Y, second.Y));

        /// <summary>
        /// Computes the max value of both.
        /// </summary>
        /// <param name="first">The first value.</param>
        /// <param name="second">The second value.</param>
        /// <returns>The max value.</returns>
        public static Int64x2 Max(
            Int64x2 first,
            Int64x2 second) =>
            new Int64x2((long)Math.Max(first.X, second.X), (long)Math.Max(first.Y, second.Y));

        /// <summary>
        /// Clamps the given value.
        /// </summary>
        /// <param name="value">The value to clamp.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The clamped value.</returns>
        public static Int64x2 Clamp(
            Int64x2 value,
            Int64x2 min,
            Int64x2 max) =>
            Max(Min(value, max), min);

        /// <summary>
        /// Creates a random scalar instance falling into the range of min max.
        /// </summary>
        /// <param name="random">The random provider to use.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The created random scalar instance.</returns>
        public static long GetRandomScalar<TRandom>(
            ref TRandom random,
            long min,
            long max)
            where TRandom : struct, IRandomProvider =>
            (long)RandomExtensions.
                Next(ref random, min, max);

        /// <summary>
        /// Creates a random vector instance falling into the range of min max.
        /// </summary>
        /// <param name="random">The random provider to use.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The created random vector instance.</returns>
        public static Int64x2 GetRandom<TRandom>(
            ref TRandom random,
            Int64x2 min,
            Int64x2 max)
            where TRandom : struct, IRandomProvider
        {
            long x = GetRandomScalar(
                ref random, min.X, max.X);
            long y = GetRandomScalar(
                ref random, min.Y, max.Y);
            return new Int64x2(x, y);
        }

        /// <summary>
        /// Creates a vector instance from the given source view.
        /// </summary>
        /// <typeparam name="TStride">The custom stride type.</typeparam>
        /// <param name="sourceView">The source view.</param>
        /// <param name="index">The source base index.</param>
        /// <returns>The vector instance.</returns>
        public static Int64x2 FromElementView<TStride>(
            ArrayView1D<long, TStride> sourceView,
            Index1D index)
            where TStride : struct, IStride1D =>
            new Int64x2(
                sourceView[index + 0],
                sourceView[index + 1]
                );

        /// <summary>
        /// Serializes the current vector instance into the given target view.
        /// </summary>
        /// <typeparam name="TStride">The custom stride type.</typeparam>
        /// <param name="targetView">The target view.</param>
        /// <param name="index">The target base index.</param>
        public void ToElementView<TStride>(
            ArrayView1D<long, TStride> targetView,
            Index1D index)
            where TStride : struct, IStride1D
        {
            targetView[index + 0] = X;
            targetView[index + 1] = Y;
        }

        /// <summary>
        /// Creates a vector instance from the given source view.
        /// </summary>
        /// <param name="sourceView">The source view.</param>
        /// <param name="index">The source base index.</param>
        /// <returns>The vector instance.</returns>
        public static Int64x2 FromElementView(
            SingleVectorView<long> sourceView,
            Index1D index) =>
            new Int64x2(
                sourceView[index + 0],
                sourceView[index + 1]
                );

        /// <summary>
        /// Serializes the current vector instance into the given target view.
        /// </summary>
        /// <param name="targetView">The target view.</param>
        /// <param name="index">The target base index.</param>
        public void ToElementView(
            SingleVectorView<long> targetView,
            Index1D index)
        {
            targetView[index + 0] = X;
            targetView[index + 1] = Y;
        }

        /// <summary>
        /// Converts a scalar value into the current vectorized type.
        /// </summary>
        /// <param name="scalar">The scalar element type.</param>
        /// <returns>The created vectorized type.</returns>
        public static Int64x2 FromScalar(long scalar) =>
            new Int64x2(scalar, scalar);

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        public static void AtomicAdd(ref Int64x2 target, Int64x2 value)
        {
            ref var elementRef = ref Unsafe.As<Int64x2, long>(
                ref target);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrX),
                value.X);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrY),
                value.Y);
        }

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        public Int64x2 ComputeAverage(long denominator) =>
            this / FromScalar((long)denominator);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int64x2 operator +(
            Int64x2 current,
            UInt8x2 toAccumulate) =>
            current + ConvertFrom_byte(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int64x2 operator +(
            UInt8x2 toAccumulate,
            Int64x2 current) =>
            ConvertFrom_byte(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int64x2 operator -(
            Int64x2 current,
            UInt8x2 toAccumulate) =>
            current - ConvertFrom_byte(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int64x2 operator -(
            UInt8x2 toAccumulate,
            Int64x2 current) =>
            ConvertFrom_byte(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref Int64x2 target,
            UInt8x2 value) =>
            AtomicAdd(ref target, ConvertFrom_byte(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int64x2 ConvertFrom_byte(
            UInt8x2 other) =>
            new Int64x2((long)other.X, (long)other.Y);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt8x2 ConvertTo_byte(
            Int64x2 current) =>
            new UInt8x2((byte)current.X, (byte)current.Y);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int64x2 IAccumulationVectorType<
            Int64x2,
            UInt8x2,
            byte>.ConvertFromBase(UInt8x2 other) =>
            ConvertFrom_byte(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt8x2 IAccumulationVectorType<
            Int64x2,
            UInt8x2,
            byte>.ConvertToBase(Int64x2 current) =>
            ConvertTo_byte(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public Int64x2 ComputeAverage(byte denominator) =>
            this / FromScalar((long)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int64x2 operator +(
            Int64x2 current,
            Int8x2 toAccumulate) =>
            current + ConvertFrom_sbyte(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int64x2 operator +(
            Int8x2 toAccumulate,
            Int64x2 current) =>
            ConvertFrom_sbyte(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int64x2 operator -(
            Int64x2 current,
            Int8x2 toAccumulate) =>
            current - ConvertFrom_sbyte(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int64x2 operator -(
            Int8x2 toAccumulate,
            Int64x2 current) =>
            ConvertFrom_sbyte(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref Int64x2 target,
            Int8x2 value) =>
            AtomicAdd(ref target, ConvertFrom_sbyte(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int64x2 ConvertFrom_sbyte(
            Int8x2 other) =>
            new Int64x2((long)other.X, (long)other.Y);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int8x2 ConvertTo_sbyte(
            Int64x2 current) =>
            new Int8x2((sbyte)current.X, (sbyte)current.Y);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int64x2 IAccumulationVectorType<
            Int64x2,
            Int8x2,
            sbyte>.ConvertFromBase(Int8x2 other) =>
            ConvertFrom_sbyte(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int8x2 IAccumulationVectorType<
            Int64x2,
            Int8x2,
            sbyte>.ConvertToBase(Int64x2 current) =>
            ConvertTo_sbyte(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public Int64x2 ComputeAverage(sbyte denominator) =>
            this / FromScalar((long)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int64x2 operator +(
            Int64x2 current,
            Int16x2 toAccumulate) =>
            current + ConvertFrom_short(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int64x2 operator +(
            Int16x2 toAccumulate,
            Int64x2 current) =>
            ConvertFrom_short(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int64x2 operator -(
            Int64x2 current,
            Int16x2 toAccumulate) =>
            current - ConvertFrom_short(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int64x2 operator -(
            Int16x2 toAccumulate,
            Int64x2 current) =>
            ConvertFrom_short(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(true)]
        public static void AtomicAdd(
            ref Int64x2 target,
            Int16x2 value) =>
            AtomicAdd(ref target, ConvertFrom_short(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int64x2 ConvertFrom_short(
            Int16x2 other) =>
            new Int64x2((long)other.X, (long)other.Y);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int16x2 ConvertTo_short(
            Int64x2 current) =>
            new Int16x2((short)current.X, (short)current.Y);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int64x2 IAccumulationVectorType<
            Int64x2,
            Int16x2,
            short>.ConvertFromBase(Int16x2 other) =>
            ConvertFrom_short(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int16x2 IAccumulationVectorType<
            Int64x2,
            Int16x2,
            short>.ConvertToBase(Int64x2 current) =>
            ConvertTo_short(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(true)]
        public Int64x2 ComputeAverage(short denominator) =>
            this / FromScalar((long)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int64x2 operator +(
            Int64x2 current,
            UInt16x2 toAccumulate) =>
            current + ConvertFrom_ushort(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int64x2 operator +(
            UInt16x2 toAccumulate,
            Int64x2 current) =>
            ConvertFrom_ushort(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int64x2 operator -(
            Int64x2 current,
            UInt16x2 toAccumulate) =>
            current - ConvertFrom_ushort(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int64x2 operator -(
            UInt16x2 toAccumulate,
            Int64x2 current) =>
            ConvertFrom_ushort(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref Int64x2 target,
            UInt16x2 value) =>
            AtomicAdd(ref target, ConvertFrom_ushort(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int64x2 ConvertFrom_ushort(
            UInt16x2 other) =>
            new Int64x2((long)other.X, (long)other.Y);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt16x2 ConvertTo_ushort(
            Int64x2 current) =>
            new UInt16x2((ushort)current.X, (ushort)current.Y);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int64x2 IAccumulationVectorType<
            Int64x2,
            UInt16x2,
            ushort>.ConvertFromBase(UInt16x2 other) =>
            ConvertFrom_ushort(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt16x2 IAccumulationVectorType<
            Int64x2,
            UInt16x2,
            ushort>.ConvertToBase(Int64x2 current) =>
            ConvertTo_ushort(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public Int64x2 ComputeAverage(ushort denominator) =>
            this / FromScalar((long)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int64x2 operator +(
            Int64x2 current,
            Int32x2 toAccumulate) =>
            current + ConvertFrom_int(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int64x2 operator +(
            Int32x2 toAccumulate,
            Int64x2 current) =>
            ConvertFrom_int(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int64x2 operator -(
            Int64x2 current,
            Int32x2 toAccumulate) =>
            current - ConvertFrom_int(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int64x2 operator -(
            Int32x2 toAccumulate,
            Int64x2 current) =>
            ConvertFrom_int(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(true)]
        public static void AtomicAdd(
            ref Int64x2 target,
            Int32x2 value) =>
            AtomicAdd(ref target, ConvertFrom_int(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int64x2 ConvertFrom_int(
            Int32x2 other) =>
            new Int64x2((long)other.X, (long)other.Y);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int32x2 ConvertTo_int(
            Int64x2 current) =>
            new Int32x2((int)current.X, (int)current.Y);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int64x2 IAccumulationVectorType<
            Int64x2,
            Int32x2,
            int>.ConvertFromBase(Int32x2 other) =>
            ConvertFrom_int(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int32x2 IAccumulationVectorType<
            Int64x2,
            Int32x2,
            int>.ConvertToBase(Int64x2 current) =>
            ConvertTo_int(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(true)]
        public Int64x2 ComputeAverage(int denominator) =>
            this / FromScalar((long)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int64x2 operator +(
            Int64x2 current,
            UInt32x2 toAccumulate) =>
            current + ConvertFrom_uint(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int64x2 operator +(
            UInt32x2 toAccumulate,
            Int64x2 current) =>
            ConvertFrom_uint(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int64x2 operator -(
            Int64x2 current,
            UInt32x2 toAccumulate) =>
            current - ConvertFrom_uint(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int64x2 operator -(
            UInt32x2 toAccumulate,
            Int64x2 current) =>
            ConvertFrom_uint(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref Int64x2 target,
            UInt32x2 value) =>
            AtomicAdd(ref target, ConvertFrom_uint(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int64x2 ConvertFrom_uint(
            UInt32x2 other) =>
            new Int64x2((long)other.X, (long)other.Y);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt32x2 ConvertTo_uint(
            Int64x2 current) =>
            new UInt32x2((uint)current.X, (uint)current.Y);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int64x2 IAccumulationVectorType<
            Int64x2,
            UInt32x2,
            uint>.ConvertFromBase(UInt32x2 other) =>
            ConvertFrom_uint(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt32x2 IAccumulationVectorType<
            Int64x2,
            UInt32x2,
            uint>.ConvertToBase(Int64x2 current) =>
            ConvertTo_uint(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public Int64x2 ComputeAverage(uint denominator) =>
            this / FromScalar((long)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int64x2 operator +(
            Int64x2 current,
            Float32x2 toAccumulate) =>
            current + ConvertFrom_float(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int64x2 operator +(
            Float32x2 toAccumulate,
            Int64x2 current) =>
            ConvertFrom_float(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int64x2 operator -(
            Int64x2 current,
            Float32x2 toAccumulate) =>
            current - ConvertFrom_float(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int64x2 operator -(
            Float32x2 toAccumulate,
            Int64x2 current) =>
            ConvertFrom_float(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(true)]
        public static void AtomicAdd(
            ref Int64x2 target,
            Float32x2 value) =>
            AtomicAdd(ref target, ConvertFrom_float(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int64x2 ConvertFrom_float(
            Float32x2 other) =>
            new Int64x2((long)other.X, (long)other.Y);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float32x2 ConvertTo_float(
            Int64x2 current) =>
            new Float32x2((float)current.X, (float)current.Y);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int64x2 IAccumulationVectorType<
            Int64x2,
            Float32x2,
            float>.ConvertFromBase(Float32x2 other) =>
            ConvertFrom_float(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float32x2 IAccumulationVectorType<
            Int64x2,
            Float32x2,
            float>.ConvertToBase(Int64x2 current) =>
            ConvertTo_float(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(true)]
        public Int64x2 ComputeAverage(float denominator) =>
            this / FromScalar((long)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int64x2 operator +(
            Int64x2 current,
            Float64x2 toAccumulate) =>
            current + ConvertFrom_double(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int64x2 operator +(
            Float64x2 toAccumulate,
            Int64x2 current) =>
            ConvertFrom_double(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int64x2 operator -(
            Int64x2 current,
            Float64x2 toAccumulate) =>
            current - ConvertFrom_double(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int64x2 operator -(
            Float64x2 toAccumulate,
            Int64x2 current) =>
            ConvertFrom_double(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(true)]
        public static void AtomicAdd(
            ref Int64x2 target,
            Float64x2 value) =>
            AtomicAdd(ref target, ConvertFrom_double(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int64x2 ConvertFrom_double(
            Float64x2 other) =>
            new Int64x2((long)other.X, (long)other.Y);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float64x2 ConvertTo_double(
            Int64x2 current) =>
            new Float64x2((double)current.X, (double)current.Y);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int64x2 IAccumulationVectorType<
            Int64x2,
            Float64x2,
            double>.ConvertFromBase(Float64x2 other) =>
            ConvertFrom_double(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float64x2 IAccumulationVectorType<
            Int64x2,
            Float64x2,
            double>.ConvertToBase(Int64x2 current) =>
            ConvertTo_double(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(true)]
        public Int64x2 ComputeAverage(double denominator) =>
            this / FromScalar((long)denominator);

        /// <summary>
        /// Converts this instance into an unsafe span instance.
        /// </summary>
        /// <returns>The readonly span instance.</returns>
        public unsafe ReadOnlySpan<long> AsSpan() =>
            new(Unsafe.AsPointer(ref Unsafe.AsRef(this)), 2);

        /// <summary>
        /// Iterates over all elements by applying the given iterator to each element.
        /// </summary>
        /// <typeparam name="TIterator">The managed iterator type.</typeparam>
        /// <param name="iterator">The iterator to invoke.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ForEach<TIterator>(ref TIterator iterator)
            where TIterator : struct, IVectorElementIterator<
            Int64x2,
            long>
        {
            iterator.Iterate(X, 0);
            iterator.Iterate(Y, 1);
        }

        /// <summary>
        /// Converts this vector instance to a string.
        /// </summary>
        public override string ToString() =>
            $"{X}, {Y}";

        /// <summary>
        /// Converts this vector instance to a string.
        /// </summary>
        public string ToString(string? format, IFormatProvider? formatProvider) =>
            $"{X.ToString(format, formatProvider)}, {Y.ToString(format, formatProvider)}";

        /// <summary>
        /// Returns true.
        /// </summary>
        public static bool IsCanonical(Int64x2 value) => true;

        /// <summary>
        /// Returns false.
        /// </summary>
        public static bool IsComplexNumber(Int64x2 value) => false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsEvenInteger(Int64x2 value) =>
            long.IsEvenInteger(value.X) & long.IsEvenInteger(value.Y);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsFinite(Int64x2 value) =>
            true;

        /// <summary>
        /// Returns false.
        /// </summary>
        public static bool IsImaginaryNumber(Int64x2 value) => false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsInfinity(Int64x2 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsInteger(Int64x2 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNaN(Int64x2 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNegative(Int64x2 value) =>
            long.IsNegative(value.X) & long.IsNegative(value.Y);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNegativeInfinity(Int64x2 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNormal(Int64x2 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsOddInteger(Int64x2 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsPositive(Int64x2 value) =>
            long.IsPositive(value.X) & long.IsPositive(value.Y);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsPositiveInfinity(Int64x2 value) =>
            false;

        /// <summary>
        /// Returns true.
        /// </summary>
        public static bool IsRealNumber(Int64x2 value) => true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsSubnormal(Int64x2 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsZero(Int64x2 value) =>
            value == Zero;

        /// <summary>
        /// Returns the absolute value.
        /// </summary>
        public static Int64x2 Abs(Int64x2 value) =>
            new Int64x2(Math.Abs(value.X), Math.Abs(value.Y));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int64x2 operator +(Int64x2 left, Int64x2 right) =>
            new Int64x2((long)(left.X + right.X), (long)(left.Y + right.Y));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int64x2 operator --(Int64x2 value) => value - One;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int64x2 operator /(Int64x2 left, Int64x2 right) =>
            new Int64x2((long)(left.X / right.X), (long)(left.Y / right.Y));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int64x2 operator ++(Int64x2 value) => value + One;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int64x2 operator *(Int64x2 left, Int64x2 right) =>
            new Int64x2((long)(left.X * right.X), (long)(left.Y * right.Y));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int64x2 operator -(Int64x2 left, Int64x2 right) =>
            new Int64x2((long)(left.X - right.X), (long)(left.Y - right.Y));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int64x2 operator -(Int64x2 value) =>
            new Int64x2((long)-value.X, (long)-value.Y);

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int64x2 operator +(Int64x2 value) => value;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int64x2 MaxMagnitude(Int64x2 x, Int64x2 y) =>
            new Int64x2(long.MaxMagnitude(x.X, y.X), long.MaxMagnitude(x.Y, y.Y));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int64x2 MaxMagnitudeNumber(Int64x2 x, Int64x2 y) =>
            MaxMagnitude(x, y);

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int64x2 MinMagnitude(Int64x2 x, Int64x2 y) =>
            new Int64x2(long.MinMagnitude(x.X, y.X), long.MinMagnitude(x.Y, y.Y));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int64x2 MinMagnitudeNumber(Int64x2 x, Int64x2 y) =>
            MinMagnitude(x, y);

        // Not supported operations

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static Int64x2 IParsable<Int64x2>.Parse(
            string s,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static Int64x2 ISpanParsable<Int64x2>.Parse(
            ReadOnlySpan<char> s,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static Int64x2 INumberBase<Int64x2>.Parse(
            ReadOnlySpan<char> s,
            NumberStyles style,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static Int64x2 INumberBase<Int64x2>.Parse(
            string s,
            NumberStyles style,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        bool ISpanFormattable.TryFormat(
            Span<char> destination,
            out int charsWritten,
            ReadOnlySpan<char> format,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool IParsable<Int64x2>.TryParse(
            string? s,
            IFormatProvider? provider,
            out Int64x2 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given span into a vectorized instance.
        /// </summary>
        static bool ISpanParsable<Int64x2>.TryParse(
            ReadOnlySpan<char> s,
            IFormatProvider? provider,
            out Int64x2 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool INumberBase<Int64x2>.TryParse(
            ReadOnlySpan<char> s,
            NumberStyles style,
            IFormatProvider? provider,
            out Int64x2 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool INumberBase<Int64x2>.TryParse(
            string? s,
            NumberStyles style,
            IFormatProvider? provider,
            out Int64x2 result) =>
            throw new NotSupportedException();

        static bool INumberBase<Int64x2>.TryConvertFromChecked<TOther>(
            TOther value,
            out Int64x2 result) =>
            throw new NotSupportedException();
        static bool INumberBase<Int64x2>.TryConvertFromSaturating<TOther>(
            TOther value,
            out Int64x2 result) =>
            throw new NotSupportedException();
        static bool INumberBase<Int64x2>.TryConvertFromTruncating<TOther>(
            TOther value,
            out Int64x2 result) =>
            throw new NotSupportedException();
        static bool INumberBase<Int64x2>.TryConvertToChecked<TOther>(
            Int64x2 value,
            out TOther result) =>
            throw new NotSupportedException();
        static bool INumberBase<Int64x2>.TryConvertToSaturating<TOther>(
            Int64x2 value,
            out TOther result) =>
            throw new NotSupportedException();
        static bool INumberBase<Int64x2>.TryConvertToTruncating<TOther>(
            Int64x2 value,
            out TOther result) =>
            throw new NotSupportedException();
    }

    /// <summary>
    /// Represents a vectorized long type with length 4.
    /// </summary>
    public readonly record struct Int64x4(
        long X, long Y, long Z, long W) :
        IVectorType<Int64x4, long>
        , IAccumulationVectorType<
            Int64x4,
            UInt8x4,
            byte>
        , IAccumulationVectorType<
            Int64x4,
            Int8x4,
            sbyte>
        , IAccumulationVectorType<
            Int64x4,
            Int16x4,
            short>
        , IAccumulationVectorType<
            Int64x4,
            UInt16x4,
            ushort>
        , IAccumulationVectorType<
            Int64x4,
            Int32x4,
            int>
        , IAccumulationVectorType<
            Int64x4,
            UInt32x4,
            uint>
        , IAccumulationVectorType<
            Int64x4,
            Float32x4,
            float>
        , IAccumulationVectorType<
            Int64x4,
            Float64x4,
            double>
    {
        /// <summary>
        /// The offset of the X field in bytes.
        /// </summary>
        public static readonly int OffsetX =
            sizeof(long) * 0;

        /// <summary>
        /// The offset of the X field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrX =>
            new UIntPtr((uint)OffsetX);
        /// <summary>
        /// The offset of the Y field in bytes.
        /// </summary>
        public static readonly int OffsetY =
            sizeof(long) * 1;

        /// <summary>
        /// The offset of the Y field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrY =>
            new UIntPtr((uint)OffsetY);
        /// <summary>
        /// The offset of the Z field in bytes.
        /// </summary>
        public static readonly int OffsetZ =
            sizeof(long) * 2;

        /// <summary>
        /// The offset of the Z field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrZ =>
            new UIntPtr((uint)OffsetZ);
        /// <summary>
        /// The offset of the W field in bytes.
        /// </summary>
        public static readonly int OffsetW =
            sizeof(long) * 3;

        /// <summary>
        /// The offset of the W field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrW =>
            new UIntPtr((uint)OffsetW);

        /// <summary>
        /// Returns the length of this vector which is 4.
        /// </summary>
        public static int Length => 4;

        /// <summary>
        /// Returns the radix of the underlying value.
        /// </summary>
        public static int Radix => 10;

        /// <summary>
        /// Returns an invalid value (min [signed types], max value [unsigned] or NaN).
        /// </summary>
        public static Int64x4 Invalid => FromScalar(
            long.MinValue
        );

        /// <summary>
        /// Returns the value zero.
        /// </summary>
        public static Int64x4 Zero => new();

        /// <summary>
        /// Returns the value one.
        /// </summary>
        public static Int64x4 One => FromScalar((1));

        /// <summary>
        /// Returns the value zero.
        /// </summary>
        public static Int64x4 AdditiveIdentity => Zero;

        /// <summary>
        /// Returns the value one.
        /// </summary>
        public static Int64x4 MultiplicativeIdentity => One;

        /// <summary>
        /// Computes the min value of both.
        /// </summary>
        /// <param name="first">The first value.</param>
        /// <param name="second">The second value.</param>
        /// <returns>The min value.</returns>
        public static Int64x4 Min(
            Int64x4 first,
            Int64x4 second) =>
            new Int64x4((long)Math.Min(first.X, second.X), (long)Math.Min(first.Y, second.Y), (long)Math.Min(first.Z, second.Z), (long)Math.Min(first.W, second.W));

        /// <summary>
        /// Computes the max value of both.
        /// </summary>
        /// <param name="first">The first value.</param>
        /// <param name="second">The second value.</param>
        /// <returns>The max value.</returns>
        public static Int64x4 Max(
            Int64x4 first,
            Int64x4 second) =>
            new Int64x4((long)Math.Max(first.X, second.X), (long)Math.Max(first.Y, second.Y), (long)Math.Max(first.Z, second.Z), (long)Math.Max(first.W, second.W));

        /// <summary>
        /// Clamps the given value.
        /// </summary>
        /// <param name="value">The value to clamp.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The clamped value.</returns>
        public static Int64x4 Clamp(
            Int64x4 value,
            Int64x4 min,
            Int64x4 max) =>
            Max(Min(value, max), min);

        /// <summary>
        /// Creates a random scalar instance falling into the range of min max.
        /// </summary>
        /// <param name="random">The random provider to use.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The created random scalar instance.</returns>
        public static long GetRandomScalar<TRandom>(
            ref TRandom random,
            long min,
            long max)
            where TRandom : struct, IRandomProvider =>
            (long)RandomExtensions.
                Next(ref random, min, max);

        /// <summary>
        /// Creates a random vector instance falling into the range of min max.
        /// </summary>
        /// <param name="random">The random provider to use.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The created random vector instance.</returns>
        public static Int64x4 GetRandom<TRandom>(
            ref TRandom random,
            Int64x4 min,
            Int64x4 max)
            where TRandom : struct, IRandomProvider
        {
            long x = GetRandomScalar(
                ref random, min.X, max.X);
            long y = GetRandomScalar(
                ref random, min.Y, max.Y);
            long z = GetRandomScalar(
                ref random, min.Z, max.Z);
            long w = GetRandomScalar(
                ref random, min.W, max.W);
            return new Int64x4(x, y, z, w);
        }

        /// <summary>
        /// Creates a vector instance from the given source view.
        /// </summary>
        /// <typeparam name="TStride">The custom stride type.</typeparam>
        /// <param name="sourceView">The source view.</param>
        /// <param name="index">The source base index.</param>
        /// <returns>The vector instance.</returns>
        public static Int64x4 FromElementView<TStride>(
            ArrayView1D<long, TStride> sourceView,
            Index1D index)
            where TStride : struct, IStride1D =>
            new Int64x4(
                sourceView[index + 0],
                sourceView[index + 1],
                sourceView[index + 2],
                sourceView[index + 3]
                );

        /// <summary>
        /// Serializes the current vector instance into the given target view.
        /// </summary>
        /// <typeparam name="TStride">The custom stride type.</typeparam>
        /// <param name="targetView">The target view.</param>
        /// <param name="index">The target base index.</param>
        public void ToElementView<TStride>(
            ArrayView1D<long, TStride> targetView,
            Index1D index)
            where TStride : struct, IStride1D
        {
            targetView[index + 0] = X;
            targetView[index + 1] = Y;
            targetView[index + 2] = Z;
            targetView[index + 3] = W;
        }

        /// <summary>
        /// Creates a vector instance from the given source view.
        /// </summary>
        /// <param name="sourceView">The source view.</param>
        /// <param name="index">The source base index.</param>
        /// <returns>The vector instance.</returns>
        public static Int64x4 FromElementView(
            SingleVectorView<long> sourceView,
            Index1D index) =>
            new Int64x4(
                sourceView[index + 0],
                sourceView[index + 1],
                sourceView[index + 2],
                sourceView[index + 3]
                );

        /// <summary>
        /// Serializes the current vector instance into the given target view.
        /// </summary>
        /// <param name="targetView">The target view.</param>
        /// <param name="index">The target base index.</param>
        public void ToElementView(
            SingleVectorView<long> targetView,
            Index1D index)
        {
            targetView[index + 0] = X;
            targetView[index + 1] = Y;
            targetView[index + 2] = Z;
            targetView[index + 3] = W;
        }

        /// <summary>
        /// Converts a scalar value into the current vectorized type.
        /// </summary>
        /// <param name="scalar">The scalar element type.</param>
        /// <returns>The created vectorized type.</returns>
        public static Int64x4 FromScalar(long scalar) =>
            new Int64x4(scalar, scalar, scalar, scalar);

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        public static void AtomicAdd(ref Int64x4 target, Int64x4 value)
        {
            ref var elementRef = ref Unsafe.As<Int64x4, long>(
                ref target);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrX),
                value.X);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrY),
                value.Y);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrZ),
                value.Z);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrW),
                value.W);
        }

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        public Int64x4 ComputeAverage(long denominator) =>
            this / FromScalar((long)denominator);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int64x4 operator +(
            Int64x4 current,
            UInt8x4 toAccumulate) =>
            current + ConvertFrom_byte(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int64x4 operator +(
            UInt8x4 toAccumulate,
            Int64x4 current) =>
            ConvertFrom_byte(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int64x4 operator -(
            Int64x4 current,
            UInt8x4 toAccumulate) =>
            current - ConvertFrom_byte(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int64x4 operator -(
            UInt8x4 toAccumulate,
            Int64x4 current) =>
            ConvertFrom_byte(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref Int64x4 target,
            UInt8x4 value) =>
            AtomicAdd(ref target, ConvertFrom_byte(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int64x4 ConvertFrom_byte(
            UInt8x4 other) =>
            new Int64x4((long)other.X, (long)other.Y, (long)other.Z, (long)other.W);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt8x4 ConvertTo_byte(
            Int64x4 current) =>
            new UInt8x4((byte)current.X, (byte)current.Y, (byte)current.Z, (byte)current.W);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int64x4 IAccumulationVectorType<
            Int64x4,
            UInt8x4,
            byte>.ConvertFromBase(UInt8x4 other) =>
            ConvertFrom_byte(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt8x4 IAccumulationVectorType<
            Int64x4,
            UInt8x4,
            byte>.ConvertToBase(Int64x4 current) =>
            ConvertTo_byte(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public Int64x4 ComputeAverage(byte denominator) =>
            this / FromScalar((long)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int64x4 operator +(
            Int64x4 current,
            Int8x4 toAccumulate) =>
            current + ConvertFrom_sbyte(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int64x4 operator +(
            Int8x4 toAccumulate,
            Int64x4 current) =>
            ConvertFrom_sbyte(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int64x4 operator -(
            Int64x4 current,
            Int8x4 toAccumulate) =>
            current - ConvertFrom_sbyte(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int64x4 operator -(
            Int8x4 toAccumulate,
            Int64x4 current) =>
            ConvertFrom_sbyte(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref Int64x4 target,
            Int8x4 value) =>
            AtomicAdd(ref target, ConvertFrom_sbyte(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int64x4 ConvertFrom_sbyte(
            Int8x4 other) =>
            new Int64x4((long)other.X, (long)other.Y, (long)other.Z, (long)other.W);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int8x4 ConvertTo_sbyte(
            Int64x4 current) =>
            new Int8x4((sbyte)current.X, (sbyte)current.Y, (sbyte)current.Z, (sbyte)current.W);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int64x4 IAccumulationVectorType<
            Int64x4,
            Int8x4,
            sbyte>.ConvertFromBase(Int8x4 other) =>
            ConvertFrom_sbyte(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int8x4 IAccumulationVectorType<
            Int64x4,
            Int8x4,
            sbyte>.ConvertToBase(Int64x4 current) =>
            ConvertTo_sbyte(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public Int64x4 ComputeAverage(sbyte denominator) =>
            this / FromScalar((long)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int64x4 operator +(
            Int64x4 current,
            Int16x4 toAccumulate) =>
            current + ConvertFrom_short(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int64x4 operator +(
            Int16x4 toAccumulate,
            Int64x4 current) =>
            ConvertFrom_short(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int64x4 operator -(
            Int64x4 current,
            Int16x4 toAccumulate) =>
            current - ConvertFrom_short(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int64x4 operator -(
            Int16x4 toAccumulate,
            Int64x4 current) =>
            ConvertFrom_short(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(true)]
        public static void AtomicAdd(
            ref Int64x4 target,
            Int16x4 value) =>
            AtomicAdd(ref target, ConvertFrom_short(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int64x4 ConvertFrom_short(
            Int16x4 other) =>
            new Int64x4((long)other.X, (long)other.Y, (long)other.Z, (long)other.W);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int16x4 ConvertTo_short(
            Int64x4 current) =>
            new Int16x4((short)current.X, (short)current.Y, (short)current.Z, (short)current.W);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int64x4 IAccumulationVectorType<
            Int64x4,
            Int16x4,
            short>.ConvertFromBase(Int16x4 other) =>
            ConvertFrom_short(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int16x4 IAccumulationVectorType<
            Int64x4,
            Int16x4,
            short>.ConvertToBase(Int64x4 current) =>
            ConvertTo_short(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(true)]
        public Int64x4 ComputeAverage(short denominator) =>
            this / FromScalar((long)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int64x4 operator +(
            Int64x4 current,
            UInt16x4 toAccumulate) =>
            current + ConvertFrom_ushort(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int64x4 operator +(
            UInt16x4 toAccumulate,
            Int64x4 current) =>
            ConvertFrom_ushort(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int64x4 operator -(
            Int64x4 current,
            UInt16x4 toAccumulate) =>
            current - ConvertFrom_ushort(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int64x4 operator -(
            UInt16x4 toAccumulate,
            Int64x4 current) =>
            ConvertFrom_ushort(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref Int64x4 target,
            UInt16x4 value) =>
            AtomicAdd(ref target, ConvertFrom_ushort(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int64x4 ConvertFrom_ushort(
            UInt16x4 other) =>
            new Int64x4((long)other.X, (long)other.Y, (long)other.Z, (long)other.W);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt16x4 ConvertTo_ushort(
            Int64x4 current) =>
            new UInt16x4((ushort)current.X, (ushort)current.Y, (ushort)current.Z, (ushort)current.W);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int64x4 IAccumulationVectorType<
            Int64x4,
            UInt16x4,
            ushort>.ConvertFromBase(UInt16x4 other) =>
            ConvertFrom_ushort(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt16x4 IAccumulationVectorType<
            Int64x4,
            UInt16x4,
            ushort>.ConvertToBase(Int64x4 current) =>
            ConvertTo_ushort(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public Int64x4 ComputeAverage(ushort denominator) =>
            this / FromScalar((long)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int64x4 operator +(
            Int64x4 current,
            Int32x4 toAccumulate) =>
            current + ConvertFrom_int(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int64x4 operator +(
            Int32x4 toAccumulate,
            Int64x4 current) =>
            ConvertFrom_int(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int64x4 operator -(
            Int64x4 current,
            Int32x4 toAccumulate) =>
            current - ConvertFrom_int(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int64x4 operator -(
            Int32x4 toAccumulate,
            Int64x4 current) =>
            ConvertFrom_int(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(true)]
        public static void AtomicAdd(
            ref Int64x4 target,
            Int32x4 value) =>
            AtomicAdd(ref target, ConvertFrom_int(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int64x4 ConvertFrom_int(
            Int32x4 other) =>
            new Int64x4((long)other.X, (long)other.Y, (long)other.Z, (long)other.W);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int32x4 ConvertTo_int(
            Int64x4 current) =>
            new Int32x4((int)current.X, (int)current.Y, (int)current.Z, (int)current.W);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int64x4 IAccumulationVectorType<
            Int64x4,
            Int32x4,
            int>.ConvertFromBase(Int32x4 other) =>
            ConvertFrom_int(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int32x4 IAccumulationVectorType<
            Int64x4,
            Int32x4,
            int>.ConvertToBase(Int64x4 current) =>
            ConvertTo_int(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(true)]
        public Int64x4 ComputeAverage(int denominator) =>
            this / FromScalar((long)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int64x4 operator +(
            Int64x4 current,
            UInt32x4 toAccumulate) =>
            current + ConvertFrom_uint(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int64x4 operator +(
            UInt32x4 toAccumulate,
            Int64x4 current) =>
            ConvertFrom_uint(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int64x4 operator -(
            Int64x4 current,
            UInt32x4 toAccumulate) =>
            current - ConvertFrom_uint(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int64x4 operator -(
            UInt32x4 toAccumulate,
            Int64x4 current) =>
            ConvertFrom_uint(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref Int64x4 target,
            UInt32x4 value) =>
            AtomicAdd(ref target, ConvertFrom_uint(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int64x4 ConvertFrom_uint(
            UInt32x4 other) =>
            new Int64x4((long)other.X, (long)other.Y, (long)other.Z, (long)other.W);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt32x4 ConvertTo_uint(
            Int64x4 current) =>
            new UInt32x4((uint)current.X, (uint)current.Y, (uint)current.Z, (uint)current.W);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int64x4 IAccumulationVectorType<
            Int64x4,
            UInt32x4,
            uint>.ConvertFromBase(UInt32x4 other) =>
            ConvertFrom_uint(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt32x4 IAccumulationVectorType<
            Int64x4,
            UInt32x4,
            uint>.ConvertToBase(Int64x4 current) =>
            ConvertTo_uint(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public Int64x4 ComputeAverage(uint denominator) =>
            this / FromScalar((long)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int64x4 operator +(
            Int64x4 current,
            Float32x4 toAccumulate) =>
            current + ConvertFrom_float(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int64x4 operator +(
            Float32x4 toAccumulate,
            Int64x4 current) =>
            ConvertFrom_float(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int64x4 operator -(
            Int64x4 current,
            Float32x4 toAccumulate) =>
            current - ConvertFrom_float(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int64x4 operator -(
            Float32x4 toAccumulate,
            Int64x4 current) =>
            ConvertFrom_float(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(true)]
        public static void AtomicAdd(
            ref Int64x4 target,
            Float32x4 value) =>
            AtomicAdd(ref target, ConvertFrom_float(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int64x4 ConvertFrom_float(
            Float32x4 other) =>
            new Int64x4((long)other.X, (long)other.Y, (long)other.Z, (long)other.W);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float32x4 ConvertTo_float(
            Int64x4 current) =>
            new Float32x4((float)current.X, (float)current.Y, (float)current.Z, (float)current.W);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int64x4 IAccumulationVectorType<
            Int64x4,
            Float32x4,
            float>.ConvertFromBase(Float32x4 other) =>
            ConvertFrom_float(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float32x4 IAccumulationVectorType<
            Int64x4,
            Float32x4,
            float>.ConvertToBase(Int64x4 current) =>
            ConvertTo_float(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(true)]
        public Int64x4 ComputeAverage(float denominator) =>
            this / FromScalar((long)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int64x4 operator +(
            Int64x4 current,
            Float64x4 toAccumulate) =>
            current + ConvertFrom_double(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int64x4 operator +(
            Float64x4 toAccumulate,
            Int64x4 current) =>
            ConvertFrom_double(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int64x4 operator -(
            Int64x4 current,
            Float64x4 toAccumulate) =>
            current - ConvertFrom_double(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int64x4 operator -(
            Float64x4 toAccumulate,
            Int64x4 current) =>
            ConvertFrom_double(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(true)]
        public static void AtomicAdd(
            ref Int64x4 target,
            Float64x4 value) =>
            AtomicAdd(ref target, ConvertFrom_double(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int64x4 ConvertFrom_double(
            Float64x4 other) =>
            new Int64x4((long)other.X, (long)other.Y, (long)other.Z, (long)other.W);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float64x4 ConvertTo_double(
            Int64x4 current) =>
            new Float64x4((double)current.X, (double)current.Y, (double)current.Z, (double)current.W);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int64x4 IAccumulationVectorType<
            Int64x4,
            Float64x4,
            double>.ConvertFromBase(Float64x4 other) =>
            ConvertFrom_double(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float64x4 IAccumulationVectorType<
            Int64x4,
            Float64x4,
            double>.ConvertToBase(Int64x4 current) =>
            ConvertTo_double(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(true)]
        public Int64x4 ComputeAverage(double denominator) =>
            this / FromScalar((long)denominator);

        /// <summary>
        /// Converts this instance into an unsafe span instance.
        /// </summary>
        /// <returns>The readonly span instance.</returns>
        public unsafe ReadOnlySpan<long> AsSpan() =>
            new(Unsafe.AsPointer(ref Unsafe.AsRef(this)), 4);

        /// <summary>
        /// Iterates over all elements by applying the given iterator to each element.
        /// </summary>
        /// <typeparam name="TIterator">The managed iterator type.</typeparam>
        /// <param name="iterator">The iterator to invoke.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ForEach<TIterator>(ref TIterator iterator)
            where TIterator : struct, IVectorElementIterator<
            Int64x4,
            long>
        {
            iterator.Iterate(X, 0);
            iterator.Iterate(Y, 1);
            iterator.Iterate(Z, 2);
            iterator.Iterate(W, 3);
        }

        /// <summary>
        /// Converts this vector instance to a string.
        /// </summary>
        public override string ToString() =>
            $"{X}, {Y}, {Z}, {W}";

        /// <summary>
        /// Converts this vector instance to a string.
        /// </summary>
        public string ToString(string? format, IFormatProvider? formatProvider) =>
            $"{X.ToString(format, formatProvider)}, {Y.ToString(format, formatProvider)}, {Z.ToString(format, formatProvider)}, {W.ToString(format, formatProvider)}";

        /// <summary>
        /// Returns true.
        /// </summary>
        public static bool IsCanonical(Int64x4 value) => true;

        /// <summary>
        /// Returns false.
        /// </summary>
        public static bool IsComplexNumber(Int64x4 value) => false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsEvenInteger(Int64x4 value) =>
            long.IsEvenInteger(value.X) & long.IsEvenInteger(value.Y) & long.IsEvenInteger(value.Z) & long.IsEvenInteger(value.W);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsFinite(Int64x4 value) =>
            true;

        /// <summary>
        /// Returns false.
        /// </summary>
        public static bool IsImaginaryNumber(Int64x4 value) => false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsInfinity(Int64x4 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsInteger(Int64x4 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNaN(Int64x4 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNegative(Int64x4 value) =>
            long.IsNegative(value.X) & long.IsNegative(value.Y) & long.IsNegative(value.Z) & long.IsNegative(value.W);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNegativeInfinity(Int64x4 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNormal(Int64x4 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsOddInteger(Int64x4 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsPositive(Int64x4 value) =>
            long.IsPositive(value.X) & long.IsPositive(value.Y) & long.IsPositive(value.Z) & long.IsPositive(value.W);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsPositiveInfinity(Int64x4 value) =>
            false;

        /// <summary>
        /// Returns true.
        /// </summary>
        public static bool IsRealNumber(Int64x4 value) => true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsSubnormal(Int64x4 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsZero(Int64x4 value) =>
            value == Zero;

        /// <summary>
        /// Returns the absolute value.
        /// </summary>
        public static Int64x4 Abs(Int64x4 value) =>
            new Int64x4(Math.Abs(value.X), Math.Abs(value.Y), Math.Abs(value.Z), Math.Abs(value.W));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int64x4 operator +(Int64x4 left, Int64x4 right) =>
            new Int64x4((long)(left.X + right.X), (long)(left.Y + right.Y), (long)(left.Z + right.Z), (long)(left.W + right.W));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int64x4 operator --(Int64x4 value) => value - One;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int64x4 operator /(Int64x4 left, Int64x4 right) =>
            new Int64x4((long)(left.X / right.X), (long)(left.Y / right.Y), (long)(left.Z / right.Z), (long)(left.W / right.W));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int64x4 operator ++(Int64x4 value) => value + One;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int64x4 operator *(Int64x4 left, Int64x4 right) =>
            new Int64x4((long)(left.X * right.X), (long)(left.Y * right.Y), (long)(left.Z * right.Z), (long)(left.W * right.W));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int64x4 operator -(Int64x4 left, Int64x4 right) =>
            new Int64x4((long)(left.X - right.X), (long)(left.Y - right.Y), (long)(left.Z - right.Z), (long)(left.W - right.W));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int64x4 operator -(Int64x4 value) =>
            new Int64x4((long)-value.X, (long)-value.Y, (long)-value.Z, (long)-value.W);

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int64x4 operator +(Int64x4 value) => value;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int64x4 MaxMagnitude(Int64x4 x, Int64x4 y) =>
            new Int64x4(long.MaxMagnitude(x.X, y.X), long.MaxMagnitude(x.Y, y.Y), long.MaxMagnitude(x.Z, y.Z), long.MaxMagnitude(x.W, y.W));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int64x4 MaxMagnitudeNumber(Int64x4 x, Int64x4 y) =>
            MaxMagnitude(x, y);

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int64x4 MinMagnitude(Int64x4 x, Int64x4 y) =>
            new Int64x4(long.MinMagnitude(x.X, y.X), long.MinMagnitude(x.Y, y.Y), long.MinMagnitude(x.Z, y.Z), long.MinMagnitude(x.W, y.W));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int64x4 MinMagnitudeNumber(Int64x4 x, Int64x4 y) =>
            MinMagnitude(x, y);

        // Not supported operations

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static Int64x4 IParsable<Int64x4>.Parse(
            string s,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static Int64x4 ISpanParsable<Int64x4>.Parse(
            ReadOnlySpan<char> s,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static Int64x4 INumberBase<Int64x4>.Parse(
            ReadOnlySpan<char> s,
            NumberStyles style,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static Int64x4 INumberBase<Int64x4>.Parse(
            string s,
            NumberStyles style,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        bool ISpanFormattable.TryFormat(
            Span<char> destination,
            out int charsWritten,
            ReadOnlySpan<char> format,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool IParsable<Int64x4>.TryParse(
            string? s,
            IFormatProvider? provider,
            out Int64x4 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given span into a vectorized instance.
        /// </summary>
        static bool ISpanParsable<Int64x4>.TryParse(
            ReadOnlySpan<char> s,
            IFormatProvider? provider,
            out Int64x4 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool INumberBase<Int64x4>.TryParse(
            ReadOnlySpan<char> s,
            NumberStyles style,
            IFormatProvider? provider,
            out Int64x4 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool INumberBase<Int64x4>.TryParse(
            string? s,
            NumberStyles style,
            IFormatProvider? provider,
            out Int64x4 result) =>
            throw new NotSupportedException();

        static bool INumberBase<Int64x4>.TryConvertFromChecked<TOther>(
            TOther value,
            out Int64x4 result) =>
            throw new NotSupportedException();
        static bool INumberBase<Int64x4>.TryConvertFromSaturating<TOther>(
            TOther value,
            out Int64x4 result) =>
            throw new NotSupportedException();
        static bool INumberBase<Int64x4>.TryConvertFromTruncating<TOther>(
            TOther value,
            out Int64x4 result) =>
            throw new NotSupportedException();
        static bool INumberBase<Int64x4>.TryConvertToChecked<TOther>(
            Int64x4 value,
            out TOther result) =>
            throw new NotSupportedException();
        static bool INumberBase<Int64x4>.TryConvertToSaturating<TOther>(
            Int64x4 value,
            out TOther result) =>
            throw new NotSupportedException();
        static bool INumberBase<Int64x4>.TryConvertToTruncating<TOther>(
            Int64x4 value,
            out TOther result) =>
            throw new NotSupportedException();
    }

    /// <summary>
    /// Represents a vectorized long type with length 8.
    /// </summary>
    public readonly record struct Int64x8(
        long X, long Y, long Z, long W, long I, long J, long K, long L) :
        IVectorType<Int64x8, long>
        , IAccumulationVectorType<
            Int64x8,
            UInt8x8,
            byte>
        , IAccumulationVectorType<
            Int64x8,
            Int8x8,
            sbyte>
        , IAccumulationVectorType<
            Int64x8,
            Int16x8,
            short>
        , IAccumulationVectorType<
            Int64x8,
            UInt16x8,
            ushort>
        , IAccumulationVectorType<
            Int64x8,
            Int32x8,
            int>
        , IAccumulationVectorType<
            Int64x8,
            UInt32x8,
            uint>
        , IAccumulationVectorType<
            Int64x8,
            Float32x8,
            float>
        , IAccumulationVectorType<
            Int64x8,
            Float64x8,
            double>
    {
        /// <summary>
        /// The offset of the X field in bytes.
        /// </summary>
        public static readonly int OffsetX =
            sizeof(long) * 0;

        /// <summary>
        /// The offset of the X field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrX =>
            new UIntPtr((uint)OffsetX);
        /// <summary>
        /// The offset of the Y field in bytes.
        /// </summary>
        public static readonly int OffsetY =
            sizeof(long) * 1;

        /// <summary>
        /// The offset of the Y field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrY =>
            new UIntPtr((uint)OffsetY);
        /// <summary>
        /// The offset of the Z field in bytes.
        /// </summary>
        public static readonly int OffsetZ =
            sizeof(long) * 2;

        /// <summary>
        /// The offset of the Z field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrZ =>
            new UIntPtr((uint)OffsetZ);
        /// <summary>
        /// The offset of the W field in bytes.
        /// </summary>
        public static readonly int OffsetW =
            sizeof(long) * 3;

        /// <summary>
        /// The offset of the W field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrW =>
            new UIntPtr((uint)OffsetW);
        /// <summary>
        /// The offset of the I field in bytes.
        /// </summary>
        public static readonly int OffsetI =
            sizeof(long) * 4;

        /// <summary>
        /// The offset of the I field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrI =>
            new UIntPtr((uint)OffsetI);
        /// <summary>
        /// The offset of the J field in bytes.
        /// </summary>
        public static readonly int OffsetJ =
            sizeof(long) * 5;

        /// <summary>
        /// The offset of the J field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrJ =>
            new UIntPtr((uint)OffsetJ);
        /// <summary>
        /// The offset of the K field in bytes.
        /// </summary>
        public static readonly int OffsetK =
            sizeof(long) * 6;

        /// <summary>
        /// The offset of the K field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrK =>
            new UIntPtr((uint)OffsetK);
        /// <summary>
        /// The offset of the L field in bytes.
        /// </summary>
        public static readonly int OffsetL =
            sizeof(long) * 7;

        /// <summary>
        /// The offset of the L field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrL =>
            new UIntPtr((uint)OffsetL);

        /// <summary>
        /// Returns the length of this vector which is 8.
        /// </summary>
        public static int Length => 8;

        /// <summary>
        /// Returns the radix of the underlying value.
        /// </summary>
        public static int Radix => 10;

        /// <summary>
        /// Returns an invalid value (min [signed types], max value [unsigned] or NaN).
        /// </summary>
        public static Int64x8 Invalid => FromScalar(
            long.MinValue
        );

        /// <summary>
        /// Returns the value zero.
        /// </summary>
        public static Int64x8 Zero => new();

        /// <summary>
        /// Returns the value one.
        /// </summary>
        public static Int64x8 One => FromScalar((1));

        /// <summary>
        /// Returns the value zero.
        /// </summary>
        public static Int64x8 AdditiveIdentity => Zero;

        /// <summary>
        /// Returns the value one.
        /// </summary>
        public static Int64x8 MultiplicativeIdentity => One;

        /// <summary>
        /// Computes the min value of both.
        /// </summary>
        /// <param name="first">The first value.</param>
        /// <param name="second">The second value.</param>
        /// <returns>The min value.</returns>
        public static Int64x8 Min(
            Int64x8 first,
            Int64x8 second) =>
            new Int64x8((long)Math.Min(first.X, second.X), (long)Math.Min(first.Y, second.Y), (long)Math.Min(first.Z, second.Z), (long)Math.Min(first.W, second.W), (long)Math.Min(first.I, second.I), (long)Math.Min(first.J, second.J), (long)Math.Min(first.K, second.K), (long)Math.Min(first.L, second.L));

        /// <summary>
        /// Computes the max value of both.
        /// </summary>
        /// <param name="first">The first value.</param>
        /// <param name="second">The second value.</param>
        /// <returns>The max value.</returns>
        public static Int64x8 Max(
            Int64x8 first,
            Int64x8 second) =>
            new Int64x8((long)Math.Max(first.X, second.X), (long)Math.Max(first.Y, second.Y), (long)Math.Max(first.Z, second.Z), (long)Math.Max(first.W, second.W), (long)Math.Max(first.I, second.I), (long)Math.Max(first.J, second.J), (long)Math.Max(first.K, second.K), (long)Math.Max(first.L, second.L));

        /// <summary>
        /// Clamps the given value.
        /// </summary>
        /// <param name="value">The value to clamp.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The clamped value.</returns>
        public static Int64x8 Clamp(
            Int64x8 value,
            Int64x8 min,
            Int64x8 max) =>
            Max(Min(value, max), min);

        /// <summary>
        /// Creates a random scalar instance falling into the range of min max.
        /// </summary>
        /// <param name="random">The random provider to use.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The created random scalar instance.</returns>
        public static long GetRandomScalar<TRandom>(
            ref TRandom random,
            long min,
            long max)
            where TRandom : struct, IRandomProvider =>
            (long)RandomExtensions.
                Next(ref random, min, max);

        /// <summary>
        /// Creates a random vector instance falling into the range of min max.
        /// </summary>
        /// <param name="random">The random provider to use.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The created random vector instance.</returns>
        public static Int64x8 GetRandom<TRandom>(
            ref TRandom random,
            Int64x8 min,
            Int64x8 max)
            where TRandom : struct, IRandomProvider
        {
            long x = GetRandomScalar(
                ref random, min.X, max.X);
            long y = GetRandomScalar(
                ref random, min.Y, max.Y);
            long z = GetRandomScalar(
                ref random, min.Z, max.Z);
            long w = GetRandomScalar(
                ref random, min.W, max.W);
            long i = GetRandomScalar(
                ref random, min.I, max.I);
            long j = GetRandomScalar(
                ref random, min.J, max.J);
            long k = GetRandomScalar(
                ref random, min.K, max.K);
            long l = GetRandomScalar(
                ref random, min.L, max.L);
            return new Int64x8(x, y, z, w, i, j, k, l);
        }

        /// <summary>
        /// Creates a vector instance from the given source view.
        /// </summary>
        /// <typeparam name="TStride">The custom stride type.</typeparam>
        /// <param name="sourceView">The source view.</param>
        /// <param name="index">The source base index.</param>
        /// <returns>The vector instance.</returns>
        public static Int64x8 FromElementView<TStride>(
            ArrayView1D<long, TStride> sourceView,
            Index1D index)
            where TStride : struct, IStride1D =>
            new Int64x8(
                sourceView[index + 0],
                sourceView[index + 1],
                sourceView[index + 2],
                sourceView[index + 3],
                sourceView[index + 4],
                sourceView[index + 5],
                sourceView[index + 6],
                sourceView[index + 7]
                );

        /// <summary>
        /// Serializes the current vector instance into the given target view.
        /// </summary>
        /// <typeparam name="TStride">The custom stride type.</typeparam>
        /// <param name="targetView">The target view.</param>
        /// <param name="index">The target base index.</param>
        public void ToElementView<TStride>(
            ArrayView1D<long, TStride> targetView,
            Index1D index)
            where TStride : struct, IStride1D
        {
            targetView[index + 0] = X;
            targetView[index + 1] = Y;
            targetView[index + 2] = Z;
            targetView[index + 3] = W;
            targetView[index + 4] = I;
            targetView[index + 5] = J;
            targetView[index + 6] = K;
            targetView[index + 7] = L;
        }

        /// <summary>
        /// Creates a vector instance from the given source view.
        /// </summary>
        /// <param name="sourceView">The source view.</param>
        /// <param name="index">The source base index.</param>
        /// <returns>The vector instance.</returns>
        public static Int64x8 FromElementView(
            SingleVectorView<long> sourceView,
            Index1D index) =>
            new Int64x8(
                sourceView[index + 0],
                sourceView[index + 1],
                sourceView[index + 2],
                sourceView[index + 3],
                sourceView[index + 4],
                sourceView[index + 5],
                sourceView[index + 6],
                sourceView[index + 7]
                );

        /// <summary>
        /// Serializes the current vector instance into the given target view.
        /// </summary>
        /// <param name="targetView">The target view.</param>
        /// <param name="index">The target base index.</param>
        public void ToElementView(
            SingleVectorView<long> targetView,
            Index1D index)
        {
            targetView[index + 0] = X;
            targetView[index + 1] = Y;
            targetView[index + 2] = Z;
            targetView[index + 3] = W;
            targetView[index + 4] = I;
            targetView[index + 5] = J;
            targetView[index + 6] = K;
            targetView[index + 7] = L;
        }

        /// <summary>
        /// Converts a scalar value into the current vectorized type.
        /// </summary>
        /// <param name="scalar">The scalar element type.</param>
        /// <returns>The created vectorized type.</returns>
        public static Int64x8 FromScalar(long scalar) =>
            new Int64x8(scalar, scalar, scalar, scalar, scalar, scalar, scalar, scalar);

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        public static void AtomicAdd(ref Int64x8 target, Int64x8 value)
        {
            ref var elementRef = ref Unsafe.As<Int64x8, long>(
                ref target);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrX),
                value.X);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrY),
                value.Y);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrZ),
                value.Z);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrW),
                value.W);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrI),
                value.I);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrJ),
                value.J);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrK),
                value.K);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrL),
                value.L);
        }

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        public Int64x8 ComputeAverage(long denominator) =>
            this / FromScalar((long)denominator);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int64x8 operator +(
            Int64x8 current,
            UInt8x8 toAccumulate) =>
            current + ConvertFrom_byte(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int64x8 operator +(
            UInt8x8 toAccumulate,
            Int64x8 current) =>
            ConvertFrom_byte(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int64x8 operator -(
            Int64x8 current,
            UInt8x8 toAccumulate) =>
            current - ConvertFrom_byte(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int64x8 operator -(
            UInt8x8 toAccumulate,
            Int64x8 current) =>
            ConvertFrom_byte(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref Int64x8 target,
            UInt8x8 value) =>
            AtomicAdd(ref target, ConvertFrom_byte(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int64x8 ConvertFrom_byte(
            UInt8x8 other) =>
            new Int64x8((long)other.X, (long)other.Y, (long)other.Z, (long)other.W, (long)other.I, (long)other.J, (long)other.K, (long)other.L);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt8x8 ConvertTo_byte(
            Int64x8 current) =>
            new UInt8x8((byte)current.X, (byte)current.Y, (byte)current.Z, (byte)current.W, (byte)current.I, (byte)current.J, (byte)current.K, (byte)current.L);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int64x8 IAccumulationVectorType<
            Int64x8,
            UInt8x8,
            byte>.ConvertFromBase(UInt8x8 other) =>
            ConvertFrom_byte(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt8x8 IAccumulationVectorType<
            Int64x8,
            UInt8x8,
            byte>.ConvertToBase(Int64x8 current) =>
            ConvertTo_byte(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public Int64x8 ComputeAverage(byte denominator) =>
            this / FromScalar((long)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int64x8 operator +(
            Int64x8 current,
            Int8x8 toAccumulate) =>
            current + ConvertFrom_sbyte(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int64x8 operator +(
            Int8x8 toAccumulate,
            Int64x8 current) =>
            ConvertFrom_sbyte(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int64x8 operator -(
            Int64x8 current,
            Int8x8 toAccumulate) =>
            current - ConvertFrom_sbyte(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int64x8 operator -(
            Int8x8 toAccumulate,
            Int64x8 current) =>
            ConvertFrom_sbyte(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref Int64x8 target,
            Int8x8 value) =>
            AtomicAdd(ref target, ConvertFrom_sbyte(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int64x8 ConvertFrom_sbyte(
            Int8x8 other) =>
            new Int64x8((long)other.X, (long)other.Y, (long)other.Z, (long)other.W, (long)other.I, (long)other.J, (long)other.K, (long)other.L);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int8x8 ConvertTo_sbyte(
            Int64x8 current) =>
            new Int8x8((sbyte)current.X, (sbyte)current.Y, (sbyte)current.Z, (sbyte)current.W, (sbyte)current.I, (sbyte)current.J, (sbyte)current.K, (sbyte)current.L);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int64x8 IAccumulationVectorType<
            Int64x8,
            Int8x8,
            sbyte>.ConvertFromBase(Int8x8 other) =>
            ConvertFrom_sbyte(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int8x8 IAccumulationVectorType<
            Int64x8,
            Int8x8,
            sbyte>.ConvertToBase(Int64x8 current) =>
            ConvertTo_sbyte(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public Int64x8 ComputeAverage(sbyte denominator) =>
            this / FromScalar((long)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int64x8 operator +(
            Int64x8 current,
            Int16x8 toAccumulate) =>
            current + ConvertFrom_short(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int64x8 operator +(
            Int16x8 toAccumulate,
            Int64x8 current) =>
            ConvertFrom_short(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int64x8 operator -(
            Int64x8 current,
            Int16x8 toAccumulate) =>
            current - ConvertFrom_short(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int64x8 operator -(
            Int16x8 toAccumulate,
            Int64x8 current) =>
            ConvertFrom_short(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(true)]
        public static void AtomicAdd(
            ref Int64x8 target,
            Int16x8 value) =>
            AtomicAdd(ref target, ConvertFrom_short(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int64x8 ConvertFrom_short(
            Int16x8 other) =>
            new Int64x8((long)other.X, (long)other.Y, (long)other.Z, (long)other.W, (long)other.I, (long)other.J, (long)other.K, (long)other.L);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int16x8 ConvertTo_short(
            Int64x8 current) =>
            new Int16x8((short)current.X, (short)current.Y, (short)current.Z, (short)current.W, (short)current.I, (short)current.J, (short)current.K, (short)current.L);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int64x8 IAccumulationVectorType<
            Int64x8,
            Int16x8,
            short>.ConvertFromBase(Int16x8 other) =>
            ConvertFrom_short(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int16x8 IAccumulationVectorType<
            Int64x8,
            Int16x8,
            short>.ConvertToBase(Int64x8 current) =>
            ConvertTo_short(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(true)]
        public Int64x8 ComputeAverage(short denominator) =>
            this / FromScalar((long)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int64x8 operator +(
            Int64x8 current,
            UInt16x8 toAccumulate) =>
            current + ConvertFrom_ushort(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int64x8 operator +(
            UInt16x8 toAccumulate,
            Int64x8 current) =>
            ConvertFrom_ushort(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int64x8 operator -(
            Int64x8 current,
            UInt16x8 toAccumulate) =>
            current - ConvertFrom_ushort(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int64x8 operator -(
            UInt16x8 toAccumulate,
            Int64x8 current) =>
            ConvertFrom_ushort(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref Int64x8 target,
            UInt16x8 value) =>
            AtomicAdd(ref target, ConvertFrom_ushort(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int64x8 ConvertFrom_ushort(
            UInt16x8 other) =>
            new Int64x8((long)other.X, (long)other.Y, (long)other.Z, (long)other.W, (long)other.I, (long)other.J, (long)other.K, (long)other.L);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt16x8 ConvertTo_ushort(
            Int64x8 current) =>
            new UInt16x8((ushort)current.X, (ushort)current.Y, (ushort)current.Z, (ushort)current.W, (ushort)current.I, (ushort)current.J, (ushort)current.K, (ushort)current.L);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int64x8 IAccumulationVectorType<
            Int64x8,
            UInt16x8,
            ushort>.ConvertFromBase(UInt16x8 other) =>
            ConvertFrom_ushort(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt16x8 IAccumulationVectorType<
            Int64x8,
            UInt16x8,
            ushort>.ConvertToBase(Int64x8 current) =>
            ConvertTo_ushort(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public Int64x8 ComputeAverage(ushort denominator) =>
            this / FromScalar((long)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int64x8 operator +(
            Int64x8 current,
            Int32x8 toAccumulate) =>
            current + ConvertFrom_int(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int64x8 operator +(
            Int32x8 toAccumulate,
            Int64x8 current) =>
            ConvertFrom_int(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int64x8 operator -(
            Int64x8 current,
            Int32x8 toAccumulate) =>
            current - ConvertFrom_int(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int64x8 operator -(
            Int32x8 toAccumulate,
            Int64x8 current) =>
            ConvertFrom_int(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(true)]
        public static void AtomicAdd(
            ref Int64x8 target,
            Int32x8 value) =>
            AtomicAdd(ref target, ConvertFrom_int(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int64x8 ConvertFrom_int(
            Int32x8 other) =>
            new Int64x8((long)other.X, (long)other.Y, (long)other.Z, (long)other.W, (long)other.I, (long)other.J, (long)other.K, (long)other.L);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int32x8 ConvertTo_int(
            Int64x8 current) =>
            new Int32x8((int)current.X, (int)current.Y, (int)current.Z, (int)current.W, (int)current.I, (int)current.J, (int)current.K, (int)current.L);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int64x8 IAccumulationVectorType<
            Int64x8,
            Int32x8,
            int>.ConvertFromBase(Int32x8 other) =>
            ConvertFrom_int(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int32x8 IAccumulationVectorType<
            Int64x8,
            Int32x8,
            int>.ConvertToBase(Int64x8 current) =>
            ConvertTo_int(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(true)]
        public Int64x8 ComputeAverage(int denominator) =>
            this / FromScalar((long)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int64x8 operator +(
            Int64x8 current,
            UInt32x8 toAccumulate) =>
            current + ConvertFrom_uint(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int64x8 operator +(
            UInt32x8 toAccumulate,
            Int64x8 current) =>
            ConvertFrom_uint(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int64x8 operator -(
            Int64x8 current,
            UInt32x8 toAccumulate) =>
            current - ConvertFrom_uint(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Int64x8 operator -(
            UInt32x8 toAccumulate,
            Int64x8 current) =>
            ConvertFrom_uint(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref Int64x8 target,
            UInt32x8 value) =>
            AtomicAdd(ref target, ConvertFrom_uint(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int64x8 ConvertFrom_uint(
            UInt32x8 other) =>
            new Int64x8((long)other.X, (long)other.Y, (long)other.Z, (long)other.W, (long)other.I, (long)other.J, (long)other.K, (long)other.L);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt32x8 ConvertTo_uint(
            Int64x8 current) =>
            new UInt32x8((uint)current.X, (uint)current.Y, (uint)current.Z, (uint)current.W, (uint)current.I, (uint)current.J, (uint)current.K, (uint)current.L);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int64x8 IAccumulationVectorType<
            Int64x8,
            UInt32x8,
            uint>.ConvertFromBase(UInt32x8 other) =>
            ConvertFrom_uint(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt32x8 IAccumulationVectorType<
            Int64x8,
            UInt32x8,
            uint>.ConvertToBase(Int64x8 current) =>
            ConvertTo_uint(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public Int64x8 ComputeAverage(uint denominator) =>
            this / FromScalar((long)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int64x8 operator +(
            Int64x8 current,
            Float32x8 toAccumulate) =>
            current + ConvertFrom_float(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int64x8 operator +(
            Float32x8 toAccumulate,
            Int64x8 current) =>
            ConvertFrom_float(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int64x8 operator -(
            Int64x8 current,
            Float32x8 toAccumulate) =>
            current - ConvertFrom_float(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int64x8 operator -(
            Float32x8 toAccumulate,
            Int64x8 current) =>
            ConvertFrom_float(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(true)]
        public static void AtomicAdd(
            ref Int64x8 target,
            Float32x8 value) =>
            AtomicAdd(ref target, ConvertFrom_float(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int64x8 ConvertFrom_float(
            Float32x8 other) =>
            new Int64x8((long)other.X, (long)other.Y, (long)other.Z, (long)other.W, (long)other.I, (long)other.J, (long)other.K, (long)other.L);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float32x8 ConvertTo_float(
            Int64x8 current) =>
            new Float32x8((float)current.X, (float)current.Y, (float)current.Z, (float)current.W, (float)current.I, (float)current.J, (float)current.K, (float)current.L);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int64x8 IAccumulationVectorType<
            Int64x8,
            Float32x8,
            float>.ConvertFromBase(Float32x8 other) =>
            ConvertFrom_float(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float32x8 IAccumulationVectorType<
            Int64x8,
            Float32x8,
            float>.ConvertToBase(Int64x8 current) =>
            ConvertTo_float(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(true)]
        public Int64x8 ComputeAverage(float denominator) =>
            this / FromScalar((long)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int64x8 operator +(
            Int64x8 current,
            Float64x8 toAccumulate) =>
            current + ConvertFrom_double(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int64x8 operator +(
            Float64x8 toAccumulate,
            Int64x8 current) =>
            ConvertFrom_double(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int64x8 operator -(
            Int64x8 current,
            Float64x8 toAccumulate) =>
            current - ConvertFrom_double(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Int64x8 operator -(
            Float64x8 toAccumulate,
            Int64x8 current) =>
            ConvertFrom_double(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(true)]
        public static void AtomicAdd(
            ref Int64x8 target,
            Float64x8 value) =>
            AtomicAdd(ref target, ConvertFrom_double(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int64x8 ConvertFrom_double(
            Float64x8 other) =>
            new Int64x8((long)other.X, (long)other.Y, (long)other.Z, (long)other.W, (long)other.I, (long)other.J, (long)other.K, (long)other.L);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float64x8 ConvertTo_double(
            Int64x8 current) =>
            new Float64x8((double)current.X, (double)current.Y, (double)current.Z, (double)current.W, (double)current.I, (double)current.J, (double)current.K, (double)current.L);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int64x8 IAccumulationVectorType<
            Int64x8,
            Float64x8,
            double>.ConvertFromBase(Float64x8 other) =>
            ConvertFrom_double(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float64x8 IAccumulationVectorType<
            Int64x8,
            Float64x8,
            double>.ConvertToBase(Int64x8 current) =>
            ConvertTo_double(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(true)]
        public Int64x8 ComputeAverage(double denominator) =>
            this / FromScalar((long)denominator);

        /// <summary>
        /// Converts this instance into an unsafe span instance.
        /// </summary>
        /// <returns>The readonly span instance.</returns>
        public unsafe ReadOnlySpan<long> AsSpan() =>
            new(Unsafe.AsPointer(ref Unsafe.AsRef(this)), 8);

        /// <summary>
        /// Iterates over all elements by applying the given iterator to each element.
        /// </summary>
        /// <typeparam name="TIterator">The managed iterator type.</typeparam>
        /// <param name="iterator">The iterator to invoke.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ForEach<TIterator>(ref TIterator iterator)
            where TIterator : struct, IVectorElementIterator<
            Int64x8,
            long>
        {
            iterator.Iterate(X, 0);
            iterator.Iterate(Y, 1);
            iterator.Iterate(Z, 2);
            iterator.Iterate(W, 3);
            iterator.Iterate(I, 4);
            iterator.Iterate(J, 5);
            iterator.Iterate(K, 6);
            iterator.Iterate(L, 7);
        }

        /// <summary>
        /// Converts this vector instance to a string.
        /// </summary>
        public override string ToString() =>
            $"{X}, {Y}, {Z}, {W}, {I}, {J}, {K}, {L}";

        /// <summary>
        /// Converts this vector instance to a string.
        /// </summary>
        public string ToString(string? format, IFormatProvider? formatProvider) =>
            $"{X.ToString(format, formatProvider)}, {Y.ToString(format, formatProvider)}, {Z.ToString(format, formatProvider)}, {W.ToString(format, formatProvider)}, {I.ToString(format, formatProvider)}, {J.ToString(format, formatProvider)}, {K.ToString(format, formatProvider)}, {L.ToString(format, formatProvider)}";

        /// <summary>
        /// Returns true.
        /// </summary>
        public static bool IsCanonical(Int64x8 value) => true;

        /// <summary>
        /// Returns false.
        /// </summary>
        public static bool IsComplexNumber(Int64x8 value) => false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsEvenInteger(Int64x8 value) =>
            long.IsEvenInteger(value.X) & long.IsEvenInteger(value.Y) & long.IsEvenInteger(value.Z) & long.IsEvenInteger(value.W) & long.IsEvenInteger(value.I) & long.IsEvenInteger(value.J) & long.IsEvenInteger(value.K) & long.IsEvenInteger(value.L);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsFinite(Int64x8 value) =>
            true;

        /// <summary>
        /// Returns false.
        /// </summary>
        public static bool IsImaginaryNumber(Int64x8 value) => false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsInfinity(Int64x8 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsInteger(Int64x8 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNaN(Int64x8 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNegative(Int64x8 value) =>
            long.IsNegative(value.X) & long.IsNegative(value.Y) & long.IsNegative(value.Z) & long.IsNegative(value.W) & long.IsNegative(value.I) & long.IsNegative(value.J) & long.IsNegative(value.K) & long.IsNegative(value.L);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNegativeInfinity(Int64x8 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNormal(Int64x8 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsOddInteger(Int64x8 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsPositive(Int64x8 value) =>
            long.IsPositive(value.X) & long.IsPositive(value.Y) & long.IsPositive(value.Z) & long.IsPositive(value.W) & long.IsPositive(value.I) & long.IsPositive(value.J) & long.IsPositive(value.K) & long.IsPositive(value.L);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsPositiveInfinity(Int64x8 value) =>
            false;

        /// <summary>
        /// Returns true.
        /// </summary>
        public static bool IsRealNumber(Int64x8 value) => true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsSubnormal(Int64x8 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsZero(Int64x8 value) =>
            value == Zero;

        /// <summary>
        /// Returns the absolute value.
        /// </summary>
        public static Int64x8 Abs(Int64x8 value) =>
            new Int64x8(Math.Abs(value.X), Math.Abs(value.Y), Math.Abs(value.Z), Math.Abs(value.W), Math.Abs(value.I), Math.Abs(value.J), Math.Abs(value.K), Math.Abs(value.L));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int64x8 operator +(Int64x8 left, Int64x8 right) =>
            new Int64x8((long)(left.X + right.X), (long)(left.Y + right.Y), (long)(left.Z + right.Z), (long)(left.W + right.W), (long)(left.I + right.I), (long)(left.J + right.J), (long)(left.K + right.K), (long)(left.L + right.L));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int64x8 operator --(Int64x8 value) => value - One;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int64x8 operator /(Int64x8 left, Int64x8 right) =>
            new Int64x8((long)(left.X / right.X), (long)(left.Y / right.Y), (long)(left.Z / right.Z), (long)(left.W / right.W), (long)(left.I / right.I), (long)(left.J / right.J), (long)(left.K / right.K), (long)(left.L / right.L));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int64x8 operator ++(Int64x8 value) => value + One;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int64x8 operator *(Int64x8 left, Int64x8 right) =>
            new Int64x8((long)(left.X * right.X), (long)(left.Y * right.Y), (long)(left.Z * right.Z), (long)(left.W * right.W), (long)(left.I * right.I), (long)(left.J * right.J), (long)(left.K * right.K), (long)(left.L * right.L));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int64x8 operator -(Int64x8 left, Int64x8 right) =>
            new Int64x8((long)(left.X - right.X), (long)(left.Y - right.Y), (long)(left.Z - right.Z), (long)(left.W - right.W), (long)(left.I - right.I), (long)(left.J - right.J), (long)(left.K - right.K), (long)(left.L - right.L));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int64x8 operator -(Int64x8 value) =>
            new Int64x8((long)-value.X, (long)-value.Y, (long)-value.Z, (long)-value.W, (long)-value.I, (long)-value.J, (long)-value.K, (long)-value.L);

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int64x8 operator +(Int64x8 value) => value;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int64x8 MaxMagnitude(Int64x8 x, Int64x8 y) =>
            new Int64x8(long.MaxMagnitude(x.X, y.X), long.MaxMagnitude(x.Y, y.Y), long.MaxMagnitude(x.Z, y.Z), long.MaxMagnitude(x.W, y.W), long.MaxMagnitude(x.I, y.I), long.MaxMagnitude(x.J, y.J), long.MaxMagnitude(x.K, y.K), long.MaxMagnitude(x.L, y.L));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int64x8 MaxMagnitudeNumber(Int64x8 x, Int64x8 y) =>
            MaxMagnitude(x, y);

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int64x8 MinMagnitude(Int64x8 x, Int64x8 y) =>
            new Int64x8(long.MinMagnitude(x.X, y.X), long.MinMagnitude(x.Y, y.Y), long.MinMagnitude(x.Z, y.Z), long.MinMagnitude(x.W, y.W), long.MinMagnitude(x.I, y.I), long.MinMagnitude(x.J, y.J), long.MinMagnitude(x.K, y.K), long.MinMagnitude(x.L, y.L));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Int64x8 MinMagnitudeNumber(Int64x8 x, Int64x8 y) =>
            MinMagnitude(x, y);

        // Not supported operations

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static Int64x8 IParsable<Int64x8>.Parse(
            string s,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static Int64x8 ISpanParsable<Int64x8>.Parse(
            ReadOnlySpan<char> s,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static Int64x8 INumberBase<Int64x8>.Parse(
            ReadOnlySpan<char> s,
            NumberStyles style,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static Int64x8 INumberBase<Int64x8>.Parse(
            string s,
            NumberStyles style,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        bool ISpanFormattable.TryFormat(
            Span<char> destination,
            out int charsWritten,
            ReadOnlySpan<char> format,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool IParsable<Int64x8>.TryParse(
            string? s,
            IFormatProvider? provider,
            out Int64x8 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given span into a vectorized instance.
        /// </summary>
        static bool ISpanParsable<Int64x8>.TryParse(
            ReadOnlySpan<char> s,
            IFormatProvider? provider,
            out Int64x8 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool INumberBase<Int64x8>.TryParse(
            ReadOnlySpan<char> s,
            NumberStyles style,
            IFormatProvider? provider,
            out Int64x8 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool INumberBase<Int64x8>.TryParse(
            string? s,
            NumberStyles style,
            IFormatProvider? provider,
            out Int64x8 result) =>
            throw new NotSupportedException();

        static bool INumberBase<Int64x8>.TryConvertFromChecked<TOther>(
            TOther value,
            out Int64x8 result) =>
            throw new NotSupportedException();
        static bool INumberBase<Int64x8>.TryConvertFromSaturating<TOther>(
            TOther value,
            out Int64x8 result) =>
            throw new NotSupportedException();
        static bool INumberBase<Int64x8>.TryConvertFromTruncating<TOther>(
            TOther value,
            out Int64x8 result) =>
            throw new NotSupportedException();
        static bool INumberBase<Int64x8>.TryConvertToChecked<TOther>(
            Int64x8 value,
            out TOther result) =>
            throw new NotSupportedException();
        static bool INumberBase<Int64x8>.TryConvertToSaturating<TOther>(
            Int64x8 value,
            out TOther result) =>
            throw new NotSupportedException();
        static bool INumberBase<Int64x8>.TryConvertToTruncating<TOther>(
            Int64x8 value,
            out TOther result) =>
            throw new NotSupportedException();
    }

    /// <summary>
    /// Represents a vectorized byte type with length 2.
    /// </summary>
    [CLSCompliant(false)]
    public readonly record struct UInt8x2(
        byte X, byte Y) :
        IVectorType<UInt8x2, byte>
    {
        /// <summary>
        /// The offset of the X field in bytes.
        /// </summary>
        public static readonly int OffsetX =
            sizeof(byte) * 0;

        /// <summary>
        /// The offset of the X field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrX =>
            new UIntPtr((uint)OffsetX);
        /// <summary>
        /// The offset of the Y field in bytes.
        /// </summary>
        public static readonly int OffsetY =
            sizeof(byte) * 1;

        /// <summary>
        /// The offset of the Y field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrY =>
            new UIntPtr((uint)OffsetY);

        /// <summary>
        /// Returns the length of this vector which is 2.
        /// </summary>
        public static int Length => 2;

        /// <summary>
        /// Returns the radix of the underlying value.
        /// </summary>
        public static int Radix => 10;

        /// <summary>
        /// Returns an invalid value (min [signed types], max value [unsigned] or NaN).
        /// </summary>
        public static UInt8x2 Invalid => FromScalar(
            byte.MaxValue
        );

        /// <summary>
        /// Returns the value zero.
        /// </summary>
        public static UInt8x2 Zero => new();

        /// <summary>
        /// Returns the value one.
        /// </summary>
        public static UInt8x2 One => FromScalar((1));

        /// <summary>
        /// Returns the value zero.
        /// </summary>
        public static UInt8x2 AdditiveIdentity => Zero;

        /// <summary>
        /// Returns the value one.
        /// </summary>
        public static UInt8x2 MultiplicativeIdentity => One;

        /// <summary>
        /// Computes the min value of both.
        /// </summary>
        /// <param name="first">The first value.</param>
        /// <param name="second">The second value.</param>
        /// <returns>The min value.</returns>
        public static UInt8x2 Min(
            UInt8x2 first,
            UInt8x2 second) =>
            new UInt8x2((byte)Math.Min(first.X, second.X), (byte)Math.Min(first.Y, second.Y));

        /// <summary>
        /// Computes the max value of both.
        /// </summary>
        /// <param name="first">The first value.</param>
        /// <param name="second">The second value.</param>
        /// <returns>The max value.</returns>
        public static UInt8x2 Max(
            UInt8x2 first,
            UInt8x2 second) =>
            new UInt8x2((byte)Math.Max(first.X, second.X), (byte)Math.Max(first.Y, second.Y));

        /// <summary>
        /// Clamps the given value.
        /// </summary>
        /// <param name="value">The value to clamp.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The clamped value.</returns>
        public static UInt8x2 Clamp(
            UInt8x2 value,
            UInt8x2 min,
            UInt8x2 max) =>
            Max(Min(value, max), min);

        /// <summary>
        /// Creates a random scalar instance falling into the range of min max.
        /// </summary>
        /// <param name="random">The random provider to use.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The created random scalar instance.</returns>
        public static byte GetRandomScalar<TRandom>(
            ref TRandom random,
            byte min,
            byte max)
            where TRandom : struct, IRandomProvider =>
            (byte)RandomExtensions.
                Next(ref random, min, max);

        /// <summary>
        /// Creates a random vector instance falling into the range of min max.
        /// </summary>
        /// <param name="random">The random provider to use.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The created random vector instance.</returns>
        public static UInt8x2 GetRandom<TRandom>(
            ref TRandom random,
            UInt8x2 min,
            UInt8x2 max)
            where TRandom : struct, IRandomProvider
        {
            byte x = GetRandomScalar(
                ref random, min.X, max.X);
            byte y = GetRandomScalar(
                ref random, min.Y, max.Y);
            return new UInt8x2(x, y);
        }

        /// <summary>
        /// Creates a vector instance from the given source view.
        /// </summary>
        /// <typeparam name="TStride">The custom stride type.</typeparam>
        /// <param name="sourceView">The source view.</param>
        /// <param name="index">The source base index.</param>
        /// <returns>The vector instance.</returns>
        public static UInt8x2 FromElementView<TStride>(
            ArrayView1D<byte, TStride> sourceView,
            Index1D index)
            where TStride : struct, IStride1D =>
            new UInt8x2(
                sourceView[index + 0],
                sourceView[index + 1]
                );

        /// <summary>
        /// Serializes the current vector instance into the given target view.
        /// </summary>
        /// <typeparam name="TStride">The custom stride type.</typeparam>
        /// <param name="targetView">The target view.</param>
        /// <param name="index">The target base index.</param>
        public void ToElementView<TStride>(
            ArrayView1D<byte, TStride> targetView,
            Index1D index)
            where TStride : struct, IStride1D
        {
            targetView[index + 0] = X;
            targetView[index + 1] = Y;
        }

        /// <summary>
        /// Creates a vector instance from the given source view.
        /// </summary>
        /// <param name="sourceView">The source view.</param>
        /// <param name="index">The source base index.</param>
        /// <returns>The vector instance.</returns>
        public static UInt8x2 FromElementView(
            SingleVectorView<byte> sourceView,
            Index1D index) =>
            new UInt8x2(
                sourceView[index + 0],
                sourceView[index + 1]
                );

        /// <summary>
        /// Serializes the current vector instance into the given target view.
        /// </summary>
        /// <param name="targetView">The target view.</param>
        /// <param name="index">The target base index.</param>
        public void ToElementView(
            SingleVectorView<byte> targetView,
            Index1D index)
        {
            targetView[index + 0] = X;
            targetView[index + 1] = Y;
        }

        /// <summary>
        /// Converts a scalar value into the current vectorized type.
        /// </summary>
        /// <param name="scalar">The scalar element type.</param>
        /// <returns>The created vectorized type.</returns>
        public static UInt8x2 FromScalar(byte scalar) =>
            new UInt8x2(scalar, scalar);

        /// <summary>
        /// Converts this instance into an unsafe span instance.
        /// </summary>
        /// <returns>The readonly span instance.</returns>
        public unsafe ReadOnlySpan<byte> AsSpan() =>
            new(Unsafe.AsPointer(ref Unsafe.AsRef(this)), 2);

        /// <summary>
        /// Iterates over all elements by applying the given iterator to each element.
        /// </summary>
        /// <typeparam name="TIterator">The managed iterator type.</typeparam>
        /// <param name="iterator">The iterator to invoke.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ForEach<TIterator>(ref TIterator iterator)
            where TIterator : struct, IVectorElementIterator<
            UInt8x2,
            byte>
        {
            iterator.Iterate(X, 0);
            iterator.Iterate(Y, 1);
        }

        /// <summary>
        /// Converts this vector instance to a string.
        /// </summary>
        public override string ToString() =>
            $"{X}, {Y}";

        /// <summary>
        /// Converts this vector instance to a string.
        /// </summary>
        public string ToString(string? format, IFormatProvider? formatProvider) =>
            $"{X.ToString(format, formatProvider)}, {Y.ToString(format, formatProvider)}";

        /// <summary>
        /// Returns true.
        /// </summary>
        public static bool IsCanonical(UInt8x2 value) => true;

        /// <summary>
        /// Returns false.
        /// </summary>
        public static bool IsComplexNumber(UInt8x2 value) => false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsEvenInteger(UInt8x2 value) =>
            byte.IsEvenInteger(value.X) & byte.IsEvenInteger(value.Y);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsFinite(UInt8x2 value) =>
            true;

        /// <summary>
        /// Returns false.
        /// </summary>
        public static bool IsImaginaryNumber(UInt8x2 value) => false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsInfinity(UInt8x2 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsInteger(UInt8x2 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNaN(UInt8x2 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNegative(UInt8x2 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNegativeInfinity(UInt8x2 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNormal(UInt8x2 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsOddInteger(UInt8x2 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsPositive(UInt8x2 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsPositiveInfinity(UInt8x2 value) =>
            false;

        /// <summary>
        /// Returns true.
        /// </summary>
        public static bool IsRealNumber(UInt8x2 value) => true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsSubnormal(UInt8x2 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsZero(UInt8x2 value) =>
            value == Zero;

        /// <summary>
        /// Returns the absolute value.
        /// </summary>
        public static UInt8x2 Abs(UInt8x2 value) =>
            value;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt8x2 operator +(UInt8x2 left, UInt8x2 right) =>
            new UInt8x2((byte)(left.X + right.X), (byte)(left.Y + right.Y));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt8x2 operator --(UInt8x2 value) => value - One;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt8x2 operator /(UInt8x2 left, UInt8x2 right) =>
            new UInt8x2((byte)(left.X / right.X), (byte)(left.Y / right.Y));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt8x2 operator ++(UInt8x2 value) => value + One;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt8x2 operator *(UInt8x2 left, UInt8x2 right) =>
            new UInt8x2((byte)(left.X * right.X), (byte)(left.Y * right.Y));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt8x2 operator -(UInt8x2 left, UInt8x2 right) =>
            new UInt8x2((byte)(left.X - right.X), (byte)(left.Y - right.Y));

        /// <summary>
        /// Not supported operation.
        /// </summary>
        static UInt8x2 IUnaryNegationOperators<UInt8x2, UInt8x2>.
            operator -(UInt8x2 value) => value;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt8x2 operator +(UInt8x2 value) => value;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt8x2 MaxMagnitude(UInt8x2 x, UInt8x2 y) =>
            Max(x, y);

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt8x2 MaxMagnitudeNumber(UInt8x2 x, UInt8x2 y) =>
            MaxMagnitude(x, y);

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt8x2 MinMagnitude(UInt8x2 x, UInt8x2 y) =>
            Min(x, y);

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt8x2 MinMagnitudeNumber(UInt8x2 x, UInt8x2 y) =>
            MinMagnitude(x, y);

        // Not supported operations

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static UInt8x2 IParsable<UInt8x2>.Parse(
            string s,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static UInt8x2 ISpanParsable<UInt8x2>.Parse(
            ReadOnlySpan<char> s,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static UInt8x2 INumberBase<UInt8x2>.Parse(
            ReadOnlySpan<char> s,
            NumberStyles style,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static UInt8x2 INumberBase<UInt8x2>.Parse(
            string s,
            NumberStyles style,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        bool ISpanFormattable.TryFormat(
            Span<char> destination,
            out int charsWritten,
            ReadOnlySpan<char> format,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool IParsable<UInt8x2>.TryParse(
            string? s,
            IFormatProvider? provider,
            out UInt8x2 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given span into a vectorized instance.
        /// </summary>
        static bool ISpanParsable<UInt8x2>.TryParse(
            ReadOnlySpan<char> s,
            IFormatProvider? provider,
            out UInt8x2 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool INumberBase<UInt8x2>.TryParse(
            ReadOnlySpan<char> s,
            NumberStyles style,
            IFormatProvider? provider,
            out UInt8x2 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool INumberBase<UInt8x2>.TryParse(
            string? s,
            NumberStyles style,
            IFormatProvider? provider,
            out UInt8x2 result) =>
            throw new NotSupportedException();

        static bool INumberBase<UInt8x2>.TryConvertFromChecked<TOther>(
            TOther value,
            out UInt8x2 result) =>
            throw new NotSupportedException();
        static bool INumberBase<UInt8x2>.TryConvertFromSaturating<TOther>(
            TOther value,
            out UInt8x2 result) =>
            throw new NotSupportedException();
        static bool INumberBase<UInt8x2>.TryConvertFromTruncating<TOther>(
            TOther value,
            out UInt8x2 result) =>
            throw new NotSupportedException();
        static bool INumberBase<UInt8x2>.TryConvertToChecked<TOther>(
            UInt8x2 value,
            out TOther result) =>
            throw new NotSupportedException();
        static bool INumberBase<UInt8x2>.TryConvertToSaturating<TOther>(
            UInt8x2 value,
            out TOther result) =>
            throw new NotSupportedException();
        static bool INumberBase<UInt8x2>.TryConvertToTruncating<TOther>(
            UInt8x2 value,
            out TOther result) =>
            throw new NotSupportedException();
    }

    /// <summary>
    /// Represents a vectorized byte type with length 4.
    /// </summary>
    [CLSCompliant(false)]
    public readonly record struct UInt8x4(
        byte X, byte Y, byte Z, byte W) :
        IVectorType<UInt8x4, byte>
    {
        /// <summary>
        /// The offset of the X field in bytes.
        /// </summary>
        public static readonly int OffsetX =
            sizeof(byte) * 0;

        /// <summary>
        /// The offset of the X field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrX =>
            new UIntPtr((uint)OffsetX);
        /// <summary>
        /// The offset of the Y field in bytes.
        /// </summary>
        public static readonly int OffsetY =
            sizeof(byte) * 1;

        /// <summary>
        /// The offset of the Y field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrY =>
            new UIntPtr((uint)OffsetY);
        /// <summary>
        /// The offset of the Z field in bytes.
        /// </summary>
        public static readonly int OffsetZ =
            sizeof(byte) * 2;

        /// <summary>
        /// The offset of the Z field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrZ =>
            new UIntPtr((uint)OffsetZ);
        /// <summary>
        /// The offset of the W field in bytes.
        /// </summary>
        public static readonly int OffsetW =
            sizeof(byte) * 3;

        /// <summary>
        /// The offset of the W field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrW =>
            new UIntPtr((uint)OffsetW);

        /// <summary>
        /// Returns the length of this vector which is 4.
        /// </summary>
        public static int Length => 4;

        /// <summary>
        /// Returns the radix of the underlying value.
        /// </summary>
        public static int Radix => 10;

        /// <summary>
        /// Returns an invalid value (min [signed types], max value [unsigned] or NaN).
        /// </summary>
        public static UInt8x4 Invalid => FromScalar(
            byte.MaxValue
        );

        /// <summary>
        /// Returns the value zero.
        /// </summary>
        public static UInt8x4 Zero => new();

        /// <summary>
        /// Returns the value one.
        /// </summary>
        public static UInt8x4 One => FromScalar((1));

        /// <summary>
        /// Returns the value zero.
        /// </summary>
        public static UInt8x4 AdditiveIdentity => Zero;

        /// <summary>
        /// Returns the value one.
        /// </summary>
        public static UInt8x4 MultiplicativeIdentity => One;

        /// <summary>
        /// Computes the min value of both.
        /// </summary>
        /// <param name="first">The first value.</param>
        /// <param name="second">The second value.</param>
        /// <returns>The min value.</returns>
        public static UInt8x4 Min(
            UInt8x4 first,
            UInt8x4 second) =>
            new UInt8x4((byte)Math.Min(first.X, second.X), (byte)Math.Min(first.Y, second.Y), (byte)Math.Min(first.Z, second.Z), (byte)Math.Min(first.W, second.W));

        /// <summary>
        /// Computes the max value of both.
        /// </summary>
        /// <param name="first">The first value.</param>
        /// <param name="second">The second value.</param>
        /// <returns>The max value.</returns>
        public static UInt8x4 Max(
            UInt8x4 first,
            UInt8x4 second) =>
            new UInt8x4((byte)Math.Max(first.X, second.X), (byte)Math.Max(first.Y, second.Y), (byte)Math.Max(first.Z, second.Z), (byte)Math.Max(first.W, second.W));

        /// <summary>
        /// Clamps the given value.
        /// </summary>
        /// <param name="value">The value to clamp.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The clamped value.</returns>
        public static UInt8x4 Clamp(
            UInt8x4 value,
            UInt8x4 min,
            UInt8x4 max) =>
            Max(Min(value, max), min);

        /// <summary>
        /// Creates a random scalar instance falling into the range of min max.
        /// </summary>
        /// <param name="random">The random provider to use.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The created random scalar instance.</returns>
        public static byte GetRandomScalar<TRandom>(
            ref TRandom random,
            byte min,
            byte max)
            where TRandom : struct, IRandomProvider =>
            (byte)RandomExtensions.
                Next(ref random, min, max);

        /// <summary>
        /// Creates a random vector instance falling into the range of min max.
        /// </summary>
        /// <param name="random">The random provider to use.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The created random vector instance.</returns>
        public static UInt8x4 GetRandom<TRandom>(
            ref TRandom random,
            UInt8x4 min,
            UInt8x4 max)
            where TRandom : struct, IRandomProvider
        {
            byte x = GetRandomScalar(
                ref random, min.X, max.X);
            byte y = GetRandomScalar(
                ref random, min.Y, max.Y);
            byte z = GetRandomScalar(
                ref random, min.Z, max.Z);
            byte w = GetRandomScalar(
                ref random, min.W, max.W);
            return new UInt8x4(x, y, z, w);
        }

        /// <summary>
        /// Creates a vector instance from the given source view.
        /// </summary>
        /// <typeparam name="TStride">The custom stride type.</typeparam>
        /// <param name="sourceView">The source view.</param>
        /// <param name="index">The source base index.</param>
        /// <returns>The vector instance.</returns>
        public static UInt8x4 FromElementView<TStride>(
            ArrayView1D<byte, TStride> sourceView,
            Index1D index)
            where TStride : struct, IStride1D =>
            new UInt8x4(
                sourceView[index + 0],
                sourceView[index + 1],
                sourceView[index + 2],
                sourceView[index + 3]
                );

        /// <summary>
        /// Serializes the current vector instance into the given target view.
        /// </summary>
        /// <typeparam name="TStride">The custom stride type.</typeparam>
        /// <param name="targetView">The target view.</param>
        /// <param name="index">The target base index.</param>
        public void ToElementView<TStride>(
            ArrayView1D<byte, TStride> targetView,
            Index1D index)
            where TStride : struct, IStride1D
        {
            targetView[index + 0] = X;
            targetView[index + 1] = Y;
            targetView[index + 2] = Z;
            targetView[index + 3] = W;
        }

        /// <summary>
        /// Creates a vector instance from the given source view.
        /// </summary>
        /// <param name="sourceView">The source view.</param>
        /// <param name="index">The source base index.</param>
        /// <returns>The vector instance.</returns>
        public static UInt8x4 FromElementView(
            SingleVectorView<byte> sourceView,
            Index1D index) =>
            new UInt8x4(
                sourceView[index + 0],
                sourceView[index + 1],
                sourceView[index + 2],
                sourceView[index + 3]
                );

        /// <summary>
        /// Serializes the current vector instance into the given target view.
        /// </summary>
        /// <param name="targetView">The target view.</param>
        /// <param name="index">The target base index.</param>
        public void ToElementView(
            SingleVectorView<byte> targetView,
            Index1D index)
        {
            targetView[index + 0] = X;
            targetView[index + 1] = Y;
            targetView[index + 2] = Z;
            targetView[index + 3] = W;
        }

        /// <summary>
        /// Converts a scalar value into the current vectorized type.
        /// </summary>
        /// <param name="scalar">The scalar element type.</param>
        /// <returns>The created vectorized type.</returns>
        public static UInt8x4 FromScalar(byte scalar) =>
            new UInt8x4(scalar, scalar, scalar, scalar);

        /// <summary>
        /// Converts this instance into an unsafe span instance.
        /// </summary>
        /// <returns>The readonly span instance.</returns>
        public unsafe ReadOnlySpan<byte> AsSpan() =>
            new(Unsafe.AsPointer(ref Unsafe.AsRef(this)), 4);

        /// <summary>
        /// Iterates over all elements by applying the given iterator to each element.
        /// </summary>
        /// <typeparam name="TIterator">The managed iterator type.</typeparam>
        /// <param name="iterator">The iterator to invoke.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ForEach<TIterator>(ref TIterator iterator)
            where TIterator : struct, IVectorElementIterator<
            UInt8x4,
            byte>
        {
            iterator.Iterate(X, 0);
            iterator.Iterate(Y, 1);
            iterator.Iterate(Z, 2);
            iterator.Iterate(W, 3);
        }

        /// <summary>
        /// Converts this vector instance to a string.
        /// </summary>
        public override string ToString() =>
            $"{X}, {Y}, {Z}, {W}";

        /// <summary>
        /// Converts this vector instance to a string.
        /// </summary>
        public string ToString(string? format, IFormatProvider? formatProvider) =>
            $"{X.ToString(format, formatProvider)}, {Y.ToString(format, formatProvider)}, {Z.ToString(format, formatProvider)}, {W.ToString(format, formatProvider)}";

        /// <summary>
        /// Returns true.
        /// </summary>
        public static bool IsCanonical(UInt8x4 value) => true;

        /// <summary>
        /// Returns false.
        /// </summary>
        public static bool IsComplexNumber(UInt8x4 value) => false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsEvenInteger(UInt8x4 value) =>
            byte.IsEvenInteger(value.X) & byte.IsEvenInteger(value.Y) & byte.IsEvenInteger(value.Z) & byte.IsEvenInteger(value.W);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsFinite(UInt8x4 value) =>
            true;

        /// <summary>
        /// Returns false.
        /// </summary>
        public static bool IsImaginaryNumber(UInt8x4 value) => false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsInfinity(UInt8x4 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsInteger(UInt8x4 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNaN(UInt8x4 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNegative(UInt8x4 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNegativeInfinity(UInt8x4 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNormal(UInt8x4 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsOddInteger(UInt8x4 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsPositive(UInt8x4 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsPositiveInfinity(UInt8x4 value) =>
            false;

        /// <summary>
        /// Returns true.
        /// </summary>
        public static bool IsRealNumber(UInt8x4 value) => true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsSubnormal(UInt8x4 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsZero(UInt8x4 value) =>
            value == Zero;

        /// <summary>
        /// Returns the absolute value.
        /// </summary>
        public static UInt8x4 Abs(UInt8x4 value) =>
            value;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt8x4 operator +(UInt8x4 left, UInt8x4 right) =>
            new UInt8x4((byte)(left.X + right.X), (byte)(left.Y + right.Y), (byte)(left.Z + right.Z), (byte)(left.W + right.W));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt8x4 operator --(UInt8x4 value) => value - One;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt8x4 operator /(UInt8x4 left, UInt8x4 right) =>
            new UInt8x4((byte)(left.X / right.X), (byte)(left.Y / right.Y), (byte)(left.Z / right.Z), (byte)(left.W / right.W));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt8x4 operator ++(UInt8x4 value) => value + One;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt8x4 operator *(UInt8x4 left, UInt8x4 right) =>
            new UInt8x4((byte)(left.X * right.X), (byte)(left.Y * right.Y), (byte)(left.Z * right.Z), (byte)(left.W * right.W));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt8x4 operator -(UInt8x4 left, UInt8x4 right) =>
            new UInt8x4((byte)(left.X - right.X), (byte)(left.Y - right.Y), (byte)(left.Z - right.Z), (byte)(left.W - right.W));

        /// <summary>
        /// Not supported operation.
        /// </summary>
        static UInt8x4 IUnaryNegationOperators<UInt8x4, UInt8x4>.
            operator -(UInt8x4 value) => value;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt8x4 operator +(UInt8x4 value) => value;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt8x4 MaxMagnitude(UInt8x4 x, UInt8x4 y) =>
            Max(x, y);

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt8x4 MaxMagnitudeNumber(UInt8x4 x, UInt8x4 y) =>
            MaxMagnitude(x, y);

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt8x4 MinMagnitude(UInt8x4 x, UInt8x4 y) =>
            Min(x, y);

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt8x4 MinMagnitudeNumber(UInt8x4 x, UInt8x4 y) =>
            MinMagnitude(x, y);

        // Not supported operations

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static UInt8x4 IParsable<UInt8x4>.Parse(
            string s,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static UInt8x4 ISpanParsable<UInt8x4>.Parse(
            ReadOnlySpan<char> s,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static UInt8x4 INumberBase<UInt8x4>.Parse(
            ReadOnlySpan<char> s,
            NumberStyles style,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static UInt8x4 INumberBase<UInt8x4>.Parse(
            string s,
            NumberStyles style,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        bool ISpanFormattable.TryFormat(
            Span<char> destination,
            out int charsWritten,
            ReadOnlySpan<char> format,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool IParsable<UInt8x4>.TryParse(
            string? s,
            IFormatProvider? provider,
            out UInt8x4 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given span into a vectorized instance.
        /// </summary>
        static bool ISpanParsable<UInt8x4>.TryParse(
            ReadOnlySpan<char> s,
            IFormatProvider? provider,
            out UInt8x4 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool INumberBase<UInt8x4>.TryParse(
            ReadOnlySpan<char> s,
            NumberStyles style,
            IFormatProvider? provider,
            out UInt8x4 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool INumberBase<UInt8x4>.TryParse(
            string? s,
            NumberStyles style,
            IFormatProvider? provider,
            out UInt8x4 result) =>
            throw new NotSupportedException();

        static bool INumberBase<UInt8x4>.TryConvertFromChecked<TOther>(
            TOther value,
            out UInt8x4 result) =>
            throw new NotSupportedException();
        static bool INumberBase<UInt8x4>.TryConvertFromSaturating<TOther>(
            TOther value,
            out UInt8x4 result) =>
            throw new NotSupportedException();
        static bool INumberBase<UInt8x4>.TryConvertFromTruncating<TOther>(
            TOther value,
            out UInt8x4 result) =>
            throw new NotSupportedException();
        static bool INumberBase<UInt8x4>.TryConvertToChecked<TOther>(
            UInt8x4 value,
            out TOther result) =>
            throw new NotSupportedException();
        static bool INumberBase<UInt8x4>.TryConvertToSaturating<TOther>(
            UInt8x4 value,
            out TOther result) =>
            throw new NotSupportedException();
        static bool INumberBase<UInt8x4>.TryConvertToTruncating<TOther>(
            UInt8x4 value,
            out TOther result) =>
            throw new NotSupportedException();
    }

    /// <summary>
    /// Represents a vectorized byte type with length 8.
    /// </summary>
    [CLSCompliant(false)]
    public readonly record struct UInt8x8(
        byte X, byte Y, byte Z, byte W, byte I, byte J, byte K, byte L) :
        IVectorType<UInt8x8, byte>
    {
        /// <summary>
        /// The offset of the X field in bytes.
        /// </summary>
        public static readonly int OffsetX =
            sizeof(byte) * 0;

        /// <summary>
        /// The offset of the X field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrX =>
            new UIntPtr((uint)OffsetX);
        /// <summary>
        /// The offset of the Y field in bytes.
        /// </summary>
        public static readonly int OffsetY =
            sizeof(byte) * 1;

        /// <summary>
        /// The offset of the Y field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrY =>
            new UIntPtr((uint)OffsetY);
        /// <summary>
        /// The offset of the Z field in bytes.
        /// </summary>
        public static readonly int OffsetZ =
            sizeof(byte) * 2;

        /// <summary>
        /// The offset of the Z field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrZ =>
            new UIntPtr((uint)OffsetZ);
        /// <summary>
        /// The offset of the W field in bytes.
        /// </summary>
        public static readonly int OffsetW =
            sizeof(byte) * 3;

        /// <summary>
        /// The offset of the W field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrW =>
            new UIntPtr((uint)OffsetW);
        /// <summary>
        /// The offset of the I field in bytes.
        /// </summary>
        public static readonly int OffsetI =
            sizeof(byte) * 4;

        /// <summary>
        /// The offset of the I field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrI =>
            new UIntPtr((uint)OffsetI);
        /// <summary>
        /// The offset of the J field in bytes.
        /// </summary>
        public static readonly int OffsetJ =
            sizeof(byte) * 5;

        /// <summary>
        /// The offset of the J field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrJ =>
            new UIntPtr((uint)OffsetJ);
        /// <summary>
        /// The offset of the K field in bytes.
        /// </summary>
        public static readonly int OffsetK =
            sizeof(byte) * 6;

        /// <summary>
        /// The offset of the K field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrK =>
            new UIntPtr((uint)OffsetK);
        /// <summary>
        /// The offset of the L field in bytes.
        /// </summary>
        public static readonly int OffsetL =
            sizeof(byte) * 7;

        /// <summary>
        /// The offset of the L field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrL =>
            new UIntPtr((uint)OffsetL);

        /// <summary>
        /// Returns the length of this vector which is 8.
        /// </summary>
        public static int Length => 8;

        /// <summary>
        /// Returns the radix of the underlying value.
        /// </summary>
        public static int Radix => 10;

        /// <summary>
        /// Returns an invalid value (min [signed types], max value [unsigned] or NaN).
        /// </summary>
        public static UInt8x8 Invalid => FromScalar(
            byte.MaxValue
        );

        /// <summary>
        /// Returns the value zero.
        /// </summary>
        public static UInt8x8 Zero => new();

        /// <summary>
        /// Returns the value one.
        /// </summary>
        public static UInt8x8 One => FromScalar((1));

        /// <summary>
        /// Returns the value zero.
        /// </summary>
        public static UInt8x8 AdditiveIdentity => Zero;

        /// <summary>
        /// Returns the value one.
        /// </summary>
        public static UInt8x8 MultiplicativeIdentity => One;

        /// <summary>
        /// Computes the min value of both.
        /// </summary>
        /// <param name="first">The first value.</param>
        /// <param name="second">The second value.</param>
        /// <returns>The min value.</returns>
        public static UInt8x8 Min(
            UInt8x8 first,
            UInt8x8 second) =>
            new UInt8x8((byte)Math.Min(first.X, second.X), (byte)Math.Min(first.Y, second.Y), (byte)Math.Min(first.Z, second.Z), (byte)Math.Min(first.W, second.W), (byte)Math.Min(first.I, second.I), (byte)Math.Min(first.J, second.J), (byte)Math.Min(first.K, second.K), (byte)Math.Min(first.L, second.L));

        /// <summary>
        /// Computes the max value of both.
        /// </summary>
        /// <param name="first">The first value.</param>
        /// <param name="second">The second value.</param>
        /// <returns>The max value.</returns>
        public static UInt8x8 Max(
            UInt8x8 first,
            UInt8x8 second) =>
            new UInt8x8((byte)Math.Max(first.X, second.X), (byte)Math.Max(first.Y, second.Y), (byte)Math.Max(first.Z, second.Z), (byte)Math.Max(first.W, second.W), (byte)Math.Max(first.I, second.I), (byte)Math.Max(first.J, second.J), (byte)Math.Max(first.K, second.K), (byte)Math.Max(first.L, second.L));

        /// <summary>
        /// Clamps the given value.
        /// </summary>
        /// <param name="value">The value to clamp.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The clamped value.</returns>
        public static UInt8x8 Clamp(
            UInt8x8 value,
            UInt8x8 min,
            UInt8x8 max) =>
            Max(Min(value, max), min);

        /// <summary>
        /// Creates a random scalar instance falling into the range of min max.
        /// </summary>
        /// <param name="random">The random provider to use.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The created random scalar instance.</returns>
        public static byte GetRandomScalar<TRandom>(
            ref TRandom random,
            byte min,
            byte max)
            where TRandom : struct, IRandomProvider =>
            (byte)RandomExtensions.
                Next(ref random, min, max);

        /// <summary>
        /// Creates a random vector instance falling into the range of min max.
        /// </summary>
        /// <param name="random">The random provider to use.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The created random vector instance.</returns>
        public static UInt8x8 GetRandom<TRandom>(
            ref TRandom random,
            UInt8x8 min,
            UInt8x8 max)
            where TRandom : struct, IRandomProvider
        {
            byte x = GetRandomScalar(
                ref random, min.X, max.X);
            byte y = GetRandomScalar(
                ref random, min.Y, max.Y);
            byte z = GetRandomScalar(
                ref random, min.Z, max.Z);
            byte w = GetRandomScalar(
                ref random, min.W, max.W);
            byte i = GetRandomScalar(
                ref random, min.I, max.I);
            byte j = GetRandomScalar(
                ref random, min.J, max.J);
            byte k = GetRandomScalar(
                ref random, min.K, max.K);
            byte l = GetRandomScalar(
                ref random, min.L, max.L);
            return new UInt8x8(x, y, z, w, i, j, k, l);
        }

        /// <summary>
        /// Creates a vector instance from the given source view.
        /// </summary>
        /// <typeparam name="TStride">The custom stride type.</typeparam>
        /// <param name="sourceView">The source view.</param>
        /// <param name="index">The source base index.</param>
        /// <returns>The vector instance.</returns>
        public static UInt8x8 FromElementView<TStride>(
            ArrayView1D<byte, TStride> sourceView,
            Index1D index)
            where TStride : struct, IStride1D =>
            new UInt8x8(
                sourceView[index + 0],
                sourceView[index + 1],
                sourceView[index + 2],
                sourceView[index + 3],
                sourceView[index + 4],
                sourceView[index + 5],
                sourceView[index + 6],
                sourceView[index + 7]
                );

        /// <summary>
        /// Serializes the current vector instance into the given target view.
        /// </summary>
        /// <typeparam name="TStride">The custom stride type.</typeparam>
        /// <param name="targetView">The target view.</param>
        /// <param name="index">The target base index.</param>
        public void ToElementView<TStride>(
            ArrayView1D<byte, TStride> targetView,
            Index1D index)
            where TStride : struct, IStride1D
        {
            targetView[index + 0] = X;
            targetView[index + 1] = Y;
            targetView[index + 2] = Z;
            targetView[index + 3] = W;
            targetView[index + 4] = I;
            targetView[index + 5] = J;
            targetView[index + 6] = K;
            targetView[index + 7] = L;
        }

        /// <summary>
        /// Creates a vector instance from the given source view.
        /// </summary>
        /// <param name="sourceView">The source view.</param>
        /// <param name="index">The source base index.</param>
        /// <returns>The vector instance.</returns>
        public static UInt8x8 FromElementView(
            SingleVectorView<byte> sourceView,
            Index1D index) =>
            new UInt8x8(
                sourceView[index + 0],
                sourceView[index + 1],
                sourceView[index + 2],
                sourceView[index + 3],
                sourceView[index + 4],
                sourceView[index + 5],
                sourceView[index + 6],
                sourceView[index + 7]
                );

        /// <summary>
        /// Serializes the current vector instance into the given target view.
        /// </summary>
        /// <param name="targetView">The target view.</param>
        /// <param name="index">The target base index.</param>
        public void ToElementView(
            SingleVectorView<byte> targetView,
            Index1D index)
        {
            targetView[index + 0] = X;
            targetView[index + 1] = Y;
            targetView[index + 2] = Z;
            targetView[index + 3] = W;
            targetView[index + 4] = I;
            targetView[index + 5] = J;
            targetView[index + 6] = K;
            targetView[index + 7] = L;
        }

        /// <summary>
        /// Converts a scalar value into the current vectorized type.
        /// </summary>
        /// <param name="scalar">The scalar element type.</param>
        /// <returns>The created vectorized type.</returns>
        public static UInt8x8 FromScalar(byte scalar) =>
            new UInt8x8(scalar, scalar, scalar, scalar, scalar, scalar, scalar, scalar);

        /// <summary>
        /// Converts this instance into an unsafe span instance.
        /// </summary>
        /// <returns>The readonly span instance.</returns>
        public unsafe ReadOnlySpan<byte> AsSpan() =>
            new(Unsafe.AsPointer(ref Unsafe.AsRef(this)), 8);

        /// <summary>
        /// Iterates over all elements by applying the given iterator to each element.
        /// </summary>
        /// <typeparam name="TIterator">The managed iterator type.</typeparam>
        /// <param name="iterator">The iterator to invoke.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ForEach<TIterator>(ref TIterator iterator)
            where TIterator : struct, IVectorElementIterator<
            UInt8x8,
            byte>
        {
            iterator.Iterate(X, 0);
            iterator.Iterate(Y, 1);
            iterator.Iterate(Z, 2);
            iterator.Iterate(W, 3);
            iterator.Iterate(I, 4);
            iterator.Iterate(J, 5);
            iterator.Iterate(K, 6);
            iterator.Iterate(L, 7);
        }

        /// <summary>
        /// Converts this vector instance to a string.
        /// </summary>
        public override string ToString() =>
            $"{X}, {Y}, {Z}, {W}, {I}, {J}, {K}, {L}";

        /// <summary>
        /// Converts this vector instance to a string.
        /// </summary>
        public string ToString(string? format, IFormatProvider? formatProvider) =>
            $"{X.ToString(format, formatProvider)}, {Y.ToString(format, formatProvider)}, {Z.ToString(format, formatProvider)}, {W.ToString(format, formatProvider)}, {I.ToString(format, formatProvider)}, {J.ToString(format, formatProvider)}, {K.ToString(format, formatProvider)}, {L.ToString(format, formatProvider)}";

        /// <summary>
        /// Returns true.
        /// </summary>
        public static bool IsCanonical(UInt8x8 value) => true;

        /// <summary>
        /// Returns false.
        /// </summary>
        public static bool IsComplexNumber(UInt8x8 value) => false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsEvenInteger(UInt8x8 value) =>
            byte.IsEvenInteger(value.X) & byte.IsEvenInteger(value.Y) & byte.IsEvenInteger(value.Z) & byte.IsEvenInteger(value.W) & byte.IsEvenInteger(value.I) & byte.IsEvenInteger(value.J) & byte.IsEvenInteger(value.K) & byte.IsEvenInteger(value.L);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsFinite(UInt8x8 value) =>
            true;

        /// <summary>
        /// Returns false.
        /// </summary>
        public static bool IsImaginaryNumber(UInt8x8 value) => false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsInfinity(UInt8x8 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsInteger(UInt8x8 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNaN(UInt8x8 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNegative(UInt8x8 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNegativeInfinity(UInt8x8 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNormal(UInt8x8 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsOddInteger(UInt8x8 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsPositive(UInt8x8 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsPositiveInfinity(UInt8x8 value) =>
            false;

        /// <summary>
        /// Returns true.
        /// </summary>
        public static bool IsRealNumber(UInt8x8 value) => true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsSubnormal(UInt8x8 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsZero(UInt8x8 value) =>
            value == Zero;

        /// <summary>
        /// Returns the absolute value.
        /// </summary>
        public static UInt8x8 Abs(UInt8x8 value) =>
            value;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt8x8 operator +(UInt8x8 left, UInt8x8 right) =>
            new UInt8x8((byte)(left.X + right.X), (byte)(left.Y + right.Y), (byte)(left.Z + right.Z), (byte)(left.W + right.W), (byte)(left.I + right.I), (byte)(left.J + right.J), (byte)(left.K + right.K), (byte)(left.L + right.L));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt8x8 operator --(UInt8x8 value) => value - One;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt8x8 operator /(UInt8x8 left, UInt8x8 right) =>
            new UInt8x8((byte)(left.X / right.X), (byte)(left.Y / right.Y), (byte)(left.Z / right.Z), (byte)(left.W / right.W), (byte)(left.I / right.I), (byte)(left.J / right.J), (byte)(left.K / right.K), (byte)(left.L / right.L));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt8x8 operator ++(UInt8x8 value) => value + One;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt8x8 operator *(UInt8x8 left, UInt8x8 right) =>
            new UInt8x8((byte)(left.X * right.X), (byte)(left.Y * right.Y), (byte)(left.Z * right.Z), (byte)(left.W * right.W), (byte)(left.I * right.I), (byte)(left.J * right.J), (byte)(left.K * right.K), (byte)(left.L * right.L));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt8x8 operator -(UInt8x8 left, UInt8x8 right) =>
            new UInt8x8((byte)(left.X - right.X), (byte)(left.Y - right.Y), (byte)(left.Z - right.Z), (byte)(left.W - right.W), (byte)(left.I - right.I), (byte)(left.J - right.J), (byte)(left.K - right.K), (byte)(left.L - right.L));

        /// <summary>
        /// Not supported operation.
        /// </summary>
        static UInt8x8 IUnaryNegationOperators<UInt8x8, UInt8x8>.
            operator -(UInt8x8 value) => value;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt8x8 operator +(UInt8x8 value) => value;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt8x8 MaxMagnitude(UInt8x8 x, UInt8x8 y) =>
            Max(x, y);

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt8x8 MaxMagnitudeNumber(UInt8x8 x, UInt8x8 y) =>
            MaxMagnitude(x, y);

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt8x8 MinMagnitude(UInt8x8 x, UInt8x8 y) =>
            Min(x, y);

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt8x8 MinMagnitudeNumber(UInt8x8 x, UInt8x8 y) =>
            MinMagnitude(x, y);

        // Not supported operations

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static UInt8x8 IParsable<UInt8x8>.Parse(
            string s,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static UInt8x8 ISpanParsable<UInt8x8>.Parse(
            ReadOnlySpan<char> s,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static UInt8x8 INumberBase<UInt8x8>.Parse(
            ReadOnlySpan<char> s,
            NumberStyles style,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static UInt8x8 INumberBase<UInt8x8>.Parse(
            string s,
            NumberStyles style,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        bool ISpanFormattable.TryFormat(
            Span<char> destination,
            out int charsWritten,
            ReadOnlySpan<char> format,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool IParsable<UInt8x8>.TryParse(
            string? s,
            IFormatProvider? provider,
            out UInt8x8 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given span into a vectorized instance.
        /// </summary>
        static bool ISpanParsable<UInt8x8>.TryParse(
            ReadOnlySpan<char> s,
            IFormatProvider? provider,
            out UInt8x8 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool INumberBase<UInt8x8>.TryParse(
            ReadOnlySpan<char> s,
            NumberStyles style,
            IFormatProvider? provider,
            out UInt8x8 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool INumberBase<UInt8x8>.TryParse(
            string? s,
            NumberStyles style,
            IFormatProvider? provider,
            out UInt8x8 result) =>
            throw new NotSupportedException();

        static bool INumberBase<UInt8x8>.TryConvertFromChecked<TOther>(
            TOther value,
            out UInt8x8 result) =>
            throw new NotSupportedException();
        static bool INumberBase<UInt8x8>.TryConvertFromSaturating<TOther>(
            TOther value,
            out UInt8x8 result) =>
            throw new NotSupportedException();
        static bool INumberBase<UInt8x8>.TryConvertFromTruncating<TOther>(
            TOther value,
            out UInt8x8 result) =>
            throw new NotSupportedException();
        static bool INumberBase<UInt8x8>.TryConvertToChecked<TOther>(
            UInt8x8 value,
            out TOther result) =>
            throw new NotSupportedException();
        static bool INumberBase<UInt8x8>.TryConvertToSaturating<TOther>(
            UInt8x8 value,
            out TOther result) =>
            throw new NotSupportedException();
        static bool INumberBase<UInt8x8>.TryConvertToTruncating<TOther>(
            UInt8x8 value,
            out TOther result) =>
            throw new NotSupportedException();
    }

    /// <summary>
    /// Represents a vectorized ushort type with length 2.
    /// </summary>
    [CLSCompliant(false)]
    public readonly record struct UInt16x2(
        ushort X, ushort Y) :
        IVectorType<UInt16x2, ushort>
    {
        /// <summary>
        /// The offset of the X field in bytes.
        /// </summary>
        public static readonly int OffsetX =
            sizeof(ushort) * 0;

        /// <summary>
        /// The offset of the X field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrX =>
            new UIntPtr((uint)OffsetX);
        /// <summary>
        /// The offset of the Y field in bytes.
        /// </summary>
        public static readonly int OffsetY =
            sizeof(ushort) * 1;

        /// <summary>
        /// The offset of the Y field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrY =>
            new UIntPtr((uint)OffsetY);

        /// <summary>
        /// Returns the length of this vector which is 2.
        /// </summary>
        public static int Length => 2;

        /// <summary>
        /// Returns the radix of the underlying value.
        /// </summary>
        public static int Radix => 10;

        /// <summary>
        /// Returns an invalid value (min [signed types], max value [unsigned] or NaN).
        /// </summary>
        public static UInt16x2 Invalid => FromScalar(
            ushort.MaxValue
        );

        /// <summary>
        /// Returns the value zero.
        /// </summary>
        public static UInt16x2 Zero => new();

        /// <summary>
        /// Returns the value one.
        /// </summary>
        public static UInt16x2 One => FromScalar((1));

        /// <summary>
        /// Returns the value zero.
        /// </summary>
        public static UInt16x2 AdditiveIdentity => Zero;

        /// <summary>
        /// Returns the value one.
        /// </summary>
        public static UInt16x2 MultiplicativeIdentity => One;

        /// <summary>
        /// Computes the min value of both.
        /// </summary>
        /// <param name="first">The first value.</param>
        /// <param name="second">The second value.</param>
        /// <returns>The min value.</returns>
        public static UInt16x2 Min(
            UInt16x2 first,
            UInt16x2 second) =>
            new UInt16x2((ushort)Math.Min(first.X, second.X), (ushort)Math.Min(first.Y, second.Y));

        /// <summary>
        /// Computes the max value of both.
        /// </summary>
        /// <param name="first">The first value.</param>
        /// <param name="second">The second value.</param>
        /// <returns>The max value.</returns>
        public static UInt16x2 Max(
            UInt16x2 first,
            UInt16x2 second) =>
            new UInt16x2((ushort)Math.Max(first.X, second.X), (ushort)Math.Max(first.Y, second.Y));

        /// <summary>
        /// Clamps the given value.
        /// </summary>
        /// <param name="value">The value to clamp.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The clamped value.</returns>
        public static UInt16x2 Clamp(
            UInt16x2 value,
            UInt16x2 min,
            UInt16x2 max) =>
            Max(Min(value, max), min);

        /// <summary>
        /// Creates a random scalar instance falling into the range of min max.
        /// </summary>
        /// <param name="random">The random provider to use.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The created random scalar instance.</returns>
        public static ushort GetRandomScalar<TRandom>(
            ref TRandom random,
            ushort min,
            ushort max)
            where TRandom : struct, IRandomProvider =>
            (ushort)RandomExtensions.
                Next(ref random, min, max);

        /// <summary>
        /// Creates a random vector instance falling into the range of min max.
        /// </summary>
        /// <param name="random">The random provider to use.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The created random vector instance.</returns>
        public static UInt16x2 GetRandom<TRandom>(
            ref TRandom random,
            UInt16x2 min,
            UInt16x2 max)
            where TRandom : struct, IRandomProvider
        {
            ushort x = GetRandomScalar(
                ref random, min.X, max.X);
            ushort y = GetRandomScalar(
                ref random, min.Y, max.Y);
            return new UInt16x2(x, y);
        }

        /// <summary>
        /// Creates a vector instance from the given source view.
        /// </summary>
        /// <typeparam name="TStride">The custom stride type.</typeparam>
        /// <param name="sourceView">The source view.</param>
        /// <param name="index">The source base index.</param>
        /// <returns>The vector instance.</returns>
        public static UInt16x2 FromElementView<TStride>(
            ArrayView1D<ushort, TStride> sourceView,
            Index1D index)
            where TStride : struct, IStride1D =>
            new UInt16x2(
                sourceView[index + 0],
                sourceView[index + 1]
                );

        /// <summary>
        /// Serializes the current vector instance into the given target view.
        /// </summary>
        /// <typeparam name="TStride">The custom stride type.</typeparam>
        /// <param name="targetView">The target view.</param>
        /// <param name="index">The target base index.</param>
        public void ToElementView<TStride>(
            ArrayView1D<ushort, TStride> targetView,
            Index1D index)
            where TStride : struct, IStride1D
        {
            targetView[index + 0] = X;
            targetView[index + 1] = Y;
        }

        /// <summary>
        /// Creates a vector instance from the given source view.
        /// </summary>
        /// <param name="sourceView">The source view.</param>
        /// <param name="index">The source base index.</param>
        /// <returns>The vector instance.</returns>
        public static UInt16x2 FromElementView(
            SingleVectorView<ushort> sourceView,
            Index1D index) =>
            new UInt16x2(
                sourceView[index + 0],
                sourceView[index + 1]
                );

        /// <summary>
        /// Serializes the current vector instance into the given target view.
        /// </summary>
        /// <param name="targetView">The target view.</param>
        /// <param name="index">The target base index.</param>
        public void ToElementView(
            SingleVectorView<ushort> targetView,
            Index1D index)
        {
            targetView[index + 0] = X;
            targetView[index + 1] = Y;
        }

        /// <summary>
        /// Converts a scalar value into the current vectorized type.
        /// </summary>
        /// <param name="scalar">The scalar element type.</param>
        /// <returns>The created vectorized type.</returns>
        public static UInt16x2 FromScalar(ushort scalar) =>
            new UInt16x2(scalar, scalar);

        /// <summary>
        /// Converts this instance into an unsafe span instance.
        /// </summary>
        /// <returns>The readonly span instance.</returns>
        public unsafe ReadOnlySpan<ushort> AsSpan() =>
            new(Unsafe.AsPointer(ref Unsafe.AsRef(this)), 2);

        /// <summary>
        /// Iterates over all elements by applying the given iterator to each element.
        /// </summary>
        /// <typeparam name="TIterator">The managed iterator type.</typeparam>
        /// <param name="iterator">The iterator to invoke.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ForEach<TIterator>(ref TIterator iterator)
            where TIterator : struct, IVectorElementIterator<
            UInt16x2,
            ushort>
        {
            iterator.Iterate(X, 0);
            iterator.Iterate(Y, 1);
        }

        /// <summary>
        /// Converts this vector instance to a string.
        /// </summary>
        public override string ToString() =>
            $"{X}, {Y}";

        /// <summary>
        /// Converts this vector instance to a string.
        /// </summary>
        public string ToString(string? format, IFormatProvider? formatProvider) =>
            $"{X.ToString(format, formatProvider)}, {Y.ToString(format, formatProvider)}";

        /// <summary>
        /// Returns true.
        /// </summary>
        public static bool IsCanonical(UInt16x2 value) => true;

        /// <summary>
        /// Returns false.
        /// </summary>
        public static bool IsComplexNumber(UInt16x2 value) => false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsEvenInteger(UInt16x2 value) =>
            ushort.IsEvenInteger(value.X) & ushort.IsEvenInteger(value.Y);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsFinite(UInt16x2 value) =>
            true;

        /// <summary>
        /// Returns false.
        /// </summary>
        public static bool IsImaginaryNumber(UInt16x2 value) => false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsInfinity(UInt16x2 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsInteger(UInt16x2 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNaN(UInt16x2 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNegative(UInt16x2 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNegativeInfinity(UInt16x2 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNormal(UInt16x2 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsOddInteger(UInt16x2 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsPositive(UInt16x2 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsPositiveInfinity(UInt16x2 value) =>
            false;

        /// <summary>
        /// Returns true.
        /// </summary>
        public static bool IsRealNumber(UInt16x2 value) => true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsSubnormal(UInt16x2 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsZero(UInt16x2 value) =>
            value == Zero;

        /// <summary>
        /// Returns the absolute value.
        /// </summary>
        public static UInt16x2 Abs(UInt16x2 value) =>
            value;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt16x2 operator +(UInt16x2 left, UInt16x2 right) =>
            new UInt16x2((ushort)(left.X + right.X), (ushort)(left.Y + right.Y));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt16x2 operator --(UInt16x2 value) => value - One;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt16x2 operator /(UInt16x2 left, UInt16x2 right) =>
            new UInt16x2((ushort)(left.X / right.X), (ushort)(left.Y / right.Y));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt16x2 operator ++(UInt16x2 value) => value + One;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt16x2 operator *(UInt16x2 left, UInt16x2 right) =>
            new UInt16x2((ushort)(left.X * right.X), (ushort)(left.Y * right.Y));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt16x2 operator -(UInt16x2 left, UInt16x2 right) =>
            new UInt16x2((ushort)(left.X - right.X), (ushort)(left.Y - right.Y));

        /// <summary>
        /// Not supported operation.
        /// </summary>
        static UInt16x2 IUnaryNegationOperators<UInt16x2, UInt16x2>.
            operator -(UInt16x2 value) => value;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt16x2 operator +(UInt16x2 value) => value;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt16x2 MaxMagnitude(UInt16x2 x, UInt16x2 y) =>
            Max(x, y);

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt16x2 MaxMagnitudeNumber(UInt16x2 x, UInt16x2 y) =>
            MaxMagnitude(x, y);

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt16x2 MinMagnitude(UInt16x2 x, UInt16x2 y) =>
            Min(x, y);

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt16x2 MinMagnitudeNumber(UInt16x2 x, UInt16x2 y) =>
            MinMagnitude(x, y);

        // Not supported operations

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static UInt16x2 IParsable<UInt16x2>.Parse(
            string s,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static UInt16x2 ISpanParsable<UInt16x2>.Parse(
            ReadOnlySpan<char> s,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static UInt16x2 INumberBase<UInt16x2>.Parse(
            ReadOnlySpan<char> s,
            NumberStyles style,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static UInt16x2 INumberBase<UInt16x2>.Parse(
            string s,
            NumberStyles style,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        bool ISpanFormattable.TryFormat(
            Span<char> destination,
            out int charsWritten,
            ReadOnlySpan<char> format,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool IParsable<UInt16x2>.TryParse(
            string? s,
            IFormatProvider? provider,
            out UInt16x2 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given span into a vectorized instance.
        /// </summary>
        static bool ISpanParsable<UInt16x2>.TryParse(
            ReadOnlySpan<char> s,
            IFormatProvider? provider,
            out UInt16x2 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool INumberBase<UInt16x2>.TryParse(
            ReadOnlySpan<char> s,
            NumberStyles style,
            IFormatProvider? provider,
            out UInt16x2 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool INumberBase<UInt16x2>.TryParse(
            string? s,
            NumberStyles style,
            IFormatProvider? provider,
            out UInt16x2 result) =>
            throw new NotSupportedException();

        static bool INumberBase<UInt16x2>.TryConvertFromChecked<TOther>(
            TOther value,
            out UInt16x2 result) =>
            throw new NotSupportedException();
        static bool INumberBase<UInt16x2>.TryConvertFromSaturating<TOther>(
            TOther value,
            out UInt16x2 result) =>
            throw new NotSupportedException();
        static bool INumberBase<UInt16x2>.TryConvertFromTruncating<TOther>(
            TOther value,
            out UInt16x2 result) =>
            throw new NotSupportedException();
        static bool INumberBase<UInt16x2>.TryConvertToChecked<TOther>(
            UInt16x2 value,
            out TOther result) =>
            throw new NotSupportedException();
        static bool INumberBase<UInt16x2>.TryConvertToSaturating<TOther>(
            UInt16x2 value,
            out TOther result) =>
            throw new NotSupportedException();
        static bool INumberBase<UInt16x2>.TryConvertToTruncating<TOther>(
            UInt16x2 value,
            out TOther result) =>
            throw new NotSupportedException();
    }

    /// <summary>
    /// Represents a vectorized ushort type with length 4.
    /// </summary>
    [CLSCompliant(false)]
    public readonly record struct UInt16x4(
        ushort X, ushort Y, ushort Z, ushort W) :
        IVectorType<UInt16x4, ushort>
    {
        /// <summary>
        /// The offset of the X field in bytes.
        /// </summary>
        public static readonly int OffsetX =
            sizeof(ushort) * 0;

        /// <summary>
        /// The offset of the X field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrX =>
            new UIntPtr((uint)OffsetX);
        /// <summary>
        /// The offset of the Y field in bytes.
        /// </summary>
        public static readonly int OffsetY =
            sizeof(ushort) * 1;

        /// <summary>
        /// The offset of the Y field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrY =>
            new UIntPtr((uint)OffsetY);
        /// <summary>
        /// The offset of the Z field in bytes.
        /// </summary>
        public static readonly int OffsetZ =
            sizeof(ushort) * 2;

        /// <summary>
        /// The offset of the Z field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrZ =>
            new UIntPtr((uint)OffsetZ);
        /// <summary>
        /// The offset of the W field in bytes.
        /// </summary>
        public static readonly int OffsetW =
            sizeof(ushort) * 3;

        /// <summary>
        /// The offset of the W field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrW =>
            new UIntPtr((uint)OffsetW);

        /// <summary>
        /// Returns the length of this vector which is 4.
        /// </summary>
        public static int Length => 4;

        /// <summary>
        /// Returns the radix of the underlying value.
        /// </summary>
        public static int Radix => 10;

        /// <summary>
        /// Returns an invalid value (min [signed types], max value [unsigned] or NaN).
        /// </summary>
        public static UInt16x4 Invalid => FromScalar(
            ushort.MaxValue
        );

        /// <summary>
        /// Returns the value zero.
        /// </summary>
        public static UInt16x4 Zero => new();

        /// <summary>
        /// Returns the value one.
        /// </summary>
        public static UInt16x4 One => FromScalar((1));

        /// <summary>
        /// Returns the value zero.
        /// </summary>
        public static UInt16x4 AdditiveIdentity => Zero;

        /// <summary>
        /// Returns the value one.
        /// </summary>
        public static UInt16x4 MultiplicativeIdentity => One;

        /// <summary>
        /// Computes the min value of both.
        /// </summary>
        /// <param name="first">The first value.</param>
        /// <param name="second">The second value.</param>
        /// <returns>The min value.</returns>
        public static UInt16x4 Min(
            UInt16x4 first,
            UInt16x4 second) =>
            new UInt16x4((ushort)Math.Min(first.X, second.X), (ushort)Math.Min(first.Y, second.Y), (ushort)Math.Min(first.Z, second.Z), (ushort)Math.Min(first.W, second.W));

        /// <summary>
        /// Computes the max value of both.
        /// </summary>
        /// <param name="first">The first value.</param>
        /// <param name="second">The second value.</param>
        /// <returns>The max value.</returns>
        public static UInt16x4 Max(
            UInt16x4 first,
            UInt16x4 second) =>
            new UInt16x4((ushort)Math.Max(first.X, second.X), (ushort)Math.Max(first.Y, second.Y), (ushort)Math.Max(first.Z, second.Z), (ushort)Math.Max(first.W, second.W));

        /// <summary>
        /// Clamps the given value.
        /// </summary>
        /// <param name="value">The value to clamp.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The clamped value.</returns>
        public static UInt16x4 Clamp(
            UInt16x4 value,
            UInt16x4 min,
            UInt16x4 max) =>
            Max(Min(value, max), min);

        /// <summary>
        /// Creates a random scalar instance falling into the range of min max.
        /// </summary>
        /// <param name="random">The random provider to use.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The created random scalar instance.</returns>
        public static ushort GetRandomScalar<TRandom>(
            ref TRandom random,
            ushort min,
            ushort max)
            where TRandom : struct, IRandomProvider =>
            (ushort)RandomExtensions.
                Next(ref random, min, max);

        /// <summary>
        /// Creates a random vector instance falling into the range of min max.
        /// </summary>
        /// <param name="random">The random provider to use.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The created random vector instance.</returns>
        public static UInt16x4 GetRandom<TRandom>(
            ref TRandom random,
            UInt16x4 min,
            UInt16x4 max)
            where TRandom : struct, IRandomProvider
        {
            ushort x = GetRandomScalar(
                ref random, min.X, max.X);
            ushort y = GetRandomScalar(
                ref random, min.Y, max.Y);
            ushort z = GetRandomScalar(
                ref random, min.Z, max.Z);
            ushort w = GetRandomScalar(
                ref random, min.W, max.W);
            return new UInt16x4(x, y, z, w);
        }

        /// <summary>
        /// Creates a vector instance from the given source view.
        /// </summary>
        /// <typeparam name="TStride">The custom stride type.</typeparam>
        /// <param name="sourceView">The source view.</param>
        /// <param name="index">The source base index.</param>
        /// <returns>The vector instance.</returns>
        public static UInt16x4 FromElementView<TStride>(
            ArrayView1D<ushort, TStride> sourceView,
            Index1D index)
            where TStride : struct, IStride1D =>
            new UInt16x4(
                sourceView[index + 0],
                sourceView[index + 1],
                sourceView[index + 2],
                sourceView[index + 3]
                );

        /// <summary>
        /// Serializes the current vector instance into the given target view.
        /// </summary>
        /// <typeparam name="TStride">The custom stride type.</typeparam>
        /// <param name="targetView">The target view.</param>
        /// <param name="index">The target base index.</param>
        public void ToElementView<TStride>(
            ArrayView1D<ushort, TStride> targetView,
            Index1D index)
            where TStride : struct, IStride1D
        {
            targetView[index + 0] = X;
            targetView[index + 1] = Y;
            targetView[index + 2] = Z;
            targetView[index + 3] = W;
        }

        /// <summary>
        /// Creates a vector instance from the given source view.
        /// </summary>
        /// <param name="sourceView">The source view.</param>
        /// <param name="index">The source base index.</param>
        /// <returns>The vector instance.</returns>
        public static UInt16x4 FromElementView(
            SingleVectorView<ushort> sourceView,
            Index1D index) =>
            new UInt16x4(
                sourceView[index + 0],
                sourceView[index + 1],
                sourceView[index + 2],
                sourceView[index + 3]
                );

        /// <summary>
        /// Serializes the current vector instance into the given target view.
        /// </summary>
        /// <param name="targetView">The target view.</param>
        /// <param name="index">The target base index.</param>
        public void ToElementView(
            SingleVectorView<ushort> targetView,
            Index1D index)
        {
            targetView[index + 0] = X;
            targetView[index + 1] = Y;
            targetView[index + 2] = Z;
            targetView[index + 3] = W;
        }

        /// <summary>
        /// Converts a scalar value into the current vectorized type.
        /// </summary>
        /// <param name="scalar">The scalar element type.</param>
        /// <returns>The created vectorized type.</returns>
        public static UInt16x4 FromScalar(ushort scalar) =>
            new UInt16x4(scalar, scalar, scalar, scalar);

        /// <summary>
        /// Converts this instance into an unsafe span instance.
        /// </summary>
        /// <returns>The readonly span instance.</returns>
        public unsafe ReadOnlySpan<ushort> AsSpan() =>
            new(Unsafe.AsPointer(ref Unsafe.AsRef(this)), 4);

        /// <summary>
        /// Iterates over all elements by applying the given iterator to each element.
        /// </summary>
        /// <typeparam name="TIterator">The managed iterator type.</typeparam>
        /// <param name="iterator">The iterator to invoke.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ForEach<TIterator>(ref TIterator iterator)
            where TIterator : struct, IVectorElementIterator<
            UInt16x4,
            ushort>
        {
            iterator.Iterate(X, 0);
            iterator.Iterate(Y, 1);
            iterator.Iterate(Z, 2);
            iterator.Iterate(W, 3);
        }

        /// <summary>
        /// Converts this vector instance to a string.
        /// </summary>
        public override string ToString() =>
            $"{X}, {Y}, {Z}, {W}";

        /// <summary>
        /// Converts this vector instance to a string.
        /// </summary>
        public string ToString(string? format, IFormatProvider? formatProvider) =>
            $"{X.ToString(format, formatProvider)}, {Y.ToString(format, formatProvider)}, {Z.ToString(format, formatProvider)}, {W.ToString(format, formatProvider)}";

        /// <summary>
        /// Returns true.
        /// </summary>
        public static bool IsCanonical(UInt16x4 value) => true;

        /// <summary>
        /// Returns false.
        /// </summary>
        public static bool IsComplexNumber(UInt16x4 value) => false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsEvenInteger(UInt16x4 value) =>
            ushort.IsEvenInteger(value.X) & ushort.IsEvenInteger(value.Y) & ushort.IsEvenInteger(value.Z) & ushort.IsEvenInteger(value.W);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsFinite(UInt16x4 value) =>
            true;

        /// <summary>
        /// Returns false.
        /// </summary>
        public static bool IsImaginaryNumber(UInt16x4 value) => false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsInfinity(UInt16x4 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsInteger(UInt16x4 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNaN(UInt16x4 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNegative(UInt16x4 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNegativeInfinity(UInt16x4 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNormal(UInt16x4 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsOddInteger(UInt16x4 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsPositive(UInt16x4 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsPositiveInfinity(UInt16x4 value) =>
            false;

        /// <summary>
        /// Returns true.
        /// </summary>
        public static bool IsRealNumber(UInt16x4 value) => true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsSubnormal(UInt16x4 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsZero(UInt16x4 value) =>
            value == Zero;

        /// <summary>
        /// Returns the absolute value.
        /// </summary>
        public static UInt16x4 Abs(UInt16x4 value) =>
            value;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt16x4 operator +(UInt16x4 left, UInt16x4 right) =>
            new UInt16x4((ushort)(left.X + right.X), (ushort)(left.Y + right.Y), (ushort)(left.Z + right.Z), (ushort)(left.W + right.W));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt16x4 operator --(UInt16x4 value) => value - One;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt16x4 operator /(UInt16x4 left, UInt16x4 right) =>
            new UInt16x4((ushort)(left.X / right.X), (ushort)(left.Y / right.Y), (ushort)(left.Z / right.Z), (ushort)(left.W / right.W));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt16x4 operator ++(UInt16x4 value) => value + One;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt16x4 operator *(UInt16x4 left, UInt16x4 right) =>
            new UInt16x4((ushort)(left.X * right.X), (ushort)(left.Y * right.Y), (ushort)(left.Z * right.Z), (ushort)(left.W * right.W));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt16x4 operator -(UInt16x4 left, UInt16x4 right) =>
            new UInt16x4((ushort)(left.X - right.X), (ushort)(left.Y - right.Y), (ushort)(left.Z - right.Z), (ushort)(left.W - right.W));

        /// <summary>
        /// Not supported operation.
        /// </summary>
        static UInt16x4 IUnaryNegationOperators<UInt16x4, UInt16x4>.
            operator -(UInt16x4 value) => value;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt16x4 operator +(UInt16x4 value) => value;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt16x4 MaxMagnitude(UInt16x4 x, UInt16x4 y) =>
            Max(x, y);

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt16x4 MaxMagnitudeNumber(UInt16x4 x, UInt16x4 y) =>
            MaxMagnitude(x, y);

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt16x4 MinMagnitude(UInt16x4 x, UInt16x4 y) =>
            Min(x, y);

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt16x4 MinMagnitudeNumber(UInt16x4 x, UInt16x4 y) =>
            MinMagnitude(x, y);

        // Not supported operations

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static UInt16x4 IParsable<UInt16x4>.Parse(
            string s,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static UInt16x4 ISpanParsable<UInt16x4>.Parse(
            ReadOnlySpan<char> s,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static UInt16x4 INumberBase<UInt16x4>.Parse(
            ReadOnlySpan<char> s,
            NumberStyles style,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static UInt16x4 INumberBase<UInt16x4>.Parse(
            string s,
            NumberStyles style,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        bool ISpanFormattable.TryFormat(
            Span<char> destination,
            out int charsWritten,
            ReadOnlySpan<char> format,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool IParsable<UInt16x4>.TryParse(
            string? s,
            IFormatProvider? provider,
            out UInt16x4 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given span into a vectorized instance.
        /// </summary>
        static bool ISpanParsable<UInt16x4>.TryParse(
            ReadOnlySpan<char> s,
            IFormatProvider? provider,
            out UInt16x4 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool INumberBase<UInt16x4>.TryParse(
            ReadOnlySpan<char> s,
            NumberStyles style,
            IFormatProvider? provider,
            out UInt16x4 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool INumberBase<UInt16x4>.TryParse(
            string? s,
            NumberStyles style,
            IFormatProvider? provider,
            out UInt16x4 result) =>
            throw new NotSupportedException();

        static bool INumberBase<UInt16x4>.TryConvertFromChecked<TOther>(
            TOther value,
            out UInt16x4 result) =>
            throw new NotSupportedException();
        static bool INumberBase<UInt16x4>.TryConvertFromSaturating<TOther>(
            TOther value,
            out UInt16x4 result) =>
            throw new NotSupportedException();
        static bool INumberBase<UInt16x4>.TryConvertFromTruncating<TOther>(
            TOther value,
            out UInt16x4 result) =>
            throw new NotSupportedException();
        static bool INumberBase<UInt16x4>.TryConvertToChecked<TOther>(
            UInt16x4 value,
            out TOther result) =>
            throw new NotSupportedException();
        static bool INumberBase<UInt16x4>.TryConvertToSaturating<TOther>(
            UInt16x4 value,
            out TOther result) =>
            throw new NotSupportedException();
        static bool INumberBase<UInt16x4>.TryConvertToTruncating<TOther>(
            UInt16x4 value,
            out TOther result) =>
            throw new NotSupportedException();
    }

    /// <summary>
    /// Represents a vectorized ushort type with length 8.
    /// </summary>
    [CLSCompliant(false)]
    public readonly record struct UInt16x8(
        ushort X, ushort Y, ushort Z, ushort W, ushort I, ushort J, ushort K, ushort L) :
        IVectorType<UInt16x8, ushort>
    {
        /// <summary>
        /// The offset of the X field in bytes.
        /// </summary>
        public static readonly int OffsetX =
            sizeof(ushort) * 0;

        /// <summary>
        /// The offset of the X field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrX =>
            new UIntPtr((uint)OffsetX);
        /// <summary>
        /// The offset of the Y field in bytes.
        /// </summary>
        public static readonly int OffsetY =
            sizeof(ushort) * 1;

        /// <summary>
        /// The offset of the Y field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrY =>
            new UIntPtr((uint)OffsetY);
        /// <summary>
        /// The offset of the Z field in bytes.
        /// </summary>
        public static readonly int OffsetZ =
            sizeof(ushort) * 2;

        /// <summary>
        /// The offset of the Z field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrZ =>
            new UIntPtr((uint)OffsetZ);
        /// <summary>
        /// The offset of the W field in bytes.
        /// </summary>
        public static readonly int OffsetW =
            sizeof(ushort) * 3;

        /// <summary>
        /// The offset of the W field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrW =>
            new UIntPtr((uint)OffsetW);
        /// <summary>
        /// The offset of the I field in bytes.
        /// </summary>
        public static readonly int OffsetI =
            sizeof(ushort) * 4;

        /// <summary>
        /// The offset of the I field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrI =>
            new UIntPtr((uint)OffsetI);
        /// <summary>
        /// The offset of the J field in bytes.
        /// </summary>
        public static readonly int OffsetJ =
            sizeof(ushort) * 5;

        /// <summary>
        /// The offset of the J field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrJ =>
            new UIntPtr((uint)OffsetJ);
        /// <summary>
        /// The offset of the K field in bytes.
        /// </summary>
        public static readonly int OffsetK =
            sizeof(ushort) * 6;

        /// <summary>
        /// The offset of the K field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrK =>
            new UIntPtr((uint)OffsetK);
        /// <summary>
        /// The offset of the L field in bytes.
        /// </summary>
        public static readonly int OffsetL =
            sizeof(ushort) * 7;

        /// <summary>
        /// The offset of the L field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrL =>
            new UIntPtr((uint)OffsetL);

        /// <summary>
        /// Returns the length of this vector which is 8.
        /// </summary>
        public static int Length => 8;

        /// <summary>
        /// Returns the radix of the underlying value.
        /// </summary>
        public static int Radix => 10;

        /// <summary>
        /// Returns an invalid value (min [signed types], max value [unsigned] or NaN).
        /// </summary>
        public static UInt16x8 Invalid => FromScalar(
            ushort.MaxValue
        );

        /// <summary>
        /// Returns the value zero.
        /// </summary>
        public static UInt16x8 Zero => new();

        /// <summary>
        /// Returns the value one.
        /// </summary>
        public static UInt16x8 One => FromScalar((1));

        /// <summary>
        /// Returns the value zero.
        /// </summary>
        public static UInt16x8 AdditiveIdentity => Zero;

        /// <summary>
        /// Returns the value one.
        /// </summary>
        public static UInt16x8 MultiplicativeIdentity => One;

        /// <summary>
        /// Computes the min value of both.
        /// </summary>
        /// <param name="first">The first value.</param>
        /// <param name="second">The second value.</param>
        /// <returns>The min value.</returns>
        public static UInt16x8 Min(
            UInt16x8 first,
            UInt16x8 second) =>
            new UInt16x8((ushort)Math.Min(first.X, second.X), (ushort)Math.Min(first.Y, second.Y), (ushort)Math.Min(first.Z, second.Z), (ushort)Math.Min(first.W, second.W), (ushort)Math.Min(first.I, second.I), (ushort)Math.Min(first.J, second.J), (ushort)Math.Min(first.K, second.K), (ushort)Math.Min(first.L, second.L));

        /// <summary>
        /// Computes the max value of both.
        /// </summary>
        /// <param name="first">The first value.</param>
        /// <param name="second">The second value.</param>
        /// <returns>The max value.</returns>
        public static UInt16x8 Max(
            UInt16x8 first,
            UInt16x8 second) =>
            new UInt16x8((ushort)Math.Max(first.X, second.X), (ushort)Math.Max(first.Y, second.Y), (ushort)Math.Max(first.Z, second.Z), (ushort)Math.Max(first.W, second.W), (ushort)Math.Max(first.I, second.I), (ushort)Math.Max(first.J, second.J), (ushort)Math.Max(first.K, second.K), (ushort)Math.Max(first.L, second.L));

        /// <summary>
        /// Clamps the given value.
        /// </summary>
        /// <param name="value">The value to clamp.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The clamped value.</returns>
        public static UInt16x8 Clamp(
            UInt16x8 value,
            UInt16x8 min,
            UInt16x8 max) =>
            Max(Min(value, max), min);

        /// <summary>
        /// Creates a random scalar instance falling into the range of min max.
        /// </summary>
        /// <param name="random">The random provider to use.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The created random scalar instance.</returns>
        public static ushort GetRandomScalar<TRandom>(
            ref TRandom random,
            ushort min,
            ushort max)
            where TRandom : struct, IRandomProvider =>
            (ushort)RandomExtensions.
                Next(ref random, min, max);

        /// <summary>
        /// Creates a random vector instance falling into the range of min max.
        /// </summary>
        /// <param name="random">The random provider to use.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The created random vector instance.</returns>
        public static UInt16x8 GetRandom<TRandom>(
            ref TRandom random,
            UInt16x8 min,
            UInt16x8 max)
            where TRandom : struct, IRandomProvider
        {
            ushort x = GetRandomScalar(
                ref random, min.X, max.X);
            ushort y = GetRandomScalar(
                ref random, min.Y, max.Y);
            ushort z = GetRandomScalar(
                ref random, min.Z, max.Z);
            ushort w = GetRandomScalar(
                ref random, min.W, max.W);
            ushort i = GetRandomScalar(
                ref random, min.I, max.I);
            ushort j = GetRandomScalar(
                ref random, min.J, max.J);
            ushort k = GetRandomScalar(
                ref random, min.K, max.K);
            ushort l = GetRandomScalar(
                ref random, min.L, max.L);
            return new UInt16x8(x, y, z, w, i, j, k, l);
        }

        /// <summary>
        /// Creates a vector instance from the given source view.
        /// </summary>
        /// <typeparam name="TStride">The custom stride type.</typeparam>
        /// <param name="sourceView">The source view.</param>
        /// <param name="index">The source base index.</param>
        /// <returns>The vector instance.</returns>
        public static UInt16x8 FromElementView<TStride>(
            ArrayView1D<ushort, TStride> sourceView,
            Index1D index)
            where TStride : struct, IStride1D =>
            new UInt16x8(
                sourceView[index + 0],
                sourceView[index + 1],
                sourceView[index + 2],
                sourceView[index + 3],
                sourceView[index + 4],
                sourceView[index + 5],
                sourceView[index + 6],
                sourceView[index + 7]
                );

        /// <summary>
        /// Serializes the current vector instance into the given target view.
        /// </summary>
        /// <typeparam name="TStride">The custom stride type.</typeparam>
        /// <param name="targetView">The target view.</param>
        /// <param name="index">The target base index.</param>
        public void ToElementView<TStride>(
            ArrayView1D<ushort, TStride> targetView,
            Index1D index)
            where TStride : struct, IStride1D
        {
            targetView[index + 0] = X;
            targetView[index + 1] = Y;
            targetView[index + 2] = Z;
            targetView[index + 3] = W;
            targetView[index + 4] = I;
            targetView[index + 5] = J;
            targetView[index + 6] = K;
            targetView[index + 7] = L;
        }

        /// <summary>
        /// Creates a vector instance from the given source view.
        /// </summary>
        /// <param name="sourceView">The source view.</param>
        /// <param name="index">The source base index.</param>
        /// <returns>The vector instance.</returns>
        public static UInt16x8 FromElementView(
            SingleVectorView<ushort> sourceView,
            Index1D index) =>
            new UInt16x8(
                sourceView[index + 0],
                sourceView[index + 1],
                sourceView[index + 2],
                sourceView[index + 3],
                sourceView[index + 4],
                sourceView[index + 5],
                sourceView[index + 6],
                sourceView[index + 7]
                );

        /// <summary>
        /// Serializes the current vector instance into the given target view.
        /// </summary>
        /// <param name="targetView">The target view.</param>
        /// <param name="index">The target base index.</param>
        public void ToElementView(
            SingleVectorView<ushort> targetView,
            Index1D index)
        {
            targetView[index + 0] = X;
            targetView[index + 1] = Y;
            targetView[index + 2] = Z;
            targetView[index + 3] = W;
            targetView[index + 4] = I;
            targetView[index + 5] = J;
            targetView[index + 6] = K;
            targetView[index + 7] = L;
        }

        /// <summary>
        /// Converts a scalar value into the current vectorized type.
        /// </summary>
        /// <param name="scalar">The scalar element type.</param>
        /// <returns>The created vectorized type.</returns>
        public static UInt16x8 FromScalar(ushort scalar) =>
            new UInt16x8(scalar, scalar, scalar, scalar, scalar, scalar, scalar, scalar);

        /// <summary>
        /// Converts this instance into an unsafe span instance.
        /// </summary>
        /// <returns>The readonly span instance.</returns>
        public unsafe ReadOnlySpan<ushort> AsSpan() =>
            new(Unsafe.AsPointer(ref Unsafe.AsRef(this)), 8);

        /// <summary>
        /// Iterates over all elements by applying the given iterator to each element.
        /// </summary>
        /// <typeparam name="TIterator">The managed iterator type.</typeparam>
        /// <param name="iterator">The iterator to invoke.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ForEach<TIterator>(ref TIterator iterator)
            where TIterator : struct, IVectorElementIterator<
            UInt16x8,
            ushort>
        {
            iterator.Iterate(X, 0);
            iterator.Iterate(Y, 1);
            iterator.Iterate(Z, 2);
            iterator.Iterate(W, 3);
            iterator.Iterate(I, 4);
            iterator.Iterate(J, 5);
            iterator.Iterate(K, 6);
            iterator.Iterate(L, 7);
        }

        /// <summary>
        /// Converts this vector instance to a string.
        /// </summary>
        public override string ToString() =>
            $"{X}, {Y}, {Z}, {W}, {I}, {J}, {K}, {L}";

        /// <summary>
        /// Converts this vector instance to a string.
        /// </summary>
        public string ToString(string? format, IFormatProvider? formatProvider) =>
            $"{X.ToString(format, formatProvider)}, {Y.ToString(format, formatProvider)}, {Z.ToString(format, formatProvider)}, {W.ToString(format, formatProvider)}, {I.ToString(format, formatProvider)}, {J.ToString(format, formatProvider)}, {K.ToString(format, formatProvider)}, {L.ToString(format, formatProvider)}";

        /// <summary>
        /// Returns true.
        /// </summary>
        public static bool IsCanonical(UInt16x8 value) => true;

        /// <summary>
        /// Returns false.
        /// </summary>
        public static bool IsComplexNumber(UInt16x8 value) => false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsEvenInteger(UInt16x8 value) =>
            ushort.IsEvenInteger(value.X) & ushort.IsEvenInteger(value.Y) & ushort.IsEvenInteger(value.Z) & ushort.IsEvenInteger(value.W) & ushort.IsEvenInteger(value.I) & ushort.IsEvenInteger(value.J) & ushort.IsEvenInteger(value.K) & ushort.IsEvenInteger(value.L);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsFinite(UInt16x8 value) =>
            true;

        /// <summary>
        /// Returns false.
        /// </summary>
        public static bool IsImaginaryNumber(UInt16x8 value) => false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsInfinity(UInt16x8 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsInteger(UInt16x8 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNaN(UInt16x8 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNegative(UInt16x8 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNegativeInfinity(UInt16x8 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNormal(UInt16x8 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsOddInteger(UInt16x8 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsPositive(UInt16x8 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsPositiveInfinity(UInt16x8 value) =>
            false;

        /// <summary>
        /// Returns true.
        /// </summary>
        public static bool IsRealNumber(UInt16x8 value) => true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsSubnormal(UInt16x8 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsZero(UInt16x8 value) =>
            value == Zero;

        /// <summary>
        /// Returns the absolute value.
        /// </summary>
        public static UInt16x8 Abs(UInt16x8 value) =>
            value;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt16x8 operator +(UInt16x8 left, UInt16x8 right) =>
            new UInt16x8((ushort)(left.X + right.X), (ushort)(left.Y + right.Y), (ushort)(left.Z + right.Z), (ushort)(left.W + right.W), (ushort)(left.I + right.I), (ushort)(left.J + right.J), (ushort)(left.K + right.K), (ushort)(left.L + right.L));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt16x8 operator --(UInt16x8 value) => value - One;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt16x8 operator /(UInt16x8 left, UInt16x8 right) =>
            new UInt16x8((ushort)(left.X / right.X), (ushort)(left.Y / right.Y), (ushort)(left.Z / right.Z), (ushort)(left.W / right.W), (ushort)(left.I / right.I), (ushort)(left.J / right.J), (ushort)(left.K / right.K), (ushort)(left.L / right.L));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt16x8 operator ++(UInt16x8 value) => value + One;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt16x8 operator *(UInt16x8 left, UInt16x8 right) =>
            new UInt16x8((ushort)(left.X * right.X), (ushort)(left.Y * right.Y), (ushort)(left.Z * right.Z), (ushort)(left.W * right.W), (ushort)(left.I * right.I), (ushort)(left.J * right.J), (ushort)(left.K * right.K), (ushort)(left.L * right.L));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt16x8 operator -(UInt16x8 left, UInt16x8 right) =>
            new UInt16x8((ushort)(left.X - right.X), (ushort)(left.Y - right.Y), (ushort)(left.Z - right.Z), (ushort)(left.W - right.W), (ushort)(left.I - right.I), (ushort)(left.J - right.J), (ushort)(left.K - right.K), (ushort)(left.L - right.L));

        /// <summary>
        /// Not supported operation.
        /// </summary>
        static UInt16x8 IUnaryNegationOperators<UInt16x8, UInt16x8>.
            operator -(UInt16x8 value) => value;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt16x8 operator +(UInt16x8 value) => value;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt16x8 MaxMagnitude(UInt16x8 x, UInt16x8 y) =>
            Max(x, y);

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt16x8 MaxMagnitudeNumber(UInt16x8 x, UInt16x8 y) =>
            MaxMagnitude(x, y);

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt16x8 MinMagnitude(UInt16x8 x, UInt16x8 y) =>
            Min(x, y);

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt16x8 MinMagnitudeNumber(UInt16x8 x, UInt16x8 y) =>
            MinMagnitude(x, y);

        // Not supported operations

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static UInt16x8 IParsable<UInt16x8>.Parse(
            string s,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static UInt16x8 ISpanParsable<UInt16x8>.Parse(
            ReadOnlySpan<char> s,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static UInt16x8 INumberBase<UInt16x8>.Parse(
            ReadOnlySpan<char> s,
            NumberStyles style,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static UInt16x8 INumberBase<UInt16x8>.Parse(
            string s,
            NumberStyles style,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        bool ISpanFormattable.TryFormat(
            Span<char> destination,
            out int charsWritten,
            ReadOnlySpan<char> format,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool IParsable<UInt16x8>.TryParse(
            string? s,
            IFormatProvider? provider,
            out UInt16x8 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given span into a vectorized instance.
        /// </summary>
        static bool ISpanParsable<UInt16x8>.TryParse(
            ReadOnlySpan<char> s,
            IFormatProvider? provider,
            out UInt16x8 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool INumberBase<UInt16x8>.TryParse(
            ReadOnlySpan<char> s,
            NumberStyles style,
            IFormatProvider? provider,
            out UInt16x8 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool INumberBase<UInt16x8>.TryParse(
            string? s,
            NumberStyles style,
            IFormatProvider? provider,
            out UInt16x8 result) =>
            throw new NotSupportedException();

        static bool INumberBase<UInt16x8>.TryConvertFromChecked<TOther>(
            TOther value,
            out UInt16x8 result) =>
            throw new NotSupportedException();
        static bool INumberBase<UInt16x8>.TryConvertFromSaturating<TOther>(
            TOther value,
            out UInt16x8 result) =>
            throw new NotSupportedException();
        static bool INumberBase<UInt16x8>.TryConvertFromTruncating<TOther>(
            TOther value,
            out UInt16x8 result) =>
            throw new NotSupportedException();
        static bool INumberBase<UInt16x8>.TryConvertToChecked<TOther>(
            UInt16x8 value,
            out TOther result) =>
            throw new NotSupportedException();
        static bool INumberBase<UInt16x8>.TryConvertToSaturating<TOther>(
            UInt16x8 value,
            out TOther result) =>
            throw new NotSupportedException();
        static bool INumberBase<UInt16x8>.TryConvertToTruncating<TOther>(
            UInt16x8 value,
            out TOther result) =>
            throw new NotSupportedException();
    }

    /// <summary>
    /// Represents a vectorized uint type with length 2.
    /// </summary>
    [CLSCompliant(false)]
    public readonly record struct UInt32x2(
        uint X, uint Y) :
        IVectorType<UInt32x2, uint>
        , IAccumulationVectorType<
            UInt32x2,
            UInt8x2,
            byte>
        , IAccumulationVectorType<
            UInt32x2,
            UInt16x2,
            ushort>
        , IAccumulationVectorType<
            UInt32x2,
            UInt32x2,
            uint>
        , IAccumulationVectorType<
            UInt32x2,
            Float32x2,
            float>
        , IAccumulationVectorType<
            UInt32x2,
            Float64x2,
            double>
    {
        /// <summary>
        /// The offset of the X field in bytes.
        /// </summary>
        public static readonly int OffsetX =
            sizeof(uint) * 0;

        /// <summary>
        /// The offset of the X field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrX =>
            new UIntPtr((uint)OffsetX);
        /// <summary>
        /// The offset of the Y field in bytes.
        /// </summary>
        public static readonly int OffsetY =
            sizeof(uint) * 1;

        /// <summary>
        /// The offset of the Y field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrY =>
            new UIntPtr((uint)OffsetY);

        /// <summary>
        /// Returns the length of this vector which is 2.
        /// </summary>
        public static int Length => 2;

        /// <summary>
        /// Returns the radix of the underlying value.
        /// </summary>
        public static int Radix => 10;

        /// <summary>
        /// Returns an invalid value (min [signed types], max value [unsigned] or NaN).
        /// </summary>
        public static UInt32x2 Invalid => FromScalar(
            uint.MaxValue
        );

        /// <summary>
        /// Returns the value zero.
        /// </summary>
        public static UInt32x2 Zero => new();

        /// <summary>
        /// Returns the value one.
        /// </summary>
        public static UInt32x2 One => FromScalar((1));

        /// <summary>
        /// Returns the value zero.
        /// </summary>
        public static UInt32x2 AdditiveIdentity => Zero;

        /// <summary>
        /// Returns the value one.
        /// </summary>
        public static UInt32x2 MultiplicativeIdentity => One;

        /// <summary>
        /// Computes the min value of both.
        /// </summary>
        /// <param name="first">The first value.</param>
        /// <param name="second">The second value.</param>
        /// <returns>The min value.</returns>
        public static UInt32x2 Min(
            UInt32x2 first,
            UInt32x2 second) =>
            new UInt32x2((uint)Math.Min(first.X, second.X), (uint)Math.Min(first.Y, second.Y));

        /// <summary>
        /// Computes the max value of both.
        /// </summary>
        /// <param name="first">The first value.</param>
        /// <param name="second">The second value.</param>
        /// <returns>The max value.</returns>
        public static UInt32x2 Max(
            UInt32x2 first,
            UInt32x2 second) =>
            new UInt32x2((uint)Math.Max(first.X, second.X), (uint)Math.Max(first.Y, second.Y));

        /// <summary>
        /// Clamps the given value.
        /// </summary>
        /// <param name="value">The value to clamp.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The clamped value.</returns>
        public static UInt32x2 Clamp(
            UInt32x2 value,
            UInt32x2 min,
            UInt32x2 max) =>
            Max(Min(value, max), min);

        /// <summary>
        /// Creates a random scalar instance falling into the range of min max.
        /// </summary>
        /// <param name="random">The random provider to use.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The created random scalar instance.</returns>
        public static uint GetRandomScalar<TRandom>(
            ref TRandom random,
            uint min,
            uint max)
            where TRandom : struct, IRandomProvider =>
            (uint)RandomExtensions.
                Next(ref random, min, max);

        /// <summary>
        /// Creates a random vector instance falling into the range of min max.
        /// </summary>
        /// <param name="random">The random provider to use.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The created random vector instance.</returns>
        public static UInt32x2 GetRandom<TRandom>(
            ref TRandom random,
            UInt32x2 min,
            UInt32x2 max)
            where TRandom : struct, IRandomProvider
        {
            uint x = GetRandomScalar(
                ref random, min.X, max.X);
            uint y = GetRandomScalar(
                ref random, min.Y, max.Y);
            return new UInt32x2(x, y);
        }

        /// <summary>
        /// Creates a vector instance from the given source view.
        /// </summary>
        /// <typeparam name="TStride">The custom stride type.</typeparam>
        /// <param name="sourceView">The source view.</param>
        /// <param name="index">The source base index.</param>
        /// <returns>The vector instance.</returns>
        public static UInt32x2 FromElementView<TStride>(
            ArrayView1D<uint, TStride> sourceView,
            Index1D index)
            where TStride : struct, IStride1D =>
            new UInt32x2(
                sourceView[index + 0],
                sourceView[index + 1]
                );

        /// <summary>
        /// Serializes the current vector instance into the given target view.
        /// </summary>
        /// <typeparam name="TStride">The custom stride type.</typeparam>
        /// <param name="targetView">The target view.</param>
        /// <param name="index">The target base index.</param>
        public void ToElementView<TStride>(
            ArrayView1D<uint, TStride> targetView,
            Index1D index)
            where TStride : struct, IStride1D
        {
            targetView[index + 0] = X;
            targetView[index + 1] = Y;
        }

        /// <summary>
        /// Creates a vector instance from the given source view.
        /// </summary>
        /// <param name="sourceView">The source view.</param>
        /// <param name="index">The source base index.</param>
        /// <returns>The vector instance.</returns>
        public static UInt32x2 FromElementView(
            SingleVectorView<uint> sourceView,
            Index1D index) =>
            new UInt32x2(
                sourceView[index + 0],
                sourceView[index + 1]
                );

        /// <summary>
        /// Serializes the current vector instance into the given target view.
        /// </summary>
        /// <param name="targetView">The target view.</param>
        /// <param name="index">The target base index.</param>
        public void ToElementView(
            SingleVectorView<uint> targetView,
            Index1D index)
        {
            targetView[index + 0] = X;
            targetView[index + 1] = Y;
        }

        /// <summary>
        /// Converts a scalar value into the current vectorized type.
        /// </summary>
        /// <param name="scalar">The scalar element type.</param>
        /// <returns>The created vectorized type.</returns>
        public static UInt32x2 FromScalar(uint scalar) =>
            new UInt32x2(scalar, scalar);

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        public static void AtomicAdd(ref UInt32x2 target, UInt32x2 value)
        {
            ref var elementRef = ref Unsafe.As<UInt32x2, uint>(
                ref target);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrX),
                value.X);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrY),
                value.Y);
        }

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        public UInt32x2 ComputeAverage(long denominator) =>
            this / FromScalar((uint)denominator);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt32x2 operator +(
            UInt32x2 current,
            UInt8x2 toAccumulate) =>
            current + ConvertFrom_byte(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt32x2 operator +(
            UInt8x2 toAccumulate,
            UInt32x2 current) =>
            ConvertFrom_byte(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt32x2 operator -(
            UInt32x2 current,
            UInt8x2 toAccumulate) =>
            current - ConvertFrom_byte(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt32x2 operator -(
            UInt8x2 toAccumulate,
            UInt32x2 current) =>
            ConvertFrom_byte(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref UInt32x2 target,
            UInt8x2 value) =>
            AtomicAdd(ref target, ConvertFrom_byte(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt32x2 ConvertFrom_byte(
            UInt8x2 other) =>
            new UInt32x2((uint)other.X, (uint)other.Y);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt8x2 ConvertTo_byte(
            UInt32x2 current) =>
            new UInt8x2((byte)current.X, (byte)current.Y);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt32x2 IAccumulationVectorType<
            UInt32x2,
            UInt8x2,
            byte>.ConvertFromBase(UInt8x2 other) =>
            ConvertFrom_byte(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt8x2 IAccumulationVectorType<
            UInt32x2,
            UInt8x2,
            byte>.ConvertToBase(UInt32x2 current) =>
            ConvertTo_byte(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public UInt32x2 ComputeAverage(byte denominator) =>
            this / FromScalar((uint)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt32x2 operator +(
            UInt32x2 current,
            UInt16x2 toAccumulate) =>
            current + ConvertFrom_ushort(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt32x2 operator +(
            UInt16x2 toAccumulate,
            UInt32x2 current) =>
            ConvertFrom_ushort(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt32x2 operator -(
            UInt32x2 current,
            UInt16x2 toAccumulate) =>
            current - ConvertFrom_ushort(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt32x2 operator -(
            UInt16x2 toAccumulate,
            UInt32x2 current) =>
            ConvertFrom_ushort(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref UInt32x2 target,
            UInt16x2 value) =>
            AtomicAdd(ref target, ConvertFrom_ushort(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt32x2 ConvertFrom_ushort(
            UInt16x2 other) =>
            new UInt32x2((uint)other.X, (uint)other.Y);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt16x2 ConvertTo_ushort(
            UInt32x2 current) =>
            new UInt16x2((ushort)current.X, (ushort)current.Y);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt32x2 IAccumulationVectorType<
            UInt32x2,
            UInt16x2,
            ushort>.ConvertFromBase(UInt16x2 other) =>
            ConvertFrom_ushort(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt16x2 IAccumulationVectorType<
            UInt32x2,
            UInt16x2,
            ushort>.ConvertToBase(UInt32x2 current) =>
            ConvertTo_ushort(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public UInt32x2 ComputeAverage(ushort denominator) =>
            this / FromScalar((uint)denominator);


        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt32x2 ConvertFrom_uint(
            UInt32x2 other) =>
            new UInt32x2((uint)other.X, (uint)other.Y);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt32x2 ConvertTo_uint(
            UInt32x2 current) =>
            new UInt32x2((uint)current.X, (uint)current.Y);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt32x2 IAccumulationVectorType<
            UInt32x2,
            UInt32x2,
            uint>.ConvertFromBase(UInt32x2 other) =>
            ConvertFrom_uint(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt32x2 IAccumulationVectorType<
            UInt32x2,
            UInt32x2,
            uint>.ConvertToBase(UInt32x2 current) =>
            ConvertTo_uint(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public UInt32x2 ComputeAverage(uint denominator) =>
            this / FromScalar((uint)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt32x2 operator +(
            UInt32x2 current,
            Float32x2 toAccumulate) =>
            current + ConvertFrom_float(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt32x2 operator +(
            Float32x2 toAccumulate,
            UInt32x2 current) =>
            ConvertFrom_float(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt32x2 operator -(
            UInt32x2 current,
            Float32x2 toAccumulate) =>
            current - ConvertFrom_float(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt32x2 operator -(
            Float32x2 toAccumulate,
            UInt32x2 current) =>
            ConvertFrom_float(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref UInt32x2 target,
            Float32x2 value) =>
            AtomicAdd(ref target, ConvertFrom_float(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt32x2 ConvertFrom_float(
            Float32x2 other) =>
            new UInt32x2((uint)other.X, (uint)other.Y);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float32x2 ConvertTo_float(
            UInt32x2 current) =>
            new Float32x2((float)current.X, (float)current.Y);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt32x2 IAccumulationVectorType<
            UInt32x2,
            Float32x2,
            float>.ConvertFromBase(Float32x2 other) =>
            ConvertFrom_float(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float32x2 IAccumulationVectorType<
            UInt32x2,
            Float32x2,
            float>.ConvertToBase(UInt32x2 current) =>
            ConvertTo_float(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public UInt32x2 ComputeAverage(float denominator) =>
            this / FromScalar((uint)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt32x2 operator +(
            UInt32x2 current,
            Float64x2 toAccumulate) =>
            current + ConvertFrom_double(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt32x2 operator +(
            Float64x2 toAccumulate,
            UInt32x2 current) =>
            ConvertFrom_double(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt32x2 operator -(
            UInt32x2 current,
            Float64x2 toAccumulate) =>
            current - ConvertFrom_double(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt32x2 operator -(
            Float64x2 toAccumulate,
            UInt32x2 current) =>
            ConvertFrom_double(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref UInt32x2 target,
            Float64x2 value) =>
            AtomicAdd(ref target, ConvertFrom_double(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt32x2 ConvertFrom_double(
            Float64x2 other) =>
            new UInt32x2((uint)other.X, (uint)other.Y);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float64x2 ConvertTo_double(
            UInt32x2 current) =>
            new Float64x2((double)current.X, (double)current.Y);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt32x2 IAccumulationVectorType<
            UInt32x2,
            Float64x2,
            double>.ConvertFromBase(Float64x2 other) =>
            ConvertFrom_double(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float64x2 IAccumulationVectorType<
            UInt32x2,
            Float64x2,
            double>.ConvertToBase(UInt32x2 current) =>
            ConvertTo_double(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public UInt32x2 ComputeAverage(double denominator) =>
            this / FromScalar((uint)denominator);

        /// <summary>
        /// Converts this instance into an unsafe span instance.
        /// </summary>
        /// <returns>The readonly span instance.</returns>
        public unsafe ReadOnlySpan<uint> AsSpan() =>
            new(Unsafe.AsPointer(ref Unsafe.AsRef(this)), 2);

        /// <summary>
        /// Iterates over all elements by applying the given iterator to each element.
        /// </summary>
        /// <typeparam name="TIterator">The managed iterator type.</typeparam>
        /// <param name="iterator">The iterator to invoke.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ForEach<TIterator>(ref TIterator iterator)
            where TIterator : struct, IVectorElementIterator<
            UInt32x2,
            uint>
        {
            iterator.Iterate(X, 0);
            iterator.Iterate(Y, 1);
        }

        /// <summary>
        /// Converts this vector instance to a string.
        /// </summary>
        public override string ToString() =>
            $"{X}, {Y}";

        /// <summary>
        /// Converts this vector instance to a string.
        /// </summary>
        public string ToString(string? format, IFormatProvider? formatProvider) =>
            $"{X.ToString(format, formatProvider)}, {Y.ToString(format, formatProvider)}";

        /// <summary>
        /// Returns true.
        /// </summary>
        public static bool IsCanonical(UInt32x2 value) => true;

        /// <summary>
        /// Returns false.
        /// </summary>
        public static bool IsComplexNumber(UInt32x2 value) => false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsEvenInteger(UInt32x2 value) =>
            uint.IsEvenInteger(value.X) & uint.IsEvenInteger(value.Y);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsFinite(UInt32x2 value) =>
            true;

        /// <summary>
        /// Returns false.
        /// </summary>
        public static bool IsImaginaryNumber(UInt32x2 value) => false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsInfinity(UInt32x2 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsInteger(UInt32x2 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNaN(UInt32x2 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNegative(UInt32x2 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNegativeInfinity(UInt32x2 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNormal(UInt32x2 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsOddInteger(UInt32x2 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsPositive(UInt32x2 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsPositiveInfinity(UInt32x2 value) =>
            false;

        /// <summary>
        /// Returns true.
        /// </summary>
        public static bool IsRealNumber(UInt32x2 value) => true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsSubnormal(UInt32x2 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsZero(UInt32x2 value) =>
            value == Zero;

        /// <summary>
        /// Returns the absolute value.
        /// </summary>
        public static UInt32x2 Abs(UInt32x2 value) =>
            value;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt32x2 operator +(UInt32x2 left, UInt32x2 right) =>
            new UInt32x2((uint)(left.X + right.X), (uint)(left.Y + right.Y));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt32x2 operator --(UInt32x2 value) => value - One;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt32x2 operator /(UInt32x2 left, UInt32x2 right) =>
            new UInt32x2((uint)(left.X / right.X), (uint)(left.Y / right.Y));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt32x2 operator ++(UInt32x2 value) => value + One;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt32x2 operator *(UInt32x2 left, UInt32x2 right) =>
            new UInt32x2((uint)(left.X * right.X), (uint)(left.Y * right.Y));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt32x2 operator -(UInt32x2 left, UInt32x2 right) =>
            new UInt32x2((uint)(left.X - right.X), (uint)(left.Y - right.Y));

        /// <summary>
        /// Not supported operation.
        /// </summary>
        static UInt32x2 IUnaryNegationOperators<UInt32x2, UInt32x2>.
            operator -(UInt32x2 value) => value;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt32x2 operator +(UInt32x2 value) => value;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt32x2 MaxMagnitude(UInt32x2 x, UInt32x2 y) =>
            Max(x, y);

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt32x2 MaxMagnitudeNumber(UInt32x2 x, UInt32x2 y) =>
            MaxMagnitude(x, y);

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt32x2 MinMagnitude(UInt32x2 x, UInt32x2 y) =>
            Min(x, y);

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt32x2 MinMagnitudeNumber(UInt32x2 x, UInt32x2 y) =>
            MinMagnitude(x, y);

        // Not supported operations

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static UInt32x2 IParsable<UInt32x2>.Parse(
            string s,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static UInt32x2 ISpanParsable<UInt32x2>.Parse(
            ReadOnlySpan<char> s,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static UInt32x2 INumberBase<UInt32x2>.Parse(
            ReadOnlySpan<char> s,
            NumberStyles style,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static UInt32x2 INumberBase<UInt32x2>.Parse(
            string s,
            NumberStyles style,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        bool ISpanFormattable.TryFormat(
            Span<char> destination,
            out int charsWritten,
            ReadOnlySpan<char> format,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool IParsable<UInt32x2>.TryParse(
            string? s,
            IFormatProvider? provider,
            out UInt32x2 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given span into a vectorized instance.
        /// </summary>
        static bool ISpanParsable<UInt32x2>.TryParse(
            ReadOnlySpan<char> s,
            IFormatProvider? provider,
            out UInt32x2 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool INumberBase<UInt32x2>.TryParse(
            ReadOnlySpan<char> s,
            NumberStyles style,
            IFormatProvider? provider,
            out UInt32x2 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool INumberBase<UInt32x2>.TryParse(
            string? s,
            NumberStyles style,
            IFormatProvider? provider,
            out UInt32x2 result) =>
            throw new NotSupportedException();

        static bool INumberBase<UInt32x2>.TryConvertFromChecked<TOther>(
            TOther value,
            out UInt32x2 result) =>
            throw new NotSupportedException();
        static bool INumberBase<UInt32x2>.TryConvertFromSaturating<TOther>(
            TOther value,
            out UInt32x2 result) =>
            throw new NotSupportedException();
        static bool INumberBase<UInt32x2>.TryConvertFromTruncating<TOther>(
            TOther value,
            out UInt32x2 result) =>
            throw new NotSupportedException();
        static bool INumberBase<UInt32x2>.TryConvertToChecked<TOther>(
            UInt32x2 value,
            out TOther result) =>
            throw new NotSupportedException();
        static bool INumberBase<UInt32x2>.TryConvertToSaturating<TOther>(
            UInt32x2 value,
            out TOther result) =>
            throw new NotSupportedException();
        static bool INumberBase<UInt32x2>.TryConvertToTruncating<TOther>(
            UInt32x2 value,
            out TOther result) =>
            throw new NotSupportedException();
    }

    /// <summary>
    /// Represents a vectorized uint type with length 4.
    /// </summary>
    [CLSCompliant(false)]
    public readonly record struct UInt32x4(
        uint X, uint Y, uint Z, uint W) :
        IVectorType<UInt32x4, uint>
        , IAccumulationVectorType<
            UInt32x4,
            UInt8x4,
            byte>
        , IAccumulationVectorType<
            UInt32x4,
            UInt16x4,
            ushort>
        , IAccumulationVectorType<
            UInt32x4,
            UInt32x4,
            uint>
        , IAccumulationVectorType<
            UInt32x4,
            Float32x4,
            float>
        , IAccumulationVectorType<
            UInt32x4,
            Float64x4,
            double>
    {
        /// <summary>
        /// The offset of the X field in bytes.
        /// </summary>
        public static readonly int OffsetX =
            sizeof(uint) * 0;

        /// <summary>
        /// The offset of the X field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrX =>
            new UIntPtr((uint)OffsetX);
        /// <summary>
        /// The offset of the Y field in bytes.
        /// </summary>
        public static readonly int OffsetY =
            sizeof(uint) * 1;

        /// <summary>
        /// The offset of the Y field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrY =>
            new UIntPtr((uint)OffsetY);
        /// <summary>
        /// The offset of the Z field in bytes.
        /// </summary>
        public static readonly int OffsetZ =
            sizeof(uint) * 2;

        /// <summary>
        /// The offset of the Z field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrZ =>
            new UIntPtr((uint)OffsetZ);
        /// <summary>
        /// The offset of the W field in bytes.
        /// </summary>
        public static readonly int OffsetW =
            sizeof(uint) * 3;

        /// <summary>
        /// The offset of the W field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrW =>
            new UIntPtr((uint)OffsetW);

        /// <summary>
        /// Returns the length of this vector which is 4.
        /// </summary>
        public static int Length => 4;

        /// <summary>
        /// Returns the radix of the underlying value.
        /// </summary>
        public static int Radix => 10;

        /// <summary>
        /// Returns an invalid value (min [signed types], max value [unsigned] or NaN).
        /// </summary>
        public static UInt32x4 Invalid => FromScalar(
            uint.MaxValue
        );

        /// <summary>
        /// Returns the value zero.
        /// </summary>
        public static UInt32x4 Zero => new();

        /// <summary>
        /// Returns the value one.
        /// </summary>
        public static UInt32x4 One => FromScalar((1));

        /// <summary>
        /// Returns the value zero.
        /// </summary>
        public static UInt32x4 AdditiveIdentity => Zero;

        /// <summary>
        /// Returns the value one.
        /// </summary>
        public static UInt32x4 MultiplicativeIdentity => One;

        /// <summary>
        /// Computes the min value of both.
        /// </summary>
        /// <param name="first">The first value.</param>
        /// <param name="second">The second value.</param>
        /// <returns>The min value.</returns>
        public static UInt32x4 Min(
            UInt32x4 first,
            UInt32x4 second) =>
            new UInt32x4((uint)Math.Min(first.X, second.X), (uint)Math.Min(first.Y, second.Y), (uint)Math.Min(first.Z, second.Z), (uint)Math.Min(first.W, second.W));

        /// <summary>
        /// Computes the max value of both.
        /// </summary>
        /// <param name="first">The first value.</param>
        /// <param name="second">The second value.</param>
        /// <returns>The max value.</returns>
        public static UInt32x4 Max(
            UInt32x4 first,
            UInt32x4 second) =>
            new UInt32x4((uint)Math.Max(first.X, second.X), (uint)Math.Max(first.Y, second.Y), (uint)Math.Max(first.Z, second.Z), (uint)Math.Max(first.W, second.W));

        /// <summary>
        /// Clamps the given value.
        /// </summary>
        /// <param name="value">The value to clamp.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The clamped value.</returns>
        public static UInt32x4 Clamp(
            UInt32x4 value,
            UInt32x4 min,
            UInt32x4 max) =>
            Max(Min(value, max), min);

        /// <summary>
        /// Creates a random scalar instance falling into the range of min max.
        /// </summary>
        /// <param name="random">The random provider to use.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The created random scalar instance.</returns>
        public static uint GetRandomScalar<TRandom>(
            ref TRandom random,
            uint min,
            uint max)
            where TRandom : struct, IRandomProvider =>
            (uint)RandomExtensions.
                Next(ref random, min, max);

        /// <summary>
        /// Creates a random vector instance falling into the range of min max.
        /// </summary>
        /// <param name="random">The random provider to use.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The created random vector instance.</returns>
        public static UInt32x4 GetRandom<TRandom>(
            ref TRandom random,
            UInt32x4 min,
            UInt32x4 max)
            where TRandom : struct, IRandomProvider
        {
            uint x = GetRandomScalar(
                ref random, min.X, max.X);
            uint y = GetRandomScalar(
                ref random, min.Y, max.Y);
            uint z = GetRandomScalar(
                ref random, min.Z, max.Z);
            uint w = GetRandomScalar(
                ref random, min.W, max.W);
            return new UInt32x4(x, y, z, w);
        }

        /// <summary>
        /// Creates a vector instance from the given source view.
        /// </summary>
        /// <typeparam name="TStride">The custom stride type.</typeparam>
        /// <param name="sourceView">The source view.</param>
        /// <param name="index">The source base index.</param>
        /// <returns>The vector instance.</returns>
        public static UInt32x4 FromElementView<TStride>(
            ArrayView1D<uint, TStride> sourceView,
            Index1D index)
            where TStride : struct, IStride1D =>
            new UInt32x4(
                sourceView[index + 0],
                sourceView[index + 1],
                sourceView[index + 2],
                sourceView[index + 3]
                );

        /// <summary>
        /// Serializes the current vector instance into the given target view.
        /// </summary>
        /// <typeparam name="TStride">The custom stride type.</typeparam>
        /// <param name="targetView">The target view.</param>
        /// <param name="index">The target base index.</param>
        public void ToElementView<TStride>(
            ArrayView1D<uint, TStride> targetView,
            Index1D index)
            where TStride : struct, IStride1D
        {
            targetView[index + 0] = X;
            targetView[index + 1] = Y;
            targetView[index + 2] = Z;
            targetView[index + 3] = W;
        }

        /// <summary>
        /// Creates a vector instance from the given source view.
        /// </summary>
        /// <param name="sourceView">The source view.</param>
        /// <param name="index">The source base index.</param>
        /// <returns>The vector instance.</returns>
        public static UInt32x4 FromElementView(
            SingleVectorView<uint> sourceView,
            Index1D index) =>
            new UInt32x4(
                sourceView[index + 0],
                sourceView[index + 1],
                sourceView[index + 2],
                sourceView[index + 3]
                );

        /// <summary>
        /// Serializes the current vector instance into the given target view.
        /// </summary>
        /// <param name="targetView">The target view.</param>
        /// <param name="index">The target base index.</param>
        public void ToElementView(
            SingleVectorView<uint> targetView,
            Index1D index)
        {
            targetView[index + 0] = X;
            targetView[index + 1] = Y;
            targetView[index + 2] = Z;
            targetView[index + 3] = W;
        }

        /// <summary>
        /// Converts a scalar value into the current vectorized type.
        /// </summary>
        /// <param name="scalar">The scalar element type.</param>
        /// <returns>The created vectorized type.</returns>
        public static UInt32x4 FromScalar(uint scalar) =>
            new UInt32x4(scalar, scalar, scalar, scalar);

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        public static void AtomicAdd(ref UInt32x4 target, UInt32x4 value)
        {
            ref var elementRef = ref Unsafe.As<UInt32x4, uint>(
                ref target);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrX),
                value.X);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrY),
                value.Y);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrZ),
                value.Z);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrW),
                value.W);
        }

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        public UInt32x4 ComputeAverage(long denominator) =>
            this / FromScalar((uint)denominator);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt32x4 operator +(
            UInt32x4 current,
            UInt8x4 toAccumulate) =>
            current + ConvertFrom_byte(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt32x4 operator +(
            UInt8x4 toAccumulate,
            UInt32x4 current) =>
            ConvertFrom_byte(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt32x4 operator -(
            UInt32x4 current,
            UInt8x4 toAccumulate) =>
            current - ConvertFrom_byte(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt32x4 operator -(
            UInt8x4 toAccumulate,
            UInt32x4 current) =>
            ConvertFrom_byte(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref UInt32x4 target,
            UInt8x4 value) =>
            AtomicAdd(ref target, ConvertFrom_byte(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt32x4 ConvertFrom_byte(
            UInt8x4 other) =>
            new UInt32x4((uint)other.X, (uint)other.Y, (uint)other.Z, (uint)other.W);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt8x4 ConvertTo_byte(
            UInt32x4 current) =>
            new UInt8x4((byte)current.X, (byte)current.Y, (byte)current.Z, (byte)current.W);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt32x4 IAccumulationVectorType<
            UInt32x4,
            UInt8x4,
            byte>.ConvertFromBase(UInt8x4 other) =>
            ConvertFrom_byte(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt8x4 IAccumulationVectorType<
            UInt32x4,
            UInt8x4,
            byte>.ConvertToBase(UInt32x4 current) =>
            ConvertTo_byte(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public UInt32x4 ComputeAverage(byte denominator) =>
            this / FromScalar((uint)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt32x4 operator +(
            UInt32x4 current,
            UInt16x4 toAccumulate) =>
            current + ConvertFrom_ushort(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt32x4 operator +(
            UInt16x4 toAccumulate,
            UInt32x4 current) =>
            ConvertFrom_ushort(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt32x4 operator -(
            UInt32x4 current,
            UInt16x4 toAccumulate) =>
            current - ConvertFrom_ushort(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt32x4 operator -(
            UInt16x4 toAccumulate,
            UInt32x4 current) =>
            ConvertFrom_ushort(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref UInt32x4 target,
            UInt16x4 value) =>
            AtomicAdd(ref target, ConvertFrom_ushort(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt32x4 ConvertFrom_ushort(
            UInt16x4 other) =>
            new UInt32x4((uint)other.X, (uint)other.Y, (uint)other.Z, (uint)other.W);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt16x4 ConvertTo_ushort(
            UInt32x4 current) =>
            new UInt16x4((ushort)current.X, (ushort)current.Y, (ushort)current.Z, (ushort)current.W);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt32x4 IAccumulationVectorType<
            UInt32x4,
            UInt16x4,
            ushort>.ConvertFromBase(UInt16x4 other) =>
            ConvertFrom_ushort(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt16x4 IAccumulationVectorType<
            UInt32x4,
            UInt16x4,
            ushort>.ConvertToBase(UInt32x4 current) =>
            ConvertTo_ushort(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public UInt32x4 ComputeAverage(ushort denominator) =>
            this / FromScalar((uint)denominator);


        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt32x4 ConvertFrom_uint(
            UInt32x4 other) =>
            new UInt32x4((uint)other.X, (uint)other.Y, (uint)other.Z, (uint)other.W);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt32x4 ConvertTo_uint(
            UInt32x4 current) =>
            new UInt32x4((uint)current.X, (uint)current.Y, (uint)current.Z, (uint)current.W);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt32x4 IAccumulationVectorType<
            UInt32x4,
            UInt32x4,
            uint>.ConvertFromBase(UInt32x4 other) =>
            ConvertFrom_uint(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt32x4 IAccumulationVectorType<
            UInt32x4,
            UInt32x4,
            uint>.ConvertToBase(UInt32x4 current) =>
            ConvertTo_uint(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public UInt32x4 ComputeAverage(uint denominator) =>
            this / FromScalar((uint)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt32x4 operator +(
            UInt32x4 current,
            Float32x4 toAccumulate) =>
            current + ConvertFrom_float(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt32x4 operator +(
            Float32x4 toAccumulate,
            UInt32x4 current) =>
            ConvertFrom_float(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt32x4 operator -(
            UInt32x4 current,
            Float32x4 toAccumulate) =>
            current - ConvertFrom_float(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt32x4 operator -(
            Float32x4 toAccumulate,
            UInt32x4 current) =>
            ConvertFrom_float(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref UInt32x4 target,
            Float32x4 value) =>
            AtomicAdd(ref target, ConvertFrom_float(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt32x4 ConvertFrom_float(
            Float32x4 other) =>
            new UInt32x4((uint)other.X, (uint)other.Y, (uint)other.Z, (uint)other.W);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float32x4 ConvertTo_float(
            UInt32x4 current) =>
            new Float32x4((float)current.X, (float)current.Y, (float)current.Z, (float)current.W);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt32x4 IAccumulationVectorType<
            UInt32x4,
            Float32x4,
            float>.ConvertFromBase(Float32x4 other) =>
            ConvertFrom_float(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float32x4 IAccumulationVectorType<
            UInt32x4,
            Float32x4,
            float>.ConvertToBase(UInt32x4 current) =>
            ConvertTo_float(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public UInt32x4 ComputeAverage(float denominator) =>
            this / FromScalar((uint)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt32x4 operator +(
            UInt32x4 current,
            Float64x4 toAccumulate) =>
            current + ConvertFrom_double(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt32x4 operator +(
            Float64x4 toAccumulate,
            UInt32x4 current) =>
            ConvertFrom_double(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt32x4 operator -(
            UInt32x4 current,
            Float64x4 toAccumulate) =>
            current - ConvertFrom_double(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt32x4 operator -(
            Float64x4 toAccumulate,
            UInt32x4 current) =>
            ConvertFrom_double(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref UInt32x4 target,
            Float64x4 value) =>
            AtomicAdd(ref target, ConvertFrom_double(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt32x4 ConvertFrom_double(
            Float64x4 other) =>
            new UInt32x4((uint)other.X, (uint)other.Y, (uint)other.Z, (uint)other.W);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float64x4 ConvertTo_double(
            UInt32x4 current) =>
            new Float64x4((double)current.X, (double)current.Y, (double)current.Z, (double)current.W);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt32x4 IAccumulationVectorType<
            UInt32x4,
            Float64x4,
            double>.ConvertFromBase(Float64x4 other) =>
            ConvertFrom_double(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float64x4 IAccumulationVectorType<
            UInt32x4,
            Float64x4,
            double>.ConvertToBase(UInt32x4 current) =>
            ConvertTo_double(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public UInt32x4 ComputeAverage(double denominator) =>
            this / FromScalar((uint)denominator);

        /// <summary>
        /// Converts this instance into an unsafe span instance.
        /// </summary>
        /// <returns>The readonly span instance.</returns>
        public unsafe ReadOnlySpan<uint> AsSpan() =>
            new(Unsafe.AsPointer(ref Unsafe.AsRef(this)), 4);

        /// <summary>
        /// Iterates over all elements by applying the given iterator to each element.
        /// </summary>
        /// <typeparam name="TIterator">The managed iterator type.</typeparam>
        /// <param name="iterator">The iterator to invoke.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ForEach<TIterator>(ref TIterator iterator)
            where TIterator : struct, IVectorElementIterator<
            UInt32x4,
            uint>
        {
            iterator.Iterate(X, 0);
            iterator.Iterate(Y, 1);
            iterator.Iterate(Z, 2);
            iterator.Iterate(W, 3);
        }

        /// <summary>
        /// Converts this vector instance to a string.
        /// </summary>
        public override string ToString() =>
            $"{X}, {Y}, {Z}, {W}";

        /// <summary>
        /// Converts this vector instance to a string.
        /// </summary>
        public string ToString(string? format, IFormatProvider? formatProvider) =>
            $"{X.ToString(format, formatProvider)}, {Y.ToString(format, formatProvider)}, {Z.ToString(format, formatProvider)}, {W.ToString(format, formatProvider)}";

        /// <summary>
        /// Returns true.
        /// </summary>
        public static bool IsCanonical(UInt32x4 value) => true;

        /// <summary>
        /// Returns false.
        /// </summary>
        public static bool IsComplexNumber(UInt32x4 value) => false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsEvenInteger(UInt32x4 value) =>
            uint.IsEvenInteger(value.X) & uint.IsEvenInteger(value.Y) & uint.IsEvenInteger(value.Z) & uint.IsEvenInteger(value.W);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsFinite(UInt32x4 value) =>
            true;

        /// <summary>
        /// Returns false.
        /// </summary>
        public static bool IsImaginaryNumber(UInt32x4 value) => false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsInfinity(UInt32x4 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsInteger(UInt32x4 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNaN(UInt32x4 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNegative(UInt32x4 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNegativeInfinity(UInt32x4 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNormal(UInt32x4 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsOddInteger(UInt32x4 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsPositive(UInt32x4 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsPositiveInfinity(UInt32x4 value) =>
            false;

        /// <summary>
        /// Returns true.
        /// </summary>
        public static bool IsRealNumber(UInt32x4 value) => true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsSubnormal(UInt32x4 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsZero(UInt32x4 value) =>
            value == Zero;

        /// <summary>
        /// Returns the absolute value.
        /// </summary>
        public static UInt32x4 Abs(UInt32x4 value) =>
            value;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt32x4 operator +(UInt32x4 left, UInt32x4 right) =>
            new UInt32x4((uint)(left.X + right.X), (uint)(left.Y + right.Y), (uint)(left.Z + right.Z), (uint)(left.W + right.W));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt32x4 operator --(UInt32x4 value) => value - One;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt32x4 operator /(UInt32x4 left, UInt32x4 right) =>
            new UInt32x4((uint)(left.X / right.X), (uint)(left.Y / right.Y), (uint)(left.Z / right.Z), (uint)(left.W / right.W));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt32x4 operator ++(UInt32x4 value) => value + One;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt32x4 operator *(UInt32x4 left, UInt32x4 right) =>
            new UInt32x4((uint)(left.X * right.X), (uint)(left.Y * right.Y), (uint)(left.Z * right.Z), (uint)(left.W * right.W));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt32x4 operator -(UInt32x4 left, UInt32x4 right) =>
            new UInt32x4((uint)(left.X - right.X), (uint)(left.Y - right.Y), (uint)(left.Z - right.Z), (uint)(left.W - right.W));

        /// <summary>
        /// Not supported operation.
        /// </summary>
        static UInt32x4 IUnaryNegationOperators<UInt32x4, UInt32x4>.
            operator -(UInt32x4 value) => value;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt32x4 operator +(UInt32x4 value) => value;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt32x4 MaxMagnitude(UInt32x4 x, UInt32x4 y) =>
            Max(x, y);

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt32x4 MaxMagnitudeNumber(UInt32x4 x, UInt32x4 y) =>
            MaxMagnitude(x, y);

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt32x4 MinMagnitude(UInt32x4 x, UInt32x4 y) =>
            Min(x, y);

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt32x4 MinMagnitudeNumber(UInt32x4 x, UInt32x4 y) =>
            MinMagnitude(x, y);

        // Not supported operations

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static UInt32x4 IParsable<UInt32x4>.Parse(
            string s,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static UInt32x4 ISpanParsable<UInt32x4>.Parse(
            ReadOnlySpan<char> s,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static UInt32x4 INumberBase<UInt32x4>.Parse(
            ReadOnlySpan<char> s,
            NumberStyles style,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static UInt32x4 INumberBase<UInt32x4>.Parse(
            string s,
            NumberStyles style,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        bool ISpanFormattable.TryFormat(
            Span<char> destination,
            out int charsWritten,
            ReadOnlySpan<char> format,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool IParsable<UInt32x4>.TryParse(
            string? s,
            IFormatProvider? provider,
            out UInt32x4 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given span into a vectorized instance.
        /// </summary>
        static bool ISpanParsable<UInt32x4>.TryParse(
            ReadOnlySpan<char> s,
            IFormatProvider? provider,
            out UInt32x4 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool INumberBase<UInt32x4>.TryParse(
            ReadOnlySpan<char> s,
            NumberStyles style,
            IFormatProvider? provider,
            out UInt32x4 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool INumberBase<UInt32x4>.TryParse(
            string? s,
            NumberStyles style,
            IFormatProvider? provider,
            out UInt32x4 result) =>
            throw new NotSupportedException();

        static bool INumberBase<UInt32x4>.TryConvertFromChecked<TOther>(
            TOther value,
            out UInt32x4 result) =>
            throw new NotSupportedException();
        static bool INumberBase<UInt32x4>.TryConvertFromSaturating<TOther>(
            TOther value,
            out UInt32x4 result) =>
            throw new NotSupportedException();
        static bool INumberBase<UInt32x4>.TryConvertFromTruncating<TOther>(
            TOther value,
            out UInt32x4 result) =>
            throw new NotSupportedException();
        static bool INumberBase<UInt32x4>.TryConvertToChecked<TOther>(
            UInt32x4 value,
            out TOther result) =>
            throw new NotSupportedException();
        static bool INumberBase<UInt32x4>.TryConvertToSaturating<TOther>(
            UInt32x4 value,
            out TOther result) =>
            throw new NotSupportedException();
        static bool INumberBase<UInt32x4>.TryConvertToTruncating<TOther>(
            UInt32x4 value,
            out TOther result) =>
            throw new NotSupportedException();
    }

    /// <summary>
    /// Represents a vectorized uint type with length 8.
    /// </summary>
    [CLSCompliant(false)]
    public readonly record struct UInt32x8(
        uint X, uint Y, uint Z, uint W, uint I, uint J, uint K, uint L) :
        IVectorType<UInt32x8, uint>
        , IAccumulationVectorType<
            UInt32x8,
            UInt8x8,
            byte>
        , IAccumulationVectorType<
            UInt32x8,
            UInt16x8,
            ushort>
        , IAccumulationVectorType<
            UInt32x8,
            UInt32x8,
            uint>
        , IAccumulationVectorType<
            UInt32x8,
            Float32x8,
            float>
        , IAccumulationVectorType<
            UInt32x8,
            Float64x8,
            double>
    {
        /// <summary>
        /// The offset of the X field in bytes.
        /// </summary>
        public static readonly int OffsetX =
            sizeof(uint) * 0;

        /// <summary>
        /// The offset of the X field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrX =>
            new UIntPtr((uint)OffsetX);
        /// <summary>
        /// The offset of the Y field in bytes.
        /// </summary>
        public static readonly int OffsetY =
            sizeof(uint) * 1;

        /// <summary>
        /// The offset of the Y field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrY =>
            new UIntPtr((uint)OffsetY);
        /// <summary>
        /// The offset of the Z field in bytes.
        /// </summary>
        public static readonly int OffsetZ =
            sizeof(uint) * 2;

        /// <summary>
        /// The offset of the Z field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrZ =>
            new UIntPtr((uint)OffsetZ);
        /// <summary>
        /// The offset of the W field in bytes.
        /// </summary>
        public static readonly int OffsetW =
            sizeof(uint) * 3;

        /// <summary>
        /// The offset of the W field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrW =>
            new UIntPtr((uint)OffsetW);
        /// <summary>
        /// The offset of the I field in bytes.
        /// </summary>
        public static readonly int OffsetI =
            sizeof(uint) * 4;

        /// <summary>
        /// The offset of the I field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrI =>
            new UIntPtr((uint)OffsetI);
        /// <summary>
        /// The offset of the J field in bytes.
        /// </summary>
        public static readonly int OffsetJ =
            sizeof(uint) * 5;

        /// <summary>
        /// The offset of the J field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrJ =>
            new UIntPtr((uint)OffsetJ);
        /// <summary>
        /// The offset of the K field in bytes.
        /// </summary>
        public static readonly int OffsetK =
            sizeof(uint) * 6;

        /// <summary>
        /// The offset of the K field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrK =>
            new UIntPtr((uint)OffsetK);
        /// <summary>
        /// The offset of the L field in bytes.
        /// </summary>
        public static readonly int OffsetL =
            sizeof(uint) * 7;

        /// <summary>
        /// The offset of the L field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrL =>
            new UIntPtr((uint)OffsetL);

        /// <summary>
        /// Returns the length of this vector which is 8.
        /// </summary>
        public static int Length => 8;

        /// <summary>
        /// Returns the radix of the underlying value.
        /// </summary>
        public static int Radix => 10;

        /// <summary>
        /// Returns an invalid value (min [signed types], max value [unsigned] or NaN).
        /// </summary>
        public static UInt32x8 Invalid => FromScalar(
            uint.MaxValue
        );

        /// <summary>
        /// Returns the value zero.
        /// </summary>
        public static UInt32x8 Zero => new();

        /// <summary>
        /// Returns the value one.
        /// </summary>
        public static UInt32x8 One => FromScalar((1));

        /// <summary>
        /// Returns the value zero.
        /// </summary>
        public static UInt32x8 AdditiveIdentity => Zero;

        /// <summary>
        /// Returns the value one.
        /// </summary>
        public static UInt32x8 MultiplicativeIdentity => One;

        /// <summary>
        /// Computes the min value of both.
        /// </summary>
        /// <param name="first">The first value.</param>
        /// <param name="second">The second value.</param>
        /// <returns>The min value.</returns>
        public static UInt32x8 Min(
            UInt32x8 first,
            UInt32x8 second) =>
            new UInt32x8((uint)Math.Min(first.X, second.X), (uint)Math.Min(first.Y, second.Y), (uint)Math.Min(first.Z, second.Z), (uint)Math.Min(first.W, second.W), (uint)Math.Min(first.I, second.I), (uint)Math.Min(first.J, second.J), (uint)Math.Min(first.K, second.K), (uint)Math.Min(first.L, second.L));

        /// <summary>
        /// Computes the max value of both.
        /// </summary>
        /// <param name="first">The first value.</param>
        /// <param name="second">The second value.</param>
        /// <returns>The max value.</returns>
        public static UInt32x8 Max(
            UInt32x8 first,
            UInt32x8 second) =>
            new UInt32x8((uint)Math.Max(first.X, second.X), (uint)Math.Max(first.Y, second.Y), (uint)Math.Max(first.Z, second.Z), (uint)Math.Max(first.W, second.W), (uint)Math.Max(first.I, second.I), (uint)Math.Max(first.J, second.J), (uint)Math.Max(first.K, second.K), (uint)Math.Max(first.L, second.L));

        /// <summary>
        /// Clamps the given value.
        /// </summary>
        /// <param name="value">The value to clamp.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The clamped value.</returns>
        public static UInt32x8 Clamp(
            UInt32x8 value,
            UInt32x8 min,
            UInt32x8 max) =>
            Max(Min(value, max), min);

        /// <summary>
        /// Creates a random scalar instance falling into the range of min max.
        /// </summary>
        /// <param name="random">The random provider to use.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The created random scalar instance.</returns>
        public static uint GetRandomScalar<TRandom>(
            ref TRandom random,
            uint min,
            uint max)
            where TRandom : struct, IRandomProvider =>
            (uint)RandomExtensions.
                Next(ref random, min, max);

        /// <summary>
        /// Creates a random vector instance falling into the range of min max.
        /// </summary>
        /// <param name="random">The random provider to use.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The created random vector instance.</returns>
        public static UInt32x8 GetRandom<TRandom>(
            ref TRandom random,
            UInt32x8 min,
            UInt32x8 max)
            where TRandom : struct, IRandomProvider
        {
            uint x = GetRandomScalar(
                ref random, min.X, max.X);
            uint y = GetRandomScalar(
                ref random, min.Y, max.Y);
            uint z = GetRandomScalar(
                ref random, min.Z, max.Z);
            uint w = GetRandomScalar(
                ref random, min.W, max.W);
            uint i = GetRandomScalar(
                ref random, min.I, max.I);
            uint j = GetRandomScalar(
                ref random, min.J, max.J);
            uint k = GetRandomScalar(
                ref random, min.K, max.K);
            uint l = GetRandomScalar(
                ref random, min.L, max.L);
            return new UInt32x8(x, y, z, w, i, j, k, l);
        }

        /// <summary>
        /// Creates a vector instance from the given source view.
        /// </summary>
        /// <typeparam name="TStride">The custom stride type.</typeparam>
        /// <param name="sourceView">The source view.</param>
        /// <param name="index">The source base index.</param>
        /// <returns>The vector instance.</returns>
        public static UInt32x8 FromElementView<TStride>(
            ArrayView1D<uint, TStride> sourceView,
            Index1D index)
            where TStride : struct, IStride1D =>
            new UInt32x8(
                sourceView[index + 0],
                sourceView[index + 1],
                sourceView[index + 2],
                sourceView[index + 3],
                sourceView[index + 4],
                sourceView[index + 5],
                sourceView[index + 6],
                sourceView[index + 7]
                );

        /// <summary>
        /// Serializes the current vector instance into the given target view.
        /// </summary>
        /// <typeparam name="TStride">The custom stride type.</typeparam>
        /// <param name="targetView">The target view.</param>
        /// <param name="index">The target base index.</param>
        public void ToElementView<TStride>(
            ArrayView1D<uint, TStride> targetView,
            Index1D index)
            where TStride : struct, IStride1D
        {
            targetView[index + 0] = X;
            targetView[index + 1] = Y;
            targetView[index + 2] = Z;
            targetView[index + 3] = W;
            targetView[index + 4] = I;
            targetView[index + 5] = J;
            targetView[index + 6] = K;
            targetView[index + 7] = L;
        }

        /// <summary>
        /// Creates a vector instance from the given source view.
        /// </summary>
        /// <param name="sourceView">The source view.</param>
        /// <param name="index">The source base index.</param>
        /// <returns>The vector instance.</returns>
        public static UInt32x8 FromElementView(
            SingleVectorView<uint> sourceView,
            Index1D index) =>
            new UInt32x8(
                sourceView[index + 0],
                sourceView[index + 1],
                sourceView[index + 2],
                sourceView[index + 3],
                sourceView[index + 4],
                sourceView[index + 5],
                sourceView[index + 6],
                sourceView[index + 7]
                );

        /// <summary>
        /// Serializes the current vector instance into the given target view.
        /// </summary>
        /// <param name="targetView">The target view.</param>
        /// <param name="index">The target base index.</param>
        public void ToElementView(
            SingleVectorView<uint> targetView,
            Index1D index)
        {
            targetView[index + 0] = X;
            targetView[index + 1] = Y;
            targetView[index + 2] = Z;
            targetView[index + 3] = W;
            targetView[index + 4] = I;
            targetView[index + 5] = J;
            targetView[index + 6] = K;
            targetView[index + 7] = L;
        }

        /// <summary>
        /// Converts a scalar value into the current vectorized type.
        /// </summary>
        /// <param name="scalar">The scalar element type.</param>
        /// <returns>The created vectorized type.</returns>
        public static UInt32x8 FromScalar(uint scalar) =>
            new UInt32x8(scalar, scalar, scalar, scalar, scalar, scalar, scalar, scalar);

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        public static void AtomicAdd(ref UInt32x8 target, UInt32x8 value)
        {
            ref var elementRef = ref Unsafe.As<UInt32x8, uint>(
                ref target);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrX),
                value.X);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrY),
                value.Y);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrZ),
                value.Z);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrW),
                value.W);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrI),
                value.I);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrJ),
                value.J);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrK),
                value.K);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrL),
                value.L);
        }

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        public UInt32x8 ComputeAverage(long denominator) =>
            this / FromScalar((uint)denominator);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt32x8 operator +(
            UInt32x8 current,
            UInt8x8 toAccumulate) =>
            current + ConvertFrom_byte(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt32x8 operator +(
            UInt8x8 toAccumulate,
            UInt32x8 current) =>
            ConvertFrom_byte(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt32x8 operator -(
            UInt32x8 current,
            UInt8x8 toAccumulate) =>
            current - ConvertFrom_byte(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt32x8 operator -(
            UInt8x8 toAccumulate,
            UInt32x8 current) =>
            ConvertFrom_byte(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref UInt32x8 target,
            UInt8x8 value) =>
            AtomicAdd(ref target, ConvertFrom_byte(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt32x8 ConvertFrom_byte(
            UInt8x8 other) =>
            new UInt32x8((uint)other.X, (uint)other.Y, (uint)other.Z, (uint)other.W, (uint)other.I, (uint)other.J, (uint)other.K, (uint)other.L);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt8x8 ConvertTo_byte(
            UInt32x8 current) =>
            new UInt8x8((byte)current.X, (byte)current.Y, (byte)current.Z, (byte)current.W, (byte)current.I, (byte)current.J, (byte)current.K, (byte)current.L);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt32x8 IAccumulationVectorType<
            UInt32x8,
            UInt8x8,
            byte>.ConvertFromBase(UInt8x8 other) =>
            ConvertFrom_byte(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt8x8 IAccumulationVectorType<
            UInt32x8,
            UInt8x8,
            byte>.ConvertToBase(UInt32x8 current) =>
            ConvertTo_byte(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public UInt32x8 ComputeAverage(byte denominator) =>
            this / FromScalar((uint)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt32x8 operator +(
            UInt32x8 current,
            UInt16x8 toAccumulate) =>
            current + ConvertFrom_ushort(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt32x8 operator +(
            UInt16x8 toAccumulate,
            UInt32x8 current) =>
            ConvertFrom_ushort(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt32x8 operator -(
            UInt32x8 current,
            UInt16x8 toAccumulate) =>
            current - ConvertFrom_ushort(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt32x8 operator -(
            UInt16x8 toAccumulate,
            UInt32x8 current) =>
            ConvertFrom_ushort(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref UInt32x8 target,
            UInt16x8 value) =>
            AtomicAdd(ref target, ConvertFrom_ushort(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt32x8 ConvertFrom_ushort(
            UInt16x8 other) =>
            new UInt32x8((uint)other.X, (uint)other.Y, (uint)other.Z, (uint)other.W, (uint)other.I, (uint)other.J, (uint)other.K, (uint)other.L);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt16x8 ConvertTo_ushort(
            UInt32x8 current) =>
            new UInt16x8((ushort)current.X, (ushort)current.Y, (ushort)current.Z, (ushort)current.W, (ushort)current.I, (ushort)current.J, (ushort)current.K, (ushort)current.L);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt32x8 IAccumulationVectorType<
            UInt32x8,
            UInt16x8,
            ushort>.ConvertFromBase(UInt16x8 other) =>
            ConvertFrom_ushort(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt16x8 IAccumulationVectorType<
            UInt32x8,
            UInt16x8,
            ushort>.ConvertToBase(UInt32x8 current) =>
            ConvertTo_ushort(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public UInt32x8 ComputeAverage(ushort denominator) =>
            this / FromScalar((uint)denominator);


        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt32x8 ConvertFrom_uint(
            UInt32x8 other) =>
            new UInt32x8((uint)other.X, (uint)other.Y, (uint)other.Z, (uint)other.W, (uint)other.I, (uint)other.J, (uint)other.K, (uint)other.L);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt32x8 ConvertTo_uint(
            UInt32x8 current) =>
            new UInt32x8((uint)current.X, (uint)current.Y, (uint)current.Z, (uint)current.W, (uint)current.I, (uint)current.J, (uint)current.K, (uint)current.L);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt32x8 IAccumulationVectorType<
            UInt32x8,
            UInt32x8,
            uint>.ConvertFromBase(UInt32x8 other) =>
            ConvertFrom_uint(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt32x8 IAccumulationVectorType<
            UInt32x8,
            UInt32x8,
            uint>.ConvertToBase(UInt32x8 current) =>
            ConvertTo_uint(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public UInt32x8 ComputeAverage(uint denominator) =>
            this / FromScalar((uint)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt32x8 operator +(
            UInt32x8 current,
            Float32x8 toAccumulate) =>
            current + ConvertFrom_float(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt32x8 operator +(
            Float32x8 toAccumulate,
            UInt32x8 current) =>
            ConvertFrom_float(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt32x8 operator -(
            UInt32x8 current,
            Float32x8 toAccumulate) =>
            current - ConvertFrom_float(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt32x8 operator -(
            Float32x8 toAccumulate,
            UInt32x8 current) =>
            ConvertFrom_float(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref UInt32x8 target,
            Float32x8 value) =>
            AtomicAdd(ref target, ConvertFrom_float(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt32x8 ConvertFrom_float(
            Float32x8 other) =>
            new UInt32x8((uint)other.X, (uint)other.Y, (uint)other.Z, (uint)other.W, (uint)other.I, (uint)other.J, (uint)other.K, (uint)other.L);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float32x8 ConvertTo_float(
            UInt32x8 current) =>
            new Float32x8((float)current.X, (float)current.Y, (float)current.Z, (float)current.W, (float)current.I, (float)current.J, (float)current.K, (float)current.L);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt32x8 IAccumulationVectorType<
            UInt32x8,
            Float32x8,
            float>.ConvertFromBase(Float32x8 other) =>
            ConvertFrom_float(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float32x8 IAccumulationVectorType<
            UInt32x8,
            Float32x8,
            float>.ConvertToBase(UInt32x8 current) =>
            ConvertTo_float(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public UInt32x8 ComputeAverage(float denominator) =>
            this / FromScalar((uint)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt32x8 operator +(
            UInt32x8 current,
            Float64x8 toAccumulate) =>
            current + ConvertFrom_double(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt32x8 operator +(
            Float64x8 toAccumulate,
            UInt32x8 current) =>
            ConvertFrom_double(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt32x8 operator -(
            UInt32x8 current,
            Float64x8 toAccumulate) =>
            current - ConvertFrom_double(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt32x8 operator -(
            Float64x8 toAccumulate,
            UInt32x8 current) =>
            ConvertFrom_double(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref UInt32x8 target,
            Float64x8 value) =>
            AtomicAdd(ref target, ConvertFrom_double(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt32x8 ConvertFrom_double(
            Float64x8 other) =>
            new UInt32x8((uint)other.X, (uint)other.Y, (uint)other.Z, (uint)other.W, (uint)other.I, (uint)other.J, (uint)other.K, (uint)other.L);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float64x8 ConvertTo_double(
            UInt32x8 current) =>
            new Float64x8((double)current.X, (double)current.Y, (double)current.Z, (double)current.W, (double)current.I, (double)current.J, (double)current.K, (double)current.L);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt32x8 IAccumulationVectorType<
            UInt32x8,
            Float64x8,
            double>.ConvertFromBase(Float64x8 other) =>
            ConvertFrom_double(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float64x8 IAccumulationVectorType<
            UInt32x8,
            Float64x8,
            double>.ConvertToBase(UInt32x8 current) =>
            ConvertTo_double(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public UInt32x8 ComputeAverage(double denominator) =>
            this / FromScalar((uint)denominator);

        /// <summary>
        /// Converts this instance into an unsafe span instance.
        /// </summary>
        /// <returns>The readonly span instance.</returns>
        public unsafe ReadOnlySpan<uint> AsSpan() =>
            new(Unsafe.AsPointer(ref Unsafe.AsRef(this)), 8);

        /// <summary>
        /// Iterates over all elements by applying the given iterator to each element.
        /// </summary>
        /// <typeparam name="TIterator">The managed iterator type.</typeparam>
        /// <param name="iterator">The iterator to invoke.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ForEach<TIterator>(ref TIterator iterator)
            where TIterator : struct, IVectorElementIterator<
            UInt32x8,
            uint>
        {
            iterator.Iterate(X, 0);
            iterator.Iterate(Y, 1);
            iterator.Iterate(Z, 2);
            iterator.Iterate(W, 3);
            iterator.Iterate(I, 4);
            iterator.Iterate(J, 5);
            iterator.Iterate(K, 6);
            iterator.Iterate(L, 7);
        }

        /// <summary>
        /// Converts this vector instance to a string.
        /// </summary>
        public override string ToString() =>
            $"{X}, {Y}, {Z}, {W}, {I}, {J}, {K}, {L}";

        /// <summary>
        /// Converts this vector instance to a string.
        /// </summary>
        public string ToString(string? format, IFormatProvider? formatProvider) =>
            $"{X.ToString(format, formatProvider)}, {Y.ToString(format, formatProvider)}, {Z.ToString(format, formatProvider)}, {W.ToString(format, formatProvider)}, {I.ToString(format, formatProvider)}, {J.ToString(format, formatProvider)}, {K.ToString(format, formatProvider)}, {L.ToString(format, formatProvider)}";

        /// <summary>
        /// Returns true.
        /// </summary>
        public static bool IsCanonical(UInt32x8 value) => true;

        /// <summary>
        /// Returns false.
        /// </summary>
        public static bool IsComplexNumber(UInt32x8 value) => false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsEvenInteger(UInt32x8 value) =>
            uint.IsEvenInteger(value.X) & uint.IsEvenInteger(value.Y) & uint.IsEvenInteger(value.Z) & uint.IsEvenInteger(value.W) & uint.IsEvenInteger(value.I) & uint.IsEvenInteger(value.J) & uint.IsEvenInteger(value.K) & uint.IsEvenInteger(value.L);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsFinite(UInt32x8 value) =>
            true;

        /// <summary>
        /// Returns false.
        /// </summary>
        public static bool IsImaginaryNumber(UInt32x8 value) => false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsInfinity(UInt32x8 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsInteger(UInt32x8 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNaN(UInt32x8 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNegative(UInt32x8 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNegativeInfinity(UInt32x8 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNormal(UInt32x8 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsOddInteger(UInt32x8 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsPositive(UInt32x8 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsPositiveInfinity(UInt32x8 value) =>
            false;

        /// <summary>
        /// Returns true.
        /// </summary>
        public static bool IsRealNumber(UInt32x8 value) => true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsSubnormal(UInt32x8 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsZero(UInt32x8 value) =>
            value == Zero;

        /// <summary>
        /// Returns the absolute value.
        /// </summary>
        public static UInt32x8 Abs(UInt32x8 value) =>
            value;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt32x8 operator +(UInt32x8 left, UInt32x8 right) =>
            new UInt32x8((uint)(left.X + right.X), (uint)(left.Y + right.Y), (uint)(left.Z + right.Z), (uint)(left.W + right.W), (uint)(left.I + right.I), (uint)(left.J + right.J), (uint)(left.K + right.K), (uint)(left.L + right.L));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt32x8 operator --(UInt32x8 value) => value - One;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt32x8 operator /(UInt32x8 left, UInt32x8 right) =>
            new UInt32x8((uint)(left.X / right.X), (uint)(left.Y / right.Y), (uint)(left.Z / right.Z), (uint)(left.W / right.W), (uint)(left.I / right.I), (uint)(left.J / right.J), (uint)(left.K / right.K), (uint)(left.L / right.L));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt32x8 operator ++(UInt32x8 value) => value + One;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt32x8 operator *(UInt32x8 left, UInt32x8 right) =>
            new UInt32x8((uint)(left.X * right.X), (uint)(left.Y * right.Y), (uint)(left.Z * right.Z), (uint)(left.W * right.W), (uint)(left.I * right.I), (uint)(left.J * right.J), (uint)(left.K * right.K), (uint)(left.L * right.L));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt32x8 operator -(UInt32x8 left, UInt32x8 right) =>
            new UInt32x8((uint)(left.X - right.X), (uint)(left.Y - right.Y), (uint)(left.Z - right.Z), (uint)(left.W - right.W), (uint)(left.I - right.I), (uint)(left.J - right.J), (uint)(left.K - right.K), (uint)(left.L - right.L));

        /// <summary>
        /// Not supported operation.
        /// </summary>
        static UInt32x8 IUnaryNegationOperators<UInt32x8, UInt32x8>.
            operator -(UInt32x8 value) => value;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt32x8 operator +(UInt32x8 value) => value;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt32x8 MaxMagnitude(UInt32x8 x, UInt32x8 y) =>
            Max(x, y);

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt32x8 MaxMagnitudeNumber(UInt32x8 x, UInt32x8 y) =>
            MaxMagnitude(x, y);

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt32x8 MinMagnitude(UInt32x8 x, UInt32x8 y) =>
            Min(x, y);

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt32x8 MinMagnitudeNumber(UInt32x8 x, UInt32x8 y) =>
            MinMagnitude(x, y);

        // Not supported operations

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static UInt32x8 IParsable<UInt32x8>.Parse(
            string s,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static UInt32x8 ISpanParsable<UInt32x8>.Parse(
            ReadOnlySpan<char> s,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static UInt32x8 INumberBase<UInt32x8>.Parse(
            ReadOnlySpan<char> s,
            NumberStyles style,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static UInt32x8 INumberBase<UInt32x8>.Parse(
            string s,
            NumberStyles style,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        bool ISpanFormattable.TryFormat(
            Span<char> destination,
            out int charsWritten,
            ReadOnlySpan<char> format,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool IParsable<UInt32x8>.TryParse(
            string? s,
            IFormatProvider? provider,
            out UInt32x8 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given span into a vectorized instance.
        /// </summary>
        static bool ISpanParsable<UInt32x8>.TryParse(
            ReadOnlySpan<char> s,
            IFormatProvider? provider,
            out UInt32x8 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool INumberBase<UInt32x8>.TryParse(
            ReadOnlySpan<char> s,
            NumberStyles style,
            IFormatProvider? provider,
            out UInt32x8 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool INumberBase<UInt32x8>.TryParse(
            string? s,
            NumberStyles style,
            IFormatProvider? provider,
            out UInt32x8 result) =>
            throw new NotSupportedException();

        static bool INumberBase<UInt32x8>.TryConvertFromChecked<TOther>(
            TOther value,
            out UInt32x8 result) =>
            throw new NotSupportedException();
        static bool INumberBase<UInt32x8>.TryConvertFromSaturating<TOther>(
            TOther value,
            out UInt32x8 result) =>
            throw new NotSupportedException();
        static bool INumberBase<UInt32x8>.TryConvertFromTruncating<TOther>(
            TOther value,
            out UInt32x8 result) =>
            throw new NotSupportedException();
        static bool INumberBase<UInt32x8>.TryConvertToChecked<TOther>(
            UInt32x8 value,
            out TOther result) =>
            throw new NotSupportedException();
        static bool INumberBase<UInt32x8>.TryConvertToSaturating<TOther>(
            UInt32x8 value,
            out TOther result) =>
            throw new NotSupportedException();
        static bool INumberBase<UInt32x8>.TryConvertToTruncating<TOther>(
            UInt32x8 value,
            out TOther result) =>
            throw new NotSupportedException();
    }

    /// <summary>
    /// Represents a vectorized ulong type with length 2.
    /// </summary>
    [CLSCompliant(false)]
    public readonly record struct UInt64x2(
        ulong X, ulong Y) :
        IVectorType<UInt64x2, ulong>
        , IAccumulationVectorType<
            UInt64x2,
            UInt8x2,
            byte>
        , IAccumulationVectorType<
            UInt64x2,
            UInt16x2,
            ushort>
        , IAccumulationVectorType<
            UInt64x2,
            UInt32x2,
            uint>
        , IAccumulationVectorType<
            UInt64x2,
            UInt64x2,
            ulong>
        , IAccumulationVectorType<
            UInt64x2,
            Float32x2,
            float>
        , IAccumulationVectorType<
            UInt64x2,
            Float64x2,
            double>
    {
        /// <summary>
        /// The offset of the X field in bytes.
        /// </summary>
        public static readonly int OffsetX =
            sizeof(ulong) * 0;

        /// <summary>
        /// The offset of the X field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrX =>
            new UIntPtr((uint)OffsetX);
        /// <summary>
        /// The offset of the Y field in bytes.
        /// </summary>
        public static readonly int OffsetY =
            sizeof(ulong) * 1;

        /// <summary>
        /// The offset of the Y field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrY =>
            new UIntPtr((uint)OffsetY);

        /// <summary>
        /// Returns the length of this vector which is 2.
        /// </summary>
        public static int Length => 2;

        /// <summary>
        /// Returns the radix of the underlying value.
        /// </summary>
        public static int Radix => 10;

        /// <summary>
        /// Returns an invalid value (min [signed types], max value [unsigned] or NaN).
        /// </summary>
        public static UInt64x2 Invalid => FromScalar(
            ulong.MaxValue
        );

        /// <summary>
        /// Returns the value zero.
        /// </summary>
        public static UInt64x2 Zero => new();

        /// <summary>
        /// Returns the value one.
        /// </summary>
        public static UInt64x2 One => FromScalar((1));

        /// <summary>
        /// Returns the value zero.
        /// </summary>
        public static UInt64x2 AdditiveIdentity => Zero;

        /// <summary>
        /// Returns the value one.
        /// </summary>
        public static UInt64x2 MultiplicativeIdentity => One;

        /// <summary>
        /// Computes the min value of both.
        /// </summary>
        /// <param name="first">The first value.</param>
        /// <param name="second">The second value.</param>
        /// <returns>The min value.</returns>
        public static UInt64x2 Min(
            UInt64x2 first,
            UInt64x2 second) =>
            new UInt64x2((ulong)Math.Min(first.X, second.X), (ulong)Math.Min(first.Y, second.Y));

        /// <summary>
        /// Computes the max value of both.
        /// </summary>
        /// <param name="first">The first value.</param>
        /// <param name="second">The second value.</param>
        /// <returns>The max value.</returns>
        public static UInt64x2 Max(
            UInt64x2 first,
            UInt64x2 second) =>
            new UInt64x2((ulong)Math.Max(first.X, second.X), (ulong)Math.Max(first.Y, second.Y));

        /// <summary>
        /// Clamps the given value.
        /// </summary>
        /// <param name="value">The value to clamp.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The clamped value.</returns>
        public static UInt64x2 Clamp(
            UInt64x2 value,
            UInt64x2 min,
            UInt64x2 max) =>
            Max(Min(value, max), min);

        /// <summary>
        /// Creates a random scalar instance falling into the range of min max.
        /// </summary>
        /// <param name="random">The random provider to use.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The created random scalar instance.</returns>
        public static ulong GetRandomScalar<TRandom>(
            ref TRandom random,
            ulong min,
            ulong max)
            where TRandom : struct, IRandomProvider =>
            (ulong)RandomExtensions.
                Next(ref random, min, max);

        /// <summary>
        /// Creates a random vector instance falling into the range of min max.
        /// </summary>
        /// <param name="random">The random provider to use.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The created random vector instance.</returns>
        public static UInt64x2 GetRandom<TRandom>(
            ref TRandom random,
            UInt64x2 min,
            UInt64x2 max)
            where TRandom : struct, IRandomProvider
        {
            ulong x = GetRandomScalar(
                ref random, min.X, max.X);
            ulong y = GetRandomScalar(
                ref random, min.Y, max.Y);
            return new UInt64x2(x, y);
        }

        /// <summary>
        /// Creates a vector instance from the given source view.
        /// </summary>
        /// <typeparam name="TStride">The custom stride type.</typeparam>
        /// <param name="sourceView">The source view.</param>
        /// <param name="index">The source base index.</param>
        /// <returns>The vector instance.</returns>
        public static UInt64x2 FromElementView<TStride>(
            ArrayView1D<ulong, TStride> sourceView,
            Index1D index)
            where TStride : struct, IStride1D =>
            new UInt64x2(
                sourceView[index + 0],
                sourceView[index + 1]
                );

        /// <summary>
        /// Serializes the current vector instance into the given target view.
        /// </summary>
        /// <typeparam name="TStride">The custom stride type.</typeparam>
        /// <param name="targetView">The target view.</param>
        /// <param name="index">The target base index.</param>
        public void ToElementView<TStride>(
            ArrayView1D<ulong, TStride> targetView,
            Index1D index)
            where TStride : struct, IStride1D
        {
            targetView[index + 0] = X;
            targetView[index + 1] = Y;
        }

        /// <summary>
        /// Creates a vector instance from the given source view.
        /// </summary>
        /// <param name="sourceView">The source view.</param>
        /// <param name="index">The source base index.</param>
        /// <returns>The vector instance.</returns>
        public static UInt64x2 FromElementView(
            SingleVectorView<ulong> sourceView,
            Index1D index) =>
            new UInt64x2(
                sourceView[index + 0],
                sourceView[index + 1]
                );

        /// <summary>
        /// Serializes the current vector instance into the given target view.
        /// </summary>
        /// <param name="targetView">The target view.</param>
        /// <param name="index">The target base index.</param>
        public void ToElementView(
            SingleVectorView<ulong> targetView,
            Index1D index)
        {
            targetView[index + 0] = X;
            targetView[index + 1] = Y;
        }

        /// <summary>
        /// Converts a scalar value into the current vectorized type.
        /// </summary>
        /// <param name="scalar">The scalar element type.</param>
        /// <returns>The created vectorized type.</returns>
        public static UInt64x2 FromScalar(ulong scalar) =>
            new UInt64x2(scalar, scalar);

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        public static void AtomicAdd(ref UInt64x2 target, UInt64x2 value)
        {
            ref var elementRef = ref Unsafe.As<UInt64x2, ulong>(
                ref target);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrX),
                value.X);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrY),
                value.Y);
        }

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        public UInt64x2 ComputeAverage(long denominator) =>
            this / FromScalar((ulong)denominator);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt64x2 operator +(
            UInt64x2 current,
            UInt8x2 toAccumulate) =>
            current + ConvertFrom_byte(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt64x2 operator +(
            UInt8x2 toAccumulate,
            UInt64x2 current) =>
            ConvertFrom_byte(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt64x2 operator -(
            UInt64x2 current,
            UInt8x2 toAccumulate) =>
            current - ConvertFrom_byte(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt64x2 operator -(
            UInt8x2 toAccumulate,
            UInt64x2 current) =>
            ConvertFrom_byte(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref UInt64x2 target,
            UInt8x2 value) =>
            AtomicAdd(ref target, ConvertFrom_byte(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt64x2 ConvertFrom_byte(
            UInt8x2 other) =>
            new UInt64x2((ulong)other.X, (ulong)other.Y);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt8x2 ConvertTo_byte(
            UInt64x2 current) =>
            new UInt8x2((byte)current.X, (byte)current.Y);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt64x2 IAccumulationVectorType<
            UInt64x2,
            UInt8x2,
            byte>.ConvertFromBase(UInt8x2 other) =>
            ConvertFrom_byte(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt8x2 IAccumulationVectorType<
            UInt64x2,
            UInt8x2,
            byte>.ConvertToBase(UInt64x2 current) =>
            ConvertTo_byte(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public UInt64x2 ComputeAverage(byte denominator) =>
            this / FromScalar((ulong)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt64x2 operator +(
            UInt64x2 current,
            UInt16x2 toAccumulate) =>
            current + ConvertFrom_ushort(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt64x2 operator +(
            UInt16x2 toAccumulate,
            UInt64x2 current) =>
            ConvertFrom_ushort(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt64x2 operator -(
            UInt64x2 current,
            UInt16x2 toAccumulate) =>
            current - ConvertFrom_ushort(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt64x2 operator -(
            UInt16x2 toAccumulate,
            UInt64x2 current) =>
            ConvertFrom_ushort(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref UInt64x2 target,
            UInt16x2 value) =>
            AtomicAdd(ref target, ConvertFrom_ushort(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt64x2 ConvertFrom_ushort(
            UInt16x2 other) =>
            new UInt64x2((ulong)other.X, (ulong)other.Y);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt16x2 ConvertTo_ushort(
            UInt64x2 current) =>
            new UInt16x2((ushort)current.X, (ushort)current.Y);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt64x2 IAccumulationVectorType<
            UInt64x2,
            UInt16x2,
            ushort>.ConvertFromBase(UInt16x2 other) =>
            ConvertFrom_ushort(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt16x2 IAccumulationVectorType<
            UInt64x2,
            UInt16x2,
            ushort>.ConvertToBase(UInt64x2 current) =>
            ConvertTo_ushort(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public UInt64x2 ComputeAverage(ushort denominator) =>
            this / FromScalar((ulong)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt64x2 operator +(
            UInt64x2 current,
            UInt32x2 toAccumulate) =>
            current + ConvertFrom_uint(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt64x2 operator +(
            UInt32x2 toAccumulate,
            UInt64x2 current) =>
            ConvertFrom_uint(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt64x2 operator -(
            UInt64x2 current,
            UInt32x2 toAccumulate) =>
            current - ConvertFrom_uint(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt64x2 operator -(
            UInt32x2 toAccumulate,
            UInt64x2 current) =>
            ConvertFrom_uint(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref UInt64x2 target,
            UInt32x2 value) =>
            AtomicAdd(ref target, ConvertFrom_uint(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt64x2 ConvertFrom_uint(
            UInt32x2 other) =>
            new UInt64x2((ulong)other.X, (ulong)other.Y);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt32x2 ConvertTo_uint(
            UInt64x2 current) =>
            new UInt32x2((uint)current.X, (uint)current.Y);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt64x2 IAccumulationVectorType<
            UInt64x2,
            UInt32x2,
            uint>.ConvertFromBase(UInt32x2 other) =>
            ConvertFrom_uint(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt32x2 IAccumulationVectorType<
            UInt64x2,
            UInt32x2,
            uint>.ConvertToBase(UInt64x2 current) =>
            ConvertTo_uint(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public UInt64x2 ComputeAverage(uint denominator) =>
            this / FromScalar((ulong)denominator);


        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt64x2 ConvertFrom_ulong(
            UInt64x2 other) =>
            new UInt64x2((ulong)other.X, (ulong)other.Y);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt64x2 ConvertTo_ulong(
            UInt64x2 current) =>
            new UInt64x2((ulong)current.X, (ulong)current.Y);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt64x2 IAccumulationVectorType<
            UInt64x2,
            UInt64x2,
            ulong>.ConvertFromBase(UInt64x2 other) =>
            ConvertFrom_ulong(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt64x2 IAccumulationVectorType<
            UInt64x2,
            UInt64x2,
            ulong>.ConvertToBase(UInt64x2 current) =>
            ConvertTo_ulong(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public UInt64x2 ComputeAverage(ulong denominator) =>
            this / FromScalar((ulong)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt64x2 operator +(
            UInt64x2 current,
            Float32x2 toAccumulate) =>
            current + ConvertFrom_float(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt64x2 operator +(
            Float32x2 toAccumulate,
            UInt64x2 current) =>
            ConvertFrom_float(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt64x2 operator -(
            UInt64x2 current,
            Float32x2 toAccumulate) =>
            current - ConvertFrom_float(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt64x2 operator -(
            Float32x2 toAccumulate,
            UInt64x2 current) =>
            ConvertFrom_float(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref UInt64x2 target,
            Float32x2 value) =>
            AtomicAdd(ref target, ConvertFrom_float(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt64x2 ConvertFrom_float(
            Float32x2 other) =>
            new UInt64x2((ulong)other.X, (ulong)other.Y);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float32x2 ConvertTo_float(
            UInt64x2 current) =>
            new Float32x2((float)current.X, (float)current.Y);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt64x2 IAccumulationVectorType<
            UInt64x2,
            Float32x2,
            float>.ConvertFromBase(Float32x2 other) =>
            ConvertFrom_float(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float32x2 IAccumulationVectorType<
            UInt64x2,
            Float32x2,
            float>.ConvertToBase(UInt64x2 current) =>
            ConvertTo_float(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public UInt64x2 ComputeAverage(float denominator) =>
            this / FromScalar((ulong)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt64x2 operator +(
            UInt64x2 current,
            Float64x2 toAccumulate) =>
            current + ConvertFrom_double(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt64x2 operator +(
            Float64x2 toAccumulate,
            UInt64x2 current) =>
            ConvertFrom_double(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt64x2 operator -(
            UInt64x2 current,
            Float64x2 toAccumulate) =>
            current - ConvertFrom_double(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt64x2 operator -(
            Float64x2 toAccumulate,
            UInt64x2 current) =>
            ConvertFrom_double(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref UInt64x2 target,
            Float64x2 value) =>
            AtomicAdd(ref target, ConvertFrom_double(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt64x2 ConvertFrom_double(
            Float64x2 other) =>
            new UInt64x2((ulong)other.X, (ulong)other.Y);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float64x2 ConvertTo_double(
            UInt64x2 current) =>
            new Float64x2((double)current.X, (double)current.Y);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt64x2 IAccumulationVectorType<
            UInt64x2,
            Float64x2,
            double>.ConvertFromBase(Float64x2 other) =>
            ConvertFrom_double(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float64x2 IAccumulationVectorType<
            UInt64x2,
            Float64x2,
            double>.ConvertToBase(UInt64x2 current) =>
            ConvertTo_double(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public UInt64x2 ComputeAverage(double denominator) =>
            this / FromScalar((ulong)denominator);

        /// <summary>
        /// Converts this instance into an unsafe span instance.
        /// </summary>
        /// <returns>The readonly span instance.</returns>
        public unsafe ReadOnlySpan<ulong> AsSpan() =>
            new(Unsafe.AsPointer(ref Unsafe.AsRef(this)), 2);

        /// <summary>
        /// Iterates over all elements by applying the given iterator to each element.
        /// </summary>
        /// <typeparam name="TIterator">The managed iterator type.</typeparam>
        /// <param name="iterator">The iterator to invoke.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ForEach<TIterator>(ref TIterator iterator)
            where TIterator : struct, IVectorElementIterator<
            UInt64x2,
            ulong>
        {
            iterator.Iterate(X, 0);
            iterator.Iterate(Y, 1);
        }

        /// <summary>
        /// Converts this vector instance to a string.
        /// </summary>
        public override string ToString() =>
            $"{X}, {Y}";

        /// <summary>
        /// Converts this vector instance to a string.
        /// </summary>
        public string ToString(string? format, IFormatProvider? formatProvider) =>
            $"{X.ToString(format, formatProvider)}, {Y.ToString(format, formatProvider)}";

        /// <summary>
        /// Returns true.
        /// </summary>
        public static bool IsCanonical(UInt64x2 value) => true;

        /// <summary>
        /// Returns false.
        /// </summary>
        public static bool IsComplexNumber(UInt64x2 value) => false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsEvenInteger(UInt64x2 value) =>
            ulong.IsEvenInteger(value.X) & ulong.IsEvenInteger(value.Y);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsFinite(UInt64x2 value) =>
            true;

        /// <summary>
        /// Returns false.
        /// </summary>
        public static bool IsImaginaryNumber(UInt64x2 value) => false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsInfinity(UInt64x2 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsInteger(UInt64x2 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNaN(UInt64x2 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNegative(UInt64x2 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNegativeInfinity(UInt64x2 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNormal(UInt64x2 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsOddInteger(UInt64x2 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsPositive(UInt64x2 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsPositiveInfinity(UInt64x2 value) =>
            false;

        /// <summary>
        /// Returns true.
        /// </summary>
        public static bool IsRealNumber(UInt64x2 value) => true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsSubnormal(UInt64x2 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsZero(UInt64x2 value) =>
            value == Zero;

        /// <summary>
        /// Returns the absolute value.
        /// </summary>
        public static UInt64x2 Abs(UInt64x2 value) =>
            value;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt64x2 operator +(UInt64x2 left, UInt64x2 right) =>
            new UInt64x2((ulong)(left.X + right.X), (ulong)(left.Y + right.Y));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt64x2 operator --(UInt64x2 value) => value - One;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt64x2 operator /(UInt64x2 left, UInt64x2 right) =>
            new UInt64x2((ulong)(left.X / right.X), (ulong)(left.Y / right.Y));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt64x2 operator ++(UInt64x2 value) => value + One;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt64x2 operator *(UInt64x2 left, UInt64x2 right) =>
            new UInt64x2((ulong)(left.X * right.X), (ulong)(left.Y * right.Y));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt64x2 operator -(UInt64x2 left, UInt64x2 right) =>
            new UInt64x2((ulong)(left.X - right.X), (ulong)(left.Y - right.Y));

        /// <summary>
        /// Not supported operation.
        /// </summary>
        static UInt64x2 IUnaryNegationOperators<UInt64x2, UInt64x2>.
            operator -(UInt64x2 value) => value;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt64x2 operator +(UInt64x2 value) => value;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt64x2 MaxMagnitude(UInt64x2 x, UInt64x2 y) =>
            Max(x, y);

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt64x2 MaxMagnitudeNumber(UInt64x2 x, UInt64x2 y) =>
            MaxMagnitude(x, y);

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt64x2 MinMagnitude(UInt64x2 x, UInt64x2 y) =>
            Min(x, y);

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt64x2 MinMagnitudeNumber(UInt64x2 x, UInt64x2 y) =>
            MinMagnitude(x, y);

        // Not supported operations

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static UInt64x2 IParsable<UInt64x2>.Parse(
            string s,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static UInt64x2 ISpanParsable<UInt64x2>.Parse(
            ReadOnlySpan<char> s,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static UInt64x2 INumberBase<UInt64x2>.Parse(
            ReadOnlySpan<char> s,
            NumberStyles style,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static UInt64x2 INumberBase<UInt64x2>.Parse(
            string s,
            NumberStyles style,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        bool ISpanFormattable.TryFormat(
            Span<char> destination,
            out int charsWritten,
            ReadOnlySpan<char> format,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool IParsable<UInt64x2>.TryParse(
            string? s,
            IFormatProvider? provider,
            out UInt64x2 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given span into a vectorized instance.
        /// </summary>
        static bool ISpanParsable<UInt64x2>.TryParse(
            ReadOnlySpan<char> s,
            IFormatProvider? provider,
            out UInt64x2 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool INumberBase<UInt64x2>.TryParse(
            ReadOnlySpan<char> s,
            NumberStyles style,
            IFormatProvider? provider,
            out UInt64x2 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool INumberBase<UInt64x2>.TryParse(
            string? s,
            NumberStyles style,
            IFormatProvider? provider,
            out UInt64x2 result) =>
            throw new NotSupportedException();

        static bool INumberBase<UInt64x2>.TryConvertFromChecked<TOther>(
            TOther value,
            out UInt64x2 result) =>
            throw new NotSupportedException();
        static bool INumberBase<UInt64x2>.TryConvertFromSaturating<TOther>(
            TOther value,
            out UInt64x2 result) =>
            throw new NotSupportedException();
        static bool INumberBase<UInt64x2>.TryConvertFromTruncating<TOther>(
            TOther value,
            out UInt64x2 result) =>
            throw new NotSupportedException();
        static bool INumberBase<UInt64x2>.TryConvertToChecked<TOther>(
            UInt64x2 value,
            out TOther result) =>
            throw new NotSupportedException();
        static bool INumberBase<UInt64x2>.TryConvertToSaturating<TOther>(
            UInt64x2 value,
            out TOther result) =>
            throw new NotSupportedException();
        static bool INumberBase<UInt64x2>.TryConvertToTruncating<TOther>(
            UInt64x2 value,
            out TOther result) =>
            throw new NotSupportedException();
    }

    /// <summary>
    /// Represents a vectorized ulong type with length 4.
    /// </summary>
    [CLSCompliant(false)]
    public readonly record struct UInt64x4(
        ulong X, ulong Y, ulong Z, ulong W) :
        IVectorType<UInt64x4, ulong>
        , IAccumulationVectorType<
            UInt64x4,
            UInt8x4,
            byte>
        , IAccumulationVectorType<
            UInt64x4,
            UInt16x4,
            ushort>
        , IAccumulationVectorType<
            UInt64x4,
            UInt32x4,
            uint>
        , IAccumulationVectorType<
            UInt64x4,
            UInt64x4,
            ulong>
        , IAccumulationVectorType<
            UInt64x4,
            Float32x4,
            float>
        , IAccumulationVectorType<
            UInt64x4,
            Float64x4,
            double>
    {
        /// <summary>
        /// The offset of the X field in bytes.
        /// </summary>
        public static readonly int OffsetX =
            sizeof(ulong) * 0;

        /// <summary>
        /// The offset of the X field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrX =>
            new UIntPtr((uint)OffsetX);
        /// <summary>
        /// The offset of the Y field in bytes.
        /// </summary>
        public static readonly int OffsetY =
            sizeof(ulong) * 1;

        /// <summary>
        /// The offset of the Y field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrY =>
            new UIntPtr((uint)OffsetY);
        /// <summary>
        /// The offset of the Z field in bytes.
        /// </summary>
        public static readonly int OffsetZ =
            sizeof(ulong) * 2;

        /// <summary>
        /// The offset of the Z field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrZ =>
            new UIntPtr((uint)OffsetZ);
        /// <summary>
        /// The offset of the W field in bytes.
        /// </summary>
        public static readonly int OffsetW =
            sizeof(ulong) * 3;

        /// <summary>
        /// The offset of the W field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrW =>
            new UIntPtr((uint)OffsetW);

        /// <summary>
        /// Returns the length of this vector which is 4.
        /// </summary>
        public static int Length => 4;

        /// <summary>
        /// Returns the radix of the underlying value.
        /// </summary>
        public static int Radix => 10;

        /// <summary>
        /// Returns an invalid value (min [signed types], max value [unsigned] or NaN).
        /// </summary>
        public static UInt64x4 Invalid => FromScalar(
            ulong.MaxValue
        );

        /// <summary>
        /// Returns the value zero.
        /// </summary>
        public static UInt64x4 Zero => new();

        /// <summary>
        /// Returns the value one.
        /// </summary>
        public static UInt64x4 One => FromScalar((1));

        /// <summary>
        /// Returns the value zero.
        /// </summary>
        public static UInt64x4 AdditiveIdentity => Zero;

        /// <summary>
        /// Returns the value one.
        /// </summary>
        public static UInt64x4 MultiplicativeIdentity => One;

        /// <summary>
        /// Computes the min value of both.
        /// </summary>
        /// <param name="first">The first value.</param>
        /// <param name="second">The second value.</param>
        /// <returns>The min value.</returns>
        public static UInt64x4 Min(
            UInt64x4 first,
            UInt64x4 second) =>
            new UInt64x4((ulong)Math.Min(first.X, second.X), (ulong)Math.Min(first.Y, second.Y), (ulong)Math.Min(first.Z, second.Z), (ulong)Math.Min(first.W, second.W));

        /// <summary>
        /// Computes the max value of both.
        /// </summary>
        /// <param name="first">The first value.</param>
        /// <param name="second">The second value.</param>
        /// <returns>The max value.</returns>
        public static UInt64x4 Max(
            UInt64x4 first,
            UInt64x4 second) =>
            new UInt64x4((ulong)Math.Max(first.X, second.X), (ulong)Math.Max(first.Y, second.Y), (ulong)Math.Max(first.Z, second.Z), (ulong)Math.Max(first.W, second.W));

        /// <summary>
        /// Clamps the given value.
        /// </summary>
        /// <param name="value">The value to clamp.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The clamped value.</returns>
        public static UInt64x4 Clamp(
            UInt64x4 value,
            UInt64x4 min,
            UInt64x4 max) =>
            Max(Min(value, max), min);

        /// <summary>
        /// Creates a random scalar instance falling into the range of min max.
        /// </summary>
        /// <param name="random">The random provider to use.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The created random scalar instance.</returns>
        public static ulong GetRandomScalar<TRandom>(
            ref TRandom random,
            ulong min,
            ulong max)
            where TRandom : struct, IRandomProvider =>
            (ulong)RandomExtensions.
                Next(ref random, min, max);

        /// <summary>
        /// Creates a random vector instance falling into the range of min max.
        /// </summary>
        /// <param name="random">The random provider to use.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The created random vector instance.</returns>
        public static UInt64x4 GetRandom<TRandom>(
            ref TRandom random,
            UInt64x4 min,
            UInt64x4 max)
            where TRandom : struct, IRandomProvider
        {
            ulong x = GetRandomScalar(
                ref random, min.X, max.X);
            ulong y = GetRandomScalar(
                ref random, min.Y, max.Y);
            ulong z = GetRandomScalar(
                ref random, min.Z, max.Z);
            ulong w = GetRandomScalar(
                ref random, min.W, max.W);
            return new UInt64x4(x, y, z, w);
        }

        /// <summary>
        /// Creates a vector instance from the given source view.
        /// </summary>
        /// <typeparam name="TStride">The custom stride type.</typeparam>
        /// <param name="sourceView">The source view.</param>
        /// <param name="index">The source base index.</param>
        /// <returns>The vector instance.</returns>
        public static UInt64x4 FromElementView<TStride>(
            ArrayView1D<ulong, TStride> sourceView,
            Index1D index)
            where TStride : struct, IStride1D =>
            new UInt64x4(
                sourceView[index + 0],
                sourceView[index + 1],
                sourceView[index + 2],
                sourceView[index + 3]
                );

        /// <summary>
        /// Serializes the current vector instance into the given target view.
        /// </summary>
        /// <typeparam name="TStride">The custom stride type.</typeparam>
        /// <param name="targetView">The target view.</param>
        /// <param name="index">The target base index.</param>
        public void ToElementView<TStride>(
            ArrayView1D<ulong, TStride> targetView,
            Index1D index)
            where TStride : struct, IStride1D
        {
            targetView[index + 0] = X;
            targetView[index + 1] = Y;
            targetView[index + 2] = Z;
            targetView[index + 3] = W;
        }

        /// <summary>
        /// Creates a vector instance from the given source view.
        /// </summary>
        /// <param name="sourceView">The source view.</param>
        /// <param name="index">The source base index.</param>
        /// <returns>The vector instance.</returns>
        public static UInt64x4 FromElementView(
            SingleVectorView<ulong> sourceView,
            Index1D index) =>
            new UInt64x4(
                sourceView[index + 0],
                sourceView[index + 1],
                sourceView[index + 2],
                sourceView[index + 3]
                );

        /// <summary>
        /// Serializes the current vector instance into the given target view.
        /// </summary>
        /// <param name="targetView">The target view.</param>
        /// <param name="index">The target base index.</param>
        public void ToElementView(
            SingleVectorView<ulong> targetView,
            Index1D index)
        {
            targetView[index + 0] = X;
            targetView[index + 1] = Y;
            targetView[index + 2] = Z;
            targetView[index + 3] = W;
        }

        /// <summary>
        /// Converts a scalar value into the current vectorized type.
        /// </summary>
        /// <param name="scalar">The scalar element type.</param>
        /// <returns>The created vectorized type.</returns>
        public static UInt64x4 FromScalar(ulong scalar) =>
            new UInt64x4(scalar, scalar, scalar, scalar);

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        public static void AtomicAdd(ref UInt64x4 target, UInt64x4 value)
        {
            ref var elementRef = ref Unsafe.As<UInt64x4, ulong>(
                ref target);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrX),
                value.X);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrY),
                value.Y);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrZ),
                value.Z);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrW),
                value.W);
        }

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        public UInt64x4 ComputeAverage(long denominator) =>
            this / FromScalar((ulong)denominator);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt64x4 operator +(
            UInt64x4 current,
            UInt8x4 toAccumulate) =>
            current + ConvertFrom_byte(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt64x4 operator +(
            UInt8x4 toAccumulate,
            UInt64x4 current) =>
            ConvertFrom_byte(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt64x4 operator -(
            UInt64x4 current,
            UInt8x4 toAccumulate) =>
            current - ConvertFrom_byte(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt64x4 operator -(
            UInt8x4 toAccumulate,
            UInt64x4 current) =>
            ConvertFrom_byte(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref UInt64x4 target,
            UInt8x4 value) =>
            AtomicAdd(ref target, ConvertFrom_byte(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt64x4 ConvertFrom_byte(
            UInt8x4 other) =>
            new UInt64x4((ulong)other.X, (ulong)other.Y, (ulong)other.Z, (ulong)other.W);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt8x4 ConvertTo_byte(
            UInt64x4 current) =>
            new UInt8x4((byte)current.X, (byte)current.Y, (byte)current.Z, (byte)current.W);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt64x4 IAccumulationVectorType<
            UInt64x4,
            UInt8x4,
            byte>.ConvertFromBase(UInt8x4 other) =>
            ConvertFrom_byte(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt8x4 IAccumulationVectorType<
            UInt64x4,
            UInt8x4,
            byte>.ConvertToBase(UInt64x4 current) =>
            ConvertTo_byte(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public UInt64x4 ComputeAverage(byte denominator) =>
            this / FromScalar((ulong)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt64x4 operator +(
            UInt64x4 current,
            UInt16x4 toAccumulate) =>
            current + ConvertFrom_ushort(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt64x4 operator +(
            UInt16x4 toAccumulate,
            UInt64x4 current) =>
            ConvertFrom_ushort(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt64x4 operator -(
            UInt64x4 current,
            UInt16x4 toAccumulate) =>
            current - ConvertFrom_ushort(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt64x4 operator -(
            UInt16x4 toAccumulate,
            UInt64x4 current) =>
            ConvertFrom_ushort(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref UInt64x4 target,
            UInt16x4 value) =>
            AtomicAdd(ref target, ConvertFrom_ushort(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt64x4 ConvertFrom_ushort(
            UInt16x4 other) =>
            new UInt64x4((ulong)other.X, (ulong)other.Y, (ulong)other.Z, (ulong)other.W);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt16x4 ConvertTo_ushort(
            UInt64x4 current) =>
            new UInt16x4((ushort)current.X, (ushort)current.Y, (ushort)current.Z, (ushort)current.W);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt64x4 IAccumulationVectorType<
            UInt64x4,
            UInt16x4,
            ushort>.ConvertFromBase(UInt16x4 other) =>
            ConvertFrom_ushort(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt16x4 IAccumulationVectorType<
            UInt64x4,
            UInt16x4,
            ushort>.ConvertToBase(UInt64x4 current) =>
            ConvertTo_ushort(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public UInt64x4 ComputeAverage(ushort denominator) =>
            this / FromScalar((ulong)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt64x4 operator +(
            UInt64x4 current,
            UInt32x4 toAccumulate) =>
            current + ConvertFrom_uint(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt64x4 operator +(
            UInt32x4 toAccumulate,
            UInt64x4 current) =>
            ConvertFrom_uint(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt64x4 operator -(
            UInt64x4 current,
            UInt32x4 toAccumulate) =>
            current - ConvertFrom_uint(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt64x4 operator -(
            UInt32x4 toAccumulate,
            UInt64x4 current) =>
            ConvertFrom_uint(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref UInt64x4 target,
            UInt32x4 value) =>
            AtomicAdd(ref target, ConvertFrom_uint(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt64x4 ConvertFrom_uint(
            UInt32x4 other) =>
            new UInt64x4((ulong)other.X, (ulong)other.Y, (ulong)other.Z, (ulong)other.W);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt32x4 ConvertTo_uint(
            UInt64x4 current) =>
            new UInt32x4((uint)current.X, (uint)current.Y, (uint)current.Z, (uint)current.W);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt64x4 IAccumulationVectorType<
            UInt64x4,
            UInt32x4,
            uint>.ConvertFromBase(UInt32x4 other) =>
            ConvertFrom_uint(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt32x4 IAccumulationVectorType<
            UInt64x4,
            UInt32x4,
            uint>.ConvertToBase(UInt64x4 current) =>
            ConvertTo_uint(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public UInt64x4 ComputeAverage(uint denominator) =>
            this / FromScalar((ulong)denominator);


        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt64x4 ConvertFrom_ulong(
            UInt64x4 other) =>
            new UInt64x4((ulong)other.X, (ulong)other.Y, (ulong)other.Z, (ulong)other.W);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt64x4 ConvertTo_ulong(
            UInt64x4 current) =>
            new UInt64x4((ulong)current.X, (ulong)current.Y, (ulong)current.Z, (ulong)current.W);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt64x4 IAccumulationVectorType<
            UInt64x4,
            UInt64x4,
            ulong>.ConvertFromBase(UInt64x4 other) =>
            ConvertFrom_ulong(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt64x4 IAccumulationVectorType<
            UInt64x4,
            UInt64x4,
            ulong>.ConvertToBase(UInt64x4 current) =>
            ConvertTo_ulong(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public UInt64x4 ComputeAverage(ulong denominator) =>
            this / FromScalar((ulong)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt64x4 operator +(
            UInt64x4 current,
            Float32x4 toAccumulate) =>
            current + ConvertFrom_float(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt64x4 operator +(
            Float32x4 toAccumulate,
            UInt64x4 current) =>
            ConvertFrom_float(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt64x4 operator -(
            UInt64x4 current,
            Float32x4 toAccumulate) =>
            current - ConvertFrom_float(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt64x4 operator -(
            Float32x4 toAccumulate,
            UInt64x4 current) =>
            ConvertFrom_float(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref UInt64x4 target,
            Float32x4 value) =>
            AtomicAdd(ref target, ConvertFrom_float(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt64x4 ConvertFrom_float(
            Float32x4 other) =>
            new UInt64x4((ulong)other.X, (ulong)other.Y, (ulong)other.Z, (ulong)other.W);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float32x4 ConvertTo_float(
            UInt64x4 current) =>
            new Float32x4((float)current.X, (float)current.Y, (float)current.Z, (float)current.W);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt64x4 IAccumulationVectorType<
            UInt64x4,
            Float32x4,
            float>.ConvertFromBase(Float32x4 other) =>
            ConvertFrom_float(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float32x4 IAccumulationVectorType<
            UInt64x4,
            Float32x4,
            float>.ConvertToBase(UInt64x4 current) =>
            ConvertTo_float(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public UInt64x4 ComputeAverage(float denominator) =>
            this / FromScalar((ulong)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt64x4 operator +(
            UInt64x4 current,
            Float64x4 toAccumulate) =>
            current + ConvertFrom_double(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt64x4 operator +(
            Float64x4 toAccumulate,
            UInt64x4 current) =>
            ConvertFrom_double(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt64x4 operator -(
            UInt64x4 current,
            Float64x4 toAccumulate) =>
            current - ConvertFrom_double(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt64x4 operator -(
            Float64x4 toAccumulate,
            UInt64x4 current) =>
            ConvertFrom_double(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref UInt64x4 target,
            Float64x4 value) =>
            AtomicAdd(ref target, ConvertFrom_double(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt64x4 ConvertFrom_double(
            Float64x4 other) =>
            new UInt64x4((ulong)other.X, (ulong)other.Y, (ulong)other.Z, (ulong)other.W);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float64x4 ConvertTo_double(
            UInt64x4 current) =>
            new Float64x4((double)current.X, (double)current.Y, (double)current.Z, (double)current.W);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt64x4 IAccumulationVectorType<
            UInt64x4,
            Float64x4,
            double>.ConvertFromBase(Float64x4 other) =>
            ConvertFrom_double(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float64x4 IAccumulationVectorType<
            UInt64x4,
            Float64x4,
            double>.ConvertToBase(UInt64x4 current) =>
            ConvertTo_double(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public UInt64x4 ComputeAverage(double denominator) =>
            this / FromScalar((ulong)denominator);

        /// <summary>
        /// Converts this instance into an unsafe span instance.
        /// </summary>
        /// <returns>The readonly span instance.</returns>
        public unsafe ReadOnlySpan<ulong> AsSpan() =>
            new(Unsafe.AsPointer(ref Unsafe.AsRef(this)), 4);

        /// <summary>
        /// Iterates over all elements by applying the given iterator to each element.
        /// </summary>
        /// <typeparam name="TIterator">The managed iterator type.</typeparam>
        /// <param name="iterator">The iterator to invoke.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ForEach<TIterator>(ref TIterator iterator)
            where TIterator : struct, IVectorElementIterator<
            UInt64x4,
            ulong>
        {
            iterator.Iterate(X, 0);
            iterator.Iterate(Y, 1);
            iterator.Iterate(Z, 2);
            iterator.Iterate(W, 3);
        }

        /// <summary>
        /// Converts this vector instance to a string.
        /// </summary>
        public override string ToString() =>
            $"{X}, {Y}, {Z}, {W}";

        /// <summary>
        /// Converts this vector instance to a string.
        /// </summary>
        public string ToString(string? format, IFormatProvider? formatProvider) =>
            $"{X.ToString(format, formatProvider)}, {Y.ToString(format, formatProvider)}, {Z.ToString(format, formatProvider)}, {W.ToString(format, formatProvider)}";

        /// <summary>
        /// Returns true.
        /// </summary>
        public static bool IsCanonical(UInt64x4 value) => true;

        /// <summary>
        /// Returns false.
        /// </summary>
        public static bool IsComplexNumber(UInt64x4 value) => false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsEvenInteger(UInt64x4 value) =>
            ulong.IsEvenInteger(value.X) & ulong.IsEvenInteger(value.Y) & ulong.IsEvenInteger(value.Z) & ulong.IsEvenInteger(value.W);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsFinite(UInt64x4 value) =>
            true;

        /// <summary>
        /// Returns false.
        /// </summary>
        public static bool IsImaginaryNumber(UInt64x4 value) => false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsInfinity(UInt64x4 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsInteger(UInt64x4 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNaN(UInt64x4 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNegative(UInt64x4 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNegativeInfinity(UInt64x4 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNormal(UInt64x4 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsOddInteger(UInt64x4 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsPositive(UInt64x4 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsPositiveInfinity(UInt64x4 value) =>
            false;

        /// <summary>
        /// Returns true.
        /// </summary>
        public static bool IsRealNumber(UInt64x4 value) => true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsSubnormal(UInt64x4 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsZero(UInt64x4 value) =>
            value == Zero;

        /// <summary>
        /// Returns the absolute value.
        /// </summary>
        public static UInt64x4 Abs(UInt64x4 value) =>
            value;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt64x4 operator +(UInt64x4 left, UInt64x4 right) =>
            new UInt64x4((ulong)(left.X + right.X), (ulong)(left.Y + right.Y), (ulong)(left.Z + right.Z), (ulong)(left.W + right.W));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt64x4 operator --(UInt64x4 value) => value - One;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt64x4 operator /(UInt64x4 left, UInt64x4 right) =>
            new UInt64x4((ulong)(left.X / right.X), (ulong)(left.Y / right.Y), (ulong)(left.Z / right.Z), (ulong)(left.W / right.W));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt64x4 operator ++(UInt64x4 value) => value + One;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt64x4 operator *(UInt64x4 left, UInt64x4 right) =>
            new UInt64x4((ulong)(left.X * right.X), (ulong)(left.Y * right.Y), (ulong)(left.Z * right.Z), (ulong)(left.W * right.W));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt64x4 operator -(UInt64x4 left, UInt64x4 right) =>
            new UInt64x4((ulong)(left.X - right.X), (ulong)(left.Y - right.Y), (ulong)(left.Z - right.Z), (ulong)(left.W - right.W));

        /// <summary>
        /// Not supported operation.
        /// </summary>
        static UInt64x4 IUnaryNegationOperators<UInt64x4, UInt64x4>.
            operator -(UInt64x4 value) => value;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt64x4 operator +(UInt64x4 value) => value;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt64x4 MaxMagnitude(UInt64x4 x, UInt64x4 y) =>
            Max(x, y);

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt64x4 MaxMagnitudeNumber(UInt64x4 x, UInt64x4 y) =>
            MaxMagnitude(x, y);

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt64x4 MinMagnitude(UInt64x4 x, UInt64x4 y) =>
            Min(x, y);

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt64x4 MinMagnitudeNumber(UInt64x4 x, UInt64x4 y) =>
            MinMagnitude(x, y);

        // Not supported operations

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static UInt64x4 IParsable<UInt64x4>.Parse(
            string s,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static UInt64x4 ISpanParsable<UInt64x4>.Parse(
            ReadOnlySpan<char> s,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static UInt64x4 INumberBase<UInt64x4>.Parse(
            ReadOnlySpan<char> s,
            NumberStyles style,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static UInt64x4 INumberBase<UInt64x4>.Parse(
            string s,
            NumberStyles style,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        bool ISpanFormattable.TryFormat(
            Span<char> destination,
            out int charsWritten,
            ReadOnlySpan<char> format,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool IParsable<UInt64x4>.TryParse(
            string? s,
            IFormatProvider? provider,
            out UInt64x4 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given span into a vectorized instance.
        /// </summary>
        static bool ISpanParsable<UInt64x4>.TryParse(
            ReadOnlySpan<char> s,
            IFormatProvider? provider,
            out UInt64x4 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool INumberBase<UInt64x4>.TryParse(
            ReadOnlySpan<char> s,
            NumberStyles style,
            IFormatProvider? provider,
            out UInt64x4 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool INumberBase<UInt64x4>.TryParse(
            string? s,
            NumberStyles style,
            IFormatProvider? provider,
            out UInt64x4 result) =>
            throw new NotSupportedException();

        static bool INumberBase<UInt64x4>.TryConvertFromChecked<TOther>(
            TOther value,
            out UInt64x4 result) =>
            throw new NotSupportedException();
        static bool INumberBase<UInt64x4>.TryConvertFromSaturating<TOther>(
            TOther value,
            out UInt64x4 result) =>
            throw new NotSupportedException();
        static bool INumberBase<UInt64x4>.TryConvertFromTruncating<TOther>(
            TOther value,
            out UInt64x4 result) =>
            throw new NotSupportedException();
        static bool INumberBase<UInt64x4>.TryConvertToChecked<TOther>(
            UInt64x4 value,
            out TOther result) =>
            throw new NotSupportedException();
        static bool INumberBase<UInt64x4>.TryConvertToSaturating<TOther>(
            UInt64x4 value,
            out TOther result) =>
            throw new NotSupportedException();
        static bool INumberBase<UInt64x4>.TryConvertToTruncating<TOther>(
            UInt64x4 value,
            out TOther result) =>
            throw new NotSupportedException();
    }

    /// <summary>
    /// Represents a vectorized ulong type with length 8.
    /// </summary>
    [CLSCompliant(false)]
    public readonly record struct UInt64x8(
        ulong X, ulong Y, ulong Z, ulong W, ulong I, ulong J, ulong K, ulong L) :
        IVectorType<UInt64x8, ulong>
        , IAccumulationVectorType<
            UInt64x8,
            UInt8x8,
            byte>
        , IAccumulationVectorType<
            UInt64x8,
            UInt16x8,
            ushort>
        , IAccumulationVectorType<
            UInt64x8,
            UInt32x8,
            uint>
        , IAccumulationVectorType<
            UInt64x8,
            UInt64x8,
            ulong>
        , IAccumulationVectorType<
            UInt64x8,
            Float32x8,
            float>
        , IAccumulationVectorType<
            UInt64x8,
            Float64x8,
            double>
    {
        /// <summary>
        /// The offset of the X field in bytes.
        /// </summary>
        public static readonly int OffsetX =
            sizeof(ulong) * 0;

        /// <summary>
        /// The offset of the X field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrX =>
            new UIntPtr((uint)OffsetX);
        /// <summary>
        /// The offset of the Y field in bytes.
        /// </summary>
        public static readonly int OffsetY =
            sizeof(ulong) * 1;

        /// <summary>
        /// The offset of the Y field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrY =>
            new UIntPtr((uint)OffsetY);
        /// <summary>
        /// The offset of the Z field in bytes.
        /// </summary>
        public static readonly int OffsetZ =
            sizeof(ulong) * 2;

        /// <summary>
        /// The offset of the Z field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrZ =>
            new UIntPtr((uint)OffsetZ);
        /// <summary>
        /// The offset of the W field in bytes.
        /// </summary>
        public static readonly int OffsetW =
            sizeof(ulong) * 3;

        /// <summary>
        /// The offset of the W field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrW =>
            new UIntPtr((uint)OffsetW);
        /// <summary>
        /// The offset of the I field in bytes.
        /// </summary>
        public static readonly int OffsetI =
            sizeof(ulong) * 4;

        /// <summary>
        /// The offset of the I field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrI =>
            new UIntPtr((uint)OffsetI);
        /// <summary>
        /// The offset of the J field in bytes.
        /// </summary>
        public static readonly int OffsetJ =
            sizeof(ulong) * 5;

        /// <summary>
        /// The offset of the J field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrJ =>
            new UIntPtr((uint)OffsetJ);
        /// <summary>
        /// The offset of the K field in bytes.
        /// </summary>
        public static readonly int OffsetK =
            sizeof(ulong) * 6;

        /// <summary>
        /// The offset of the K field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrK =>
            new UIntPtr((uint)OffsetK);
        /// <summary>
        /// The offset of the L field in bytes.
        /// </summary>
        public static readonly int OffsetL =
            sizeof(ulong) * 7;

        /// <summary>
        /// The offset of the L field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrL =>
            new UIntPtr((uint)OffsetL);

        /// <summary>
        /// Returns the length of this vector which is 8.
        /// </summary>
        public static int Length => 8;

        /// <summary>
        /// Returns the radix of the underlying value.
        /// </summary>
        public static int Radix => 10;

        /// <summary>
        /// Returns an invalid value (min [signed types], max value [unsigned] or NaN).
        /// </summary>
        public static UInt64x8 Invalid => FromScalar(
            ulong.MaxValue
        );

        /// <summary>
        /// Returns the value zero.
        /// </summary>
        public static UInt64x8 Zero => new();

        /// <summary>
        /// Returns the value one.
        /// </summary>
        public static UInt64x8 One => FromScalar((1));

        /// <summary>
        /// Returns the value zero.
        /// </summary>
        public static UInt64x8 AdditiveIdentity => Zero;

        /// <summary>
        /// Returns the value one.
        /// </summary>
        public static UInt64x8 MultiplicativeIdentity => One;

        /// <summary>
        /// Computes the min value of both.
        /// </summary>
        /// <param name="first">The first value.</param>
        /// <param name="second">The second value.</param>
        /// <returns>The min value.</returns>
        public static UInt64x8 Min(
            UInt64x8 first,
            UInt64x8 second) =>
            new UInt64x8((ulong)Math.Min(first.X, second.X), (ulong)Math.Min(first.Y, second.Y), (ulong)Math.Min(first.Z, second.Z), (ulong)Math.Min(first.W, second.W), (ulong)Math.Min(first.I, second.I), (ulong)Math.Min(first.J, second.J), (ulong)Math.Min(first.K, second.K), (ulong)Math.Min(first.L, second.L));

        /// <summary>
        /// Computes the max value of both.
        /// </summary>
        /// <param name="first">The first value.</param>
        /// <param name="second">The second value.</param>
        /// <returns>The max value.</returns>
        public static UInt64x8 Max(
            UInt64x8 first,
            UInt64x8 second) =>
            new UInt64x8((ulong)Math.Max(first.X, second.X), (ulong)Math.Max(first.Y, second.Y), (ulong)Math.Max(first.Z, second.Z), (ulong)Math.Max(first.W, second.W), (ulong)Math.Max(first.I, second.I), (ulong)Math.Max(first.J, second.J), (ulong)Math.Max(first.K, second.K), (ulong)Math.Max(first.L, second.L));

        /// <summary>
        /// Clamps the given value.
        /// </summary>
        /// <param name="value">The value to clamp.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The clamped value.</returns>
        public static UInt64x8 Clamp(
            UInt64x8 value,
            UInt64x8 min,
            UInt64x8 max) =>
            Max(Min(value, max), min);

        /// <summary>
        /// Creates a random scalar instance falling into the range of min max.
        /// </summary>
        /// <param name="random">The random provider to use.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The created random scalar instance.</returns>
        public static ulong GetRandomScalar<TRandom>(
            ref TRandom random,
            ulong min,
            ulong max)
            where TRandom : struct, IRandomProvider =>
            (ulong)RandomExtensions.
                Next(ref random, min, max);

        /// <summary>
        /// Creates a random vector instance falling into the range of min max.
        /// </summary>
        /// <param name="random">The random provider to use.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The created random vector instance.</returns>
        public static UInt64x8 GetRandom<TRandom>(
            ref TRandom random,
            UInt64x8 min,
            UInt64x8 max)
            where TRandom : struct, IRandomProvider
        {
            ulong x = GetRandomScalar(
                ref random, min.X, max.X);
            ulong y = GetRandomScalar(
                ref random, min.Y, max.Y);
            ulong z = GetRandomScalar(
                ref random, min.Z, max.Z);
            ulong w = GetRandomScalar(
                ref random, min.W, max.W);
            ulong i = GetRandomScalar(
                ref random, min.I, max.I);
            ulong j = GetRandomScalar(
                ref random, min.J, max.J);
            ulong k = GetRandomScalar(
                ref random, min.K, max.K);
            ulong l = GetRandomScalar(
                ref random, min.L, max.L);
            return new UInt64x8(x, y, z, w, i, j, k, l);
        }

        /// <summary>
        /// Creates a vector instance from the given source view.
        /// </summary>
        /// <typeparam name="TStride">The custom stride type.</typeparam>
        /// <param name="sourceView">The source view.</param>
        /// <param name="index">The source base index.</param>
        /// <returns>The vector instance.</returns>
        public static UInt64x8 FromElementView<TStride>(
            ArrayView1D<ulong, TStride> sourceView,
            Index1D index)
            where TStride : struct, IStride1D =>
            new UInt64x8(
                sourceView[index + 0],
                sourceView[index + 1],
                sourceView[index + 2],
                sourceView[index + 3],
                sourceView[index + 4],
                sourceView[index + 5],
                sourceView[index + 6],
                sourceView[index + 7]
                );

        /// <summary>
        /// Serializes the current vector instance into the given target view.
        /// </summary>
        /// <typeparam name="TStride">The custom stride type.</typeparam>
        /// <param name="targetView">The target view.</param>
        /// <param name="index">The target base index.</param>
        public void ToElementView<TStride>(
            ArrayView1D<ulong, TStride> targetView,
            Index1D index)
            where TStride : struct, IStride1D
        {
            targetView[index + 0] = X;
            targetView[index + 1] = Y;
            targetView[index + 2] = Z;
            targetView[index + 3] = W;
            targetView[index + 4] = I;
            targetView[index + 5] = J;
            targetView[index + 6] = K;
            targetView[index + 7] = L;
        }

        /// <summary>
        /// Creates a vector instance from the given source view.
        /// </summary>
        /// <param name="sourceView">The source view.</param>
        /// <param name="index">The source base index.</param>
        /// <returns>The vector instance.</returns>
        public static UInt64x8 FromElementView(
            SingleVectorView<ulong> sourceView,
            Index1D index) =>
            new UInt64x8(
                sourceView[index + 0],
                sourceView[index + 1],
                sourceView[index + 2],
                sourceView[index + 3],
                sourceView[index + 4],
                sourceView[index + 5],
                sourceView[index + 6],
                sourceView[index + 7]
                );

        /// <summary>
        /// Serializes the current vector instance into the given target view.
        /// </summary>
        /// <param name="targetView">The target view.</param>
        /// <param name="index">The target base index.</param>
        public void ToElementView(
            SingleVectorView<ulong> targetView,
            Index1D index)
        {
            targetView[index + 0] = X;
            targetView[index + 1] = Y;
            targetView[index + 2] = Z;
            targetView[index + 3] = W;
            targetView[index + 4] = I;
            targetView[index + 5] = J;
            targetView[index + 6] = K;
            targetView[index + 7] = L;
        }

        /// <summary>
        /// Converts a scalar value into the current vectorized type.
        /// </summary>
        /// <param name="scalar">The scalar element type.</param>
        /// <returns>The created vectorized type.</returns>
        public static UInt64x8 FromScalar(ulong scalar) =>
            new UInt64x8(scalar, scalar, scalar, scalar, scalar, scalar, scalar, scalar);

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        public static void AtomicAdd(ref UInt64x8 target, UInt64x8 value)
        {
            ref var elementRef = ref Unsafe.As<UInt64x8, ulong>(
                ref target);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrX),
                value.X);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrY),
                value.Y);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrZ),
                value.Z);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrW),
                value.W);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrI),
                value.I);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrJ),
                value.J);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrK),
                value.K);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrL),
                value.L);
        }

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        public UInt64x8 ComputeAverage(long denominator) =>
            this / FromScalar((ulong)denominator);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt64x8 operator +(
            UInt64x8 current,
            UInt8x8 toAccumulate) =>
            current + ConvertFrom_byte(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt64x8 operator +(
            UInt8x8 toAccumulate,
            UInt64x8 current) =>
            ConvertFrom_byte(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt64x8 operator -(
            UInt64x8 current,
            UInt8x8 toAccumulate) =>
            current - ConvertFrom_byte(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt64x8 operator -(
            UInt8x8 toAccumulate,
            UInt64x8 current) =>
            ConvertFrom_byte(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref UInt64x8 target,
            UInt8x8 value) =>
            AtomicAdd(ref target, ConvertFrom_byte(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt64x8 ConvertFrom_byte(
            UInt8x8 other) =>
            new UInt64x8((ulong)other.X, (ulong)other.Y, (ulong)other.Z, (ulong)other.W, (ulong)other.I, (ulong)other.J, (ulong)other.K, (ulong)other.L);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt8x8 ConvertTo_byte(
            UInt64x8 current) =>
            new UInt8x8((byte)current.X, (byte)current.Y, (byte)current.Z, (byte)current.W, (byte)current.I, (byte)current.J, (byte)current.K, (byte)current.L);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt64x8 IAccumulationVectorType<
            UInt64x8,
            UInt8x8,
            byte>.ConvertFromBase(UInt8x8 other) =>
            ConvertFrom_byte(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt8x8 IAccumulationVectorType<
            UInt64x8,
            UInt8x8,
            byte>.ConvertToBase(UInt64x8 current) =>
            ConvertTo_byte(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public UInt64x8 ComputeAverage(byte denominator) =>
            this / FromScalar((ulong)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt64x8 operator +(
            UInt64x8 current,
            UInt16x8 toAccumulate) =>
            current + ConvertFrom_ushort(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt64x8 operator +(
            UInt16x8 toAccumulate,
            UInt64x8 current) =>
            ConvertFrom_ushort(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt64x8 operator -(
            UInt64x8 current,
            UInt16x8 toAccumulate) =>
            current - ConvertFrom_ushort(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt64x8 operator -(
            UInt16x8 toAccumulate,
            UInt64x8 current) =>
            ConvertFrom_ushort(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref UInt64x8 target,
            UInt16x8 value) =>
            AtomicAdd(ref target, ConvertFrom_ushort(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt64x8 ConvertFrom_ushort(
            UInt16x8 other) =>
            new UInt64x8((ulong)other.X, (ulong)other.Y, (ulong)other.Z, (ulong)other.W, (ulong)other.I, (ulong)other.J, (ulong)other.K, (ulong)other.L);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt16x8 ConvertTo_ushort(
            UInt64x8 current) =>
            new UInt16x8((ushort)current.X, (ushort)current.Y, (ushort)current.Z, (ushort)current.W, (ushort)current.I, (ushort)current.J, (ushort)current.K, (ushort)current.L);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt64x8 IAccumulationVectorType<
            UInt64x8,
            UInt16x8,
            ushort>.ConvertFromBase(UInt16x8 other) =>
            ConvertFrom_ushort(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt16x8 IAccumulationVectorType<
            UInt64x8,
            UInt16x8,
            ushort>.ConvertToBase(UInt64x8 current) =>
            ConvertTo_ushort(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public UInt64x8 ComputeAverage(ushort denominator) =>
            this / FromScalar((ulong)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt64x8 operator +(
            UInt64x8 current,
            UInt32x8 toAccumulate) =>
            current + ConvertFrom_uint(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt64x8 operator +(
            UInt32x8 toAccumulate,
            UInt64x8 current) =>
            ConvertFrom_uint(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt64x8 operator -(
            UInt64x8 current,
            UInt32x8 toAccumulate) =>
            current - ConvertFrom_uint(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt64x8 operator -(
            UInt32x8 toAccumulate,
            UInt64x8 current) =>
            ConvertFrom_uint(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref UInt64x8 target,
            UInt32x8 value) =>
            AtomicAdd(ref target, ConvertFrom_uint(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt64x8 ConvertFrom_uint(
            UInt32x8 other) =>
            new UInt64x8((ulong)other.X, (ulong)other.Y, (ulong)other.Z, (ulong)other.W, (ulong)other.I, (ulong)other.J, (ulong)other.K, (ulong)other.L);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt32x8 ConvertTo_uint(
            UInt64x8 current) =>
            new UInt32x8((uint)current.X, (uint)current.Y, (uint)current.Z, (uint)current.W, (uint)current.I, (uint)current.J, (uint)current.K, (uint)current.L);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt64x8 IAccumulationVectorType<
            UInt64x8,
            UInt32x8,
            uint>.ConvertFromBase(UInt32x8 other) =>
            ConvertFrom_uint(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt32x8 IAccumulationVectorType<
            UInt64x8,
            UInt32x8,
            uint>.ConvertToBase(UInt64x8 current) =>
            ConvertTo_uint(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public UInt64x8 ComputeAverage(uint denominator) =>
            this / FromScalar((ulong)denominator);


        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt64x8 ConvertFrom_ulong(
            UInt64x8 other) =>
            new UInt64x8((ulong)other.X, (ulong)other.Y, (ulong)other.Z, (ulong)other.W, (ulong)other.I, (ulong)other.J, (ulong)other.K, (ulong)other.L);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt64x8 ConvertTo_ulong(
            UInt64x8 current) =>
            new UInt64x8((ulong)current.X, (ulong)current.Y, (ulong)current.Z, (ulong)current.W, (ulong)current.I, (ulong)current.J, (ulong)current.K, (ulong)current.L);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt64x8 IAccumulationVectorType<
            UInt64x8,
            UInt64x8,
            ulong>.ConvertFromBase(UInt64x8 other) =>
            ConvertFrom_ulong(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt64x8 IAccumulationVectorType<
            UInt64x8,
            UInt64x8,
            ulong>.ConvertToBase(UInt64x8 current) =>
            ConvertTo_ulong(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public UInt64x8 ComputeAverage(ulong denominator) =>
            this / FromScalar((ulong)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt64x8 operator +(
            UInt64x8 current,
            Float32x8 toAccumulate) =>
            current + ConvertFrom_float(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt64x8 operator +(
            Float32x8 toAccumulate,
            UInt64x8 current) =>
            ConvertFrom_float(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt64x8 operator -(
            UInt64x8 current,
            Float32x8 toAccumulate) =>
            current - ConvertFrom_float(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt64x8 operator -(
            Float32x8 toAccumulate,
            UInt64x8 current) =>
            ConvertFrom_float(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref UInt64x8 target,
            Float32x8 value) =>
            AtomicAdd(ref target, ConvertFrom_float(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt64x8 ConvertFrom_float(
            Float32x8 other) =>
            new UInt64x8((ulong)other.X, (ulong)other.Y, (ulong)other.Z, (ulong)other.W, (ulong)other.I, (ulong)other.J, (ulong)other.K, (ulong)other.L);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float32x8 ConvertTo_float(
            UInt64x8 current) =>
            new Float32x8((float)current.X, (float)current.Y, (float)current.Z, (float)current.W, (float)current.I, (float)current.J, (float)current.K, (float)current.L);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt64x8 IAccumulationVectorType<
            UInt64x8,
            Float32x8,
            float>.ConvertFromBase(Float32x8 other) =>
            ConvertFrom_float(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float32x8 IAccumulationVectorType<
            UInt64x8,
            Float32x8,
            float>.ConvertToBase(UInt64x8 current) =>
            ConvertTo_float(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public UInt64x8 ComputeAverage(float denominator) =>
            this / FromScalar((ulong)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt64x8 operator +(
            UInt64x8 current,
            Float64x8 toAccumulate) =>
            current + ConvertFrom_double(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt64x8 operator +(
            Float64x8 toAccumulate,
            UInt64x8 current) =>
            ConvertFrom_double(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt64x8 operator -(
            UInt64x8 current,
            Float64x8 toAccumulate) =>
            current - ConvertFrom_double(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static UInt64x8 operator -(
            Float64x8 toAccumulate,
            UInt64x8 current) =>
            ConvertFrom_double(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref UInt64x8 target,
            Float64x8 value) =>
            AtomicAdd(ref target, ConvertFrom_double(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt64x8 ConvertFrom_double(
            Float64x8 other) =>
            new UInt64x8((ulong)other.X, (ulong)other.Y, (ulong)other.Z, (ulong)other.W, (ulong)other.I, (ulong)other.J, (ulong)other.K, (ulong)other.L);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float64x8 ConvertTo_double(
            UInt64x8 current) =>
            new Float64x8((double)current.X, (double)current.Y, (double)current.Z, (double)current.W, (double)current.I, (double)current.J, (double)current.K, (double)current.L);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt64x8 IAccumulationVectorType<
            UInt64x8,
            Float64x8,
            double>.ConvertFromBase(Float64x8 other) =>
            ConvertFrom_double(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float64x8 IAccumulationVectorType<
            UInt64x8,
            Float64x8,
            double>.ConvertToBase(UInt64x8 current) =>
            ConvertTo_double(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public UInt64x8 ComputeAverage(double denominator) =>
            this / FromScalar((ulong)denominator);

        /// <summary>
        /// Converts this instance into an unsafe span instance.
        /// </summary>
        /// <returns>The readonly span instance.</returns>
        public unsafe ReadOnlySpan<ulong> AsSpan() =>
            new(Unsafe.AsPointer(ref Unsafe.AsRef(this)), 8);

        /// <summary>
        /// Iterates over all elements by applying the given iterator to each element.
        /// </summary>
        /// <typeparam name="TIterator">The managed iterator type.</typeparam>
        /// <param name="iterator">The iterator to invoke.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ForEach<TIterator>(ref TIterator iterator)
            where TIterator : struct, IVectorElementIterator<
            UInt64x8,
            ulong>
        {
            iterator.Iterate(X, 0);
            iterator.Iterate(Y, 1);
            iterator.Iterate(Z, 2);
            iterator.Iterate(W, 3);
            iterator.Iterate(I, 4);
            iterator.Iterate(J, 5);
            iterator.Iterate(K, 6);
            iterator.Iterate(L, 7);
        }

        /// <summary>
        /// Converts this vector instance to a string.
        /// </summary>
        public override string ToString() =>
            $"{X}, {Y}, {Z}, {W}, {I}, {J}, {K}, {L}";

        /// <summary>
        /// Converts this vector instance to a string.
        /// </summary>
        public string ToString(string? format, IFormatProvider? formatProvider) =>
            $"{X.ToString(format, formatProvider)}, {Y.ToString(format, formatProvider)}, {Z.ToString(format, formatProvider)}, {W.ToString(format, formatProvider)}, {I.ToString(format, formatProvider)}, {J.ToString(format, formatProvider)}, {K.ToString(format, formatProvider)}, {L.ToString(format, formatProvider)}";

        /// <summary>
        /// Returns true.
        /// </summary>
        public static bool IsCanonical(UInt64x8 value) => true;

        /// <summary>
        /// Returns false.
        /// </summary>
        public static bool IsComplexNumber(UInt64x8 value) => false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsEvenInteger(UInt64x8 value) =>
            ulong.IsEvenInteger(value.X) & ulong.IsEvenInteger(value.Y) & ulong.IsEvenInteger(value.Z) & ulong.IsEvenInteger(value.W) & ulong.IsEvenInteger(value.I) & ulong.IsEvenInteger(value.J) & ulong.IsEvenInteger(value.K) & ulong.IsEvenInteger(value.L);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsFinite(UInt64x8 value) =>
            true;

        /// <summary>
        /// Returns false.
        /// </summary>
        public static bool IsImaginaryNumber(UInt64x8 value) => false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsInfinity(UInt64x8 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsInteger(UInt64x8 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNaN(UInt64x8 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNegative(UInt64x8 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNegativeInfinity(UInt64x8 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNormal(UInt64x8 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsOddInteger(UInt64x8 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsPositive(UInt64x8 value) =>
            true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsPositiveInfinity(UInt64x8 value) =>
            false;

        /// <summary>
        /// Returns true.
        /// </summary>
        public static bool IsRealNumber(UInt64x8 value) => true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsSubnormal(UInt64x8 value) =>
            false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsZero(UInt64x8 value) =>
            value == Zero;

        /// <summary>
        /// Returns the absolute value.
        /// </summary>
        public static UInt64x8 Abs(UInt64x8 value) =>
            value;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt64x8 operator +(UInt64x8 left, UInt64x8 right) =>
            new UInt64x8((ulong)(left.X + right.X), (ulong)(left.Y + right.Y), (ulong)(left.Z + right.Z), (ulong)(left.W + right.W), (ulong)(left.I + right.I), (ulong)(left.J + right.J), (ulong)(left.K + right.K), (ulong)(left.L + right.L));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt64x8 operator --(UInt64x8 value) => value - One;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt64x8 operator /(UInt64x8 left, UInt64x8 right) =>
            new UInt64x8((ulong)(left.X / right.X), (ulong)(left.Y / right.Y), (ulong)(left.Z / right.Z), (ulong)(left.W / right.W), (ulong)(left.I / right.I), (ulong)(left.J / right.J), (ulong)(left.K / right.K), (ulong)(left.L / right.L));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt64x8 operator ++(UInt64x8 value) => value + One;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt64x8 operator *(UInt64x8 left, UInt64x8 right) =>
            new UInt64x8((ulong)(left.X * right.X), (ulong)(left.Y * right.Y), (ulong)(left.Z * right.Z), (ulong)(left.W * right.W), (ulong)(left.I * right.I), (ulong)(left.J * right.J), (ulong)(left.K * right.K), (ulong)(left.L * right.L));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt64x8 operator -(UInt64x8 left, UInt64x8 right) =>
            new UInt64x8((ulong)(left.X - right.X), (ulong)(left.Y - right.Y), (ulong)(left.Z - right.Z), (ulong)(left.W - right.W), (ulong)(left.I - right.I), (ulong)(left.J - right.J), (ulong)(left.K - right.K), (ulong)(left.L - right.L));

        /// <summary>
        /// Not supported operation.
        /// </summary>
        static UInt64x8 IUnaryNegationOperators<UInt64x8, UInt64x8>.
            operator -(UInt64x8 value) => value;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt64x8 operator +(UInt64x8 value) => value;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt64x8 MaxMagnitude(UInt64x8 x, UInt64x8 y) =>
            Max(x, y);

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt64x8 MaxMagnitudeNumber(UInt64x8 x, UInt64x8 y) =>
            MaxMagnitude(x, y);

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt64x8 MinMagnitude(UInt64x8 x, UInt64x8 y) =>
            Min(x, y);

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static UInt64x8 MinMagnitudeNumber(UInt64x8 x, UInt64x8 y) =>
            MinMagnitude(x, y);

        // Not supported operations

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static UInt64x8 IParsable<UInt64x8>.Parse(
            string s,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static UInt64x8 ISpanParsable<UInt64x8>.Parse(
            ReadOnlySpan<char> s,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static UInt64x8 INumberBase<UInt64x8>.Parse(
            ReadOnlySpan<char> s,
            NumberStyles style,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static UInt64x8 INumberBase<UInt64x8>.Parse(
            string s,
            NumberStyles style,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        bool ISpanFormattable.TryFormat(
            Span<char> destination,
            out int charsWritten,
            ReadOnlySpan<char> format,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool IParsable<UInt64x8>.TryParse(
            string? s,
            IFormatProvider? provider,
            out UInt64x8 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given span into a vectorized instance.
        /// </summary>
        static bool ISpanParsable<UInt64x8>.TryParse(
            ReadOnlySpan<char> s,
            IFormatProvider? provider,
            out UInt64x8 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool INumberBase<UInt64x8>.TryParse(
            ReadOnlySpan<char> s,
            NumberStyles style,
            IFormatProvider? provider,
            out UInt64x8 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool INumberBase<UInt64x8>.TryParse(
            string? s,
            NumberStyles style,
            IFormatProvider? provider,
            out UInt64x8 result) =>
            throw new NotSupportedException();

        static bool INumberBase<UInt64x8>.TryConvertFromChecked<TOther>(
            TOther value,
            out UInt64x8 result) =>
            throw new NotSupportedException();
        static bool INumberBase<UInt64x8>.TryConvertFromSaturating<TOther>(
            TOther value,
            out UInt64x8 result) =>
            throw new NotSupportedException();
        static bool INumberBase<UInt64x8>.TryConvertFromTruncating<TOther>(
            TOther value,
            out UInt64x8 result) =>
            throw new NotSupportedException();
        static bool INumberBase<UInt64x8>.TryConvertToChecked<TOther>(
            UInt64x8 value,
            out TOther result) =>
            throw new NotSupportedException();
        static bool INumberBase<UInt64x8>.TryConvertToSaturating<TOther>(
            UInt64x8 value,
            out TOther result) =>
            throw new NotSupportedException();
        static bool INumberBase<UInt64x8>.TryConvertToTruncating<TOther>(
            UInt64x8 value,
            out TOther result) =>
            throw new NotSupportedException();
    }

    /// <summary>
    /// Represents a vectorized float type with length 2.
    /// </summary>
    public readonly record struct Float32x2(
        float X, float Y) :
        IVectorType<Float32x2, float>
        , IAccumulationVectorType<
            Float32x2,
            Float32x2,
            float>
        , IAccumulationVectorType<
            Float32x2,
            UInt8x2,
            byte>
        , IAccumulationVectorType<
            Float32x2,
            Int8x2,
            sbyte>
        , IAccumulationVectorType<
            Float32x2,
            Int16x2,
            short>
        , IAccumulationVectorType<
            Float32x2,
            UInt16x2,
            ushort>
        , IAccumulationVectorType<
            Float32x2,
            Int32x2,
            int>
        , IAccumulationVectorType<
            Float32x2,
            UInt32x2,
            uint>
        , IAccumulationVectorType<
            Float32x2,
            Int64x2,
            long>
        , IAccumulationVectorType<
            Float32x2,
            UInt64x2,
            ulong>
    {
        /// <summary>
        /// The offset of the X field in bytes.
        /// </summary>
        public static readonly int OffsetX =
            sizeof(float) * 0;

        /// <summary>
        /// The offset of the X field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrX =>
            new UIntPtr((uint)OffsetX);
        /// <summary>
        /// The offset of the Y field in bytes.
        /// </summary>
        public static readonly int OffsetY =
            sizeof(float) * 1;

        /// <summary>
        /// The offset of the Y field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrY =>
            new UIntPtr((uint)OffsetY);

        /// <summary>
        /// Returns the length of this vector which is 2.
        /// </summary>
        public static int Length => 2;

        /// <summary>
        /// Returns the radix of the underlying value.
        /// </summary>
        public static int Radix => 10;

        /// <summary>
        /// Returns an invalid value (min [signed types], max value [unsigned] or NaN).
        /// </summary>
        public static Float32x2 Invalid => FromScalar(
            float.NaN
        );

        /// <summary>
        /// Returns the value zero.
        /// </summary>
        public static Float32x2 Zero => new();

        /// <summary>
        /// Returns the value one.
        /// </summary>
        public static Float32x2 One => FromScalar((1f));

        /// <summary>
        /// Returns the value zero.
        /// </summary>
        public static Float32x2 AdditiveIdentity => Zero;

        /// <summary>
        /// Returns the value one.
        /// </summary>
        public static Float32x2 MultiplicativeIdentity => One;

        /// <summary>
        /// Computes the min value of both.
        /// </summary>
        /// <param name="first">The first value.</param>
        /// <param name="second">The second value.</param>
        /// <returns>The min value.</returns>
        public static Float32x2 Min(
            Float32x2 first,
            Float32x2 second) =>
            new Float32x2((float)Math.Min(first.X, second.X), (float)Math.Min(first.Y, second.Y));

        /// <summary>
        /// Computes the max value of both.
        /// </summary>
        /// <param name="first">The first value.</param>
        /// <param name="second">The second value.</param>
        /// <returns>The max value.</returns>
        public static Float32x2 Max(
            Float32x2 first,
            Float32x2 second) =>
            new Float32x2((float)Math.Max(first.X, second.X), (float)Math.Max(first.Y, second.Y));

        /// <summary>
        /// Clamps the given value.
        /// </summary>
        /// <param name="value">The value to clamp.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The clamped value.</returns>
        public static Float32x2 Clamp(
            Float32x2 value,
            Float32x2 min,
            Float32x2 max) =>
            Max(Min(value, max), min);

        /// <summary>
        /// Creates a random scalar instance falling into the range of min max.
        /// </summary>
        /// <param name="random">The random provider to use.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The created random scalar instance.</returns>
        public static float GetRandomScalar<TRandom>(
            ref TRandom random,
            float min,
            float max)
            where TRandom : struct, IRandomProvider =>
            (float)RandomExtensions.
                Next(ref random, min, max);

        /// <summary>
        /// Creates a random vector instance falling into the range of min max.
        /// </summary>
        /// <param name="random">The random provider to use.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The created random vector instance.</returns>
        public static Float32x2 GetRandom<TRandom>(
            ref TRandom random,
            Float32x2 min,
            Float32x2 max)
            where TRandom : struct, IRandomProvider
        {
            float x = GetRandomScalar(
                ref random, min.X, max.X);
            float y = GetRandomScalar(
                ref random, min.Y, max.Y);
            return new Float32x2(x, y);
        }

        /// <summary>
        /// Creates a vector instance from the given source view.
        /// </summary>
        /// <typeparam name="TStride">The custom stride type.</typeparam>
        /// <param name="sourceView">The source view.</param>
        /// <param name="index">The source base index.</param>
        /// <returns>The vector instance.</returns>
        public static Float32x2 FromElementView<TStride>(
            ArrayView1D<float, TStride> sourceView,
            Index1D index)
            where TStride : struct, IStride1D =>
            new Float32x2(
                sourceView[index + 0],
                sourceView[index + 1]
                );

        /// <summary>
        /// Serializes the current vector instance into the given target view.
        /// </summary>
        /// <typeparam name="TStride">The custom stride type.</typeparam>
        /// <param name="targetView">The target view.</param>
        /// <param name="index">The target base index.</param>
        public void ToElementView<TStride>(
            ArrayView1D<float, TStride> targetView,
            Index1D index)
            where TStride : struct, IStride1D
        {
            targetView[index + 0] = X;
            targetView[index + 1] = Y;
        }

        /// <summary>
        /// Creates a vector instance from the given source view.
        /// </summary>
        /// <param name="sourceView">The source view.</param>
        /// <param name="index">The source base index.</param>
        /// <returns>The vector instance.</returns>
        public static Float32x2 FromElementView(
            SingleVectorView<float> sourceView,
            Index1D index) =>
            new Float32x2(
                sourceView[index + 0],
                sourceView[index + 1]
                );

        /// <summary>
        /// Serializes the current vector instance into the given target view.
        /// </summary>
        /// <param name="targetView">The target view.</param>
        /// <param name="index">The target base index.</param>
        public void ToElementView(
            SingleVectorView<float> targetView,
            Index1D index)
        {
            targetView[index + 0] = X;
            targetView[index + 1] = Y;
        }

        /// <summary>
        /// Converts a scalar value into the current vectorized type.
        /// </summary>
        /// <param name="scalar">The scalar element type.</param>
        /// <returns>The created vectorized type.</returns>
        public static Float32x2 FromScalar(float scalar) =>
            new Float32x2(scalar, scalar);

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        public static void AtomicAdd(ref Float32x2 target, Float32x2 value)
        {
            ref var elementRef = ref Unsafe.As<Float32x2, float>(
                ref target);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrX),
                value.X);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrY),
                value.Y);
        }

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        public Float32x2 ComputeAverage(long denominator) =>
            this / FromScalar((float)denominator);
        

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float32x2 ConvertFrom_float(
            Float32x2 other) =>
            new Float32x2((float)other.X, (float)other.Y);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float32x2 ConvertTo_float(
            Float32x2 current) =>
            new Float32x2((float)current.X, (float)current.Y);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float32x2 IAccumulationVectorType<
            Float32x2,
            Float32x2,
            float>.ConvertFromBase(Float32x2 other) =>
            ConvertFrom_float(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float32x2 IAccumulationVectorType<
            Float32x2,
            Float32x2,
            float>.ConvertToBase(Float32x2 current) =>
            ConvertTo_float(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(true)]
        public Float32x2 ComputeAverage(float denominator) =>
            this / FromScalar((float)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float32x2 operator +(
            Float32x2 current,
            UInt8x2 toAccumulate) =>
            current + ConvertFrom_byte(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float32x2 operator +(
            UInt8x2 toAccumulate,
            Float32x2 current) =>
            ConvertFrom_byte(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float32x2 operator -(
            Float32x2 current,
            UInt8x2 toAccumulate) =>
            current - ConvertFrom_byte(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float32x2 operator -(
            UInt8x2 toAccumulate,
            Float32x2 current) =>
            ConvertFrom_byte(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref Float32x2 target,
            UInt8x2 value) =>
            AtomicAdd(ref target, ConvertFrom_byte(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float32x2 ConvertFrom_byte(
            UInt8x2 other) =>
            new Float32x2((float)other.X, (float)other.Y);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt8x2 ConvertTo_byte(
            Float32x2 current) =>
            new UInt8x2((byte)current.X, (byte)current.Y);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float32x2 IAccumulationVectorType<
            Float32x2,
            UInt8x2,
            byte>.ConvertFromBase(UInt8x2 other) =>
            ConvertFrom_byte(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt8x2 IAccumulationVectorType<
            Float32x2,
            UInt8x2,
            byte>.ConvertToBase(Float32x2 current) =>
            ConvertTo_byte(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public Float32x2 ComputeAverage(byte denominator) =>
            this / FromScalar((float)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float32x2 operator +(
            Float32x2 current,
            Int8x2 toAccumulate) =>
            current + ConvertFrom_sbyte(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float32x2 operator +(
            Int8x2 toAccumulate,
            Float32x2 current) =>
            ConvertFrom_sbyte(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float32x2 operator -(
            Float32x2 current,
            Int8x2 toAccumulate) =>
            current - ConvertFrom_sbyte(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float32x2 operator -(
            Int8x2 toAccumulate,
            Float32x2 current) =>
            ConvertFrom_sbyte(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref Float32x2 target,
            Int8x2 value) =>
            AtomicAdd(ref target, ConvertFrom_sbyte(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float32x2 ConvertFrom_sbyte(
            Int8x2 other) =>
            new Float32x2((float)other.X, (float)other.Y);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int8x2 ConvertTo_sbyte(
            Float32x2 current) =>
            new Int8x2((sbyte)current.X, (sbyte)current.Y);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float32x2 IAccumulationVectorType<
            Float32x2,
            Int8x2,
            sbyte>.ConvertFromBase(Int8x2 other) =>
            ConvertFrom_sbyte(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int8x2 IAccumulationVectorType<
            Float32x2,
            Int8x2,
            sbyte>.ConvertToBase(Float32x2 current) =>
            ConvertTo_sbyte(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public Float32x2 ComputeAverage(sbyte denominator) =>
            this / FromScalar((float)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float32x2 operator +(
            Float32x2 current,
            Int16x2 toAccumulate) =>
            current + ConvertFrom_short(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float32x2 operator +(
            Int16x2 toAccumulate,
            Float32x2 current) =>
            ConvertFrom_short(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float32x2 operator -(
            Float32x2 current,
            Int16x2 toAccumulate) =>
            current - ConvertFrom_short(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float32x2 operator -(
            Int16x2 toAccumulate,
            Float32x2 current) =>
            ConvertFrom_short(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(true)]
        public static void AtomicAdd(
            ref Float32x2 target,
            Int16x2 value) =>
            AtomicAdd(ref target, ConvertFrom_short(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float32x2 ConvertFrom_short(
            Int16x2 other) =>
            new Float32x2((float)other.X, (float)other.Y);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int16x2 ConvertTo_short(
            Float32x2 current) =>
            new Int16x2((short)current.X, (short)current.Y);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float32x2 IAccumulationVectorType<
            Float32x2,
            Int16x2,
            short>.ConvertFromBase(Int16x2 other) =>
            ConvertFrom_short(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int16x2 IAccumulationVectorType<
            Float32x2,
            Int16x2,
            short>.ConvertToBase(Float32x2 current) =>
            ConvertTo_short(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(true)]
        public Float32x2 ComputeAverage(short denominator) =>
            this / FromScalar((float)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float32x2 operator +(
            Float32x2 current,
            UInt16x2 toAccumulate) =>
            current + ConvertFrom_ushort(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float32x2 operator +(
            UInt16x2 toAccumulate,
            Float32x2 current) =>
            ConvertFrom_ushort(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float32x2 operator -(
            Float32x2 current,
            UInt16x2 toAccumulate) =>
            current - ConvertFrom_ushort(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float32x2 operator -(
            UInt16x2 toAccumulate,
            Float32x2 current) =>
            ConvertFrom_ushort(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref Float32x2 target,
            UInt16x2 value) =>
            AtomicAdd(ref target, ConvertFrom_ushort(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float32x2 ConvertFrom_ushort(
            UInt16x2 other) =>
            new Float32x2((float)other.X, (float)other.Y);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt16x2 ConvertTo_ushort(
            Float32x2 current) =>
            new UInt16x2((ushort)current.X, (ushort)current.Y);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float32x2 IAccumulationVectorType<
            Float32x2,
            UInt16x2,
            ushort>.ConvertFromBase(UInt16x2 other) =>
            ConvertFrom_ushort(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt16x2 IAccumulationVectorType<
            Float32x2,
            UInt16x2,
            ushort>.ConvertToBase(Float32x2 current) =>
            ConvertTo_ushort(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public Float32x2 ComputeAverage(ushort denominator) =>
            this / FromScalar((float)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float32x2 operator +(
            Float32x2 current,
            Int32x2 toAccumulate) =>
            current + ConvertFrom_int(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float32x2 operator +(
            Int32x2 toAccumulate,
            Float32x2 current) =>
            ConvertFrom_int(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float32x2 operator -(
            Float32x2 current,
            Int32x2 toAccumulate) =>
            current - ConvertFrom_int(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float32x2 operator -(
            Int32x2 toAccumulate,
            Float32x2 current) =>
            ConvertFrom_int(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(true)]
        public static void AtomicAdd(
            ref Float32x2 target,
            Int32x2 value) =>
            AtomicAdd(ref target, ConvertFrom_int(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float32x2 ConvertFrom_int(
            Int32x2 other) =>
            new Float32x2((float)other.X, (float)other.Y);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int32x2 ConvertTo_int(
            Float32x2 current) =>
            new Int32x2((int)current.X, (int)current.Y);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float32x2 IAccumulationVectorType<
            Float32x2,
            Int32x2,
            int>.ConvertFromBase(Int32x2 other) =>
            ConvertFrom_int(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int32x2 IAccumulationVectorType<
            Float32x2,
            Int32x2,
            int>.ConvertToBase(Float32x2 current) =>
            ConvertTo_int(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(true)]
        public Float32x2 ComputeAverage(int denominator) =>
            this / FromScalar((float)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float32x2 operator +(
            Float32x2 current,
            UInt32x2 toAccumulate) =>
            current + ConvertFrom_uint(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float32x2 operator +(
            UInt32x2 toAccumulate,
            Float32x2 current) =>
            ConvertFrom_uint(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float32x2 operator -(
            Float32x2 current,
            UInt32x2 toAccumulate) =>
            current - ConvertFrom_uint(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float32x2 operator -(
            UInt32x2 toAccumulate,
            Float32x2 current) =>
            ConvertFrom_uint(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref Float32x2 target,
            UInt32x2 value) =>
            AtomicAdd(ref target, ConvertFrom_uint(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float32x2 ConvertFrom_uint(
            UInt32x2 other) =>
            new Float32x2((float)other.X, (float)other.Y);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt32x2 ConvertTo_uint(
            Float32x2 current) =>
            new UInt32x2((uint)current.X, (uint)current.Y);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float32x2 IAccumulationVectorType<
            Float32x2,
            UInt32x2,
            uint>.ConvertFromBase(UInt32x2 other) =>
            ConvertFrom_uint(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt32x2 IAccumulationVectorType<
            Float32x2,
            UInt32x2,
            uint>.ConvertToBase(Float32x2 current) =>
            ConvertTo_uint(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public Float32x2 ComputeAverage(uint denominator) =>
            this / FromScalar((float)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float32x2 operator +(
            Float32x2 current,
            Int64x2 toAccumulate) =>
            current + ConvertFrom_long(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float32x2 operator +(
            Int64x2 toAccumulate,
            Float32x2 current) =>
            ConvertFrom_long(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float32x2 operator -(
            Float32x2 current,
            Int64x2 toAccumulate) =>
            current - ConvertFrom_long(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float32x2 operator -(
            Int64x2 toAccumulate,
            Float32x2 current) =>
            ConvertFrom_long(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(true)]
        public static void AtomicAdd(
            ref Float32x2 target,
            Int64x2 value) =>
            AtomicAdd(ref target, ConvertFrom_long(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float32x2 ConvertFrom_long(
            Int64x2 other) =>
            new Float32x2((float)other.X, (float)other.Y);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int64x2 ConvertTo_long(
            Float32x2 current) =>
            new Int64x2((long)current.X, (long)current.Y);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float32x2 IAccumulationVectorType<
            Float32x2,
            Int64x2,
            long>.ConvertFromBase(Int64x2 other) =>
            ConvertFrom_long(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int64x2 IAccumulationVectorType<
            Float32x2,
            Int64x2,
            long>.ConvertToBase(Float32x2 current) =>
            ConvertTo_long(current);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float32x2 operator +(
            Float32x2 current,
            UInt64x2 toAccumulate) =>
            current + ConvertFrom_ulong(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float32x2 operator +(
            UInt64x2 toAccumulate,
            Float32x2 current) =>
            ConvertFrom_ulong(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float32x2 operator -(
            Float32x2 current,
            UInt64x2 toAccumulate) =>
            current - ConvertFrom_ulong(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float32x2 operator -(
            UInt64x2 toAccumulate,
            Float32x2 current) =>
            ConvertFrom_ulong(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref Float32x2 target,
            UInt64x2 value) =>
            AtomicAdd(ref target, ConvertFrom_ulong(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float32x2 ConvertFrom_ulong(
            UInt64x2 other) =>
            new Float32x2((float)other.X, (float)other.Y);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt64x2 ConvertTo_ulong(
            Float32x2 current) =>
            new UInt64x2((ulong)current.X, (ulong)current.Y);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float32x2 IAccumulationVectorType<
            Float32x2,
            UInt64x2,
            ulong>.ConvertFromBase(UInt64x2 other) =>
            ConvertFrom_ulong(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt64x2 IAccumulationVectorType<
            Float32x2,
            UInt64x2,
            ulong>.ConvertToBase(Float32x2 current) =>
            ConvertTo_ulong(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public Float32x2 ComputeAverage(ulong denominator) =>
            this / FromScalar((float)denominator);

        /// <summary>
        /// Converts this instance into an unsafe span instance.
        /// </summary>
        /// <returns>The readonly span instance.</returns>
        public unsafe ReadOnlySpan<float> AsSpan() =>
            new(Unsafe.AsPointer(ref Unsafe.AsRef(this)), 2);

        /// <summary>
        /// Iterates over all elements by applying the given iterator to each element.
        /// </summary>
        /// <typeparam name="TIterator">The managed iterator type.</typeparam>
        /// <param name="iterator">The iterator to invoke.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ForEach<TIterator>(ref TIterator iterator)
            where TIterator : struct, IVectorElementIterator<
            Float32x2,
            float>
        {
            iterator.Iterate(X, 0);
            iterator.Iterate(Y, 1);
        }

        /// <summary>
        /// Converts this vector instance to a string.
        /// </summary>
        public override string ToString() =>
            $"{X}, {Y}";

        /// <summary>
        /// Converts this vector instance to a string.
        /// </summary>
        public string ToString(string? format, IFormatProvider? formatProvider) =>
            $"{X.ToString(format, formatProvider)}, {Y.ToString(format, formatProvider)}";

        /// <summary>
        /// Returns true.
        /// </summary>
        public static bool IsCanonical(Float32x2 value) => true;

        /// <summary>
        /// Returns false.
        /// </summary>
        public static bool IsComplexNumber(Float32x2 value) => false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsEvenInteger(Float32x2 value) =>
            float.IsEvenInteger(value.X) & float.IsEvenInteger(value.Y);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsFinite(Float32x2 value) =>
            float.IsFinite(value.X) & float.IsFinite(value.Y);

        /// <summary>
        /// Returns false.
        /// </summary>
        public static bool IsImaginaryNumber(Float32x2 value) => false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsInfinity(Float32x2 value) =>
            float.IsInfinity(value.X) | float.IsInfinity(value.Y);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsInteger(Float32x2 value) =>
            float.IsInteger(value.X) & float.IsInteger(value.Y);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNaN(Float32x2 value) =>
            float.IsNaN(value.X) | float.IsNaN(value.Y);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNegative(Float32x2 value) =>
            float.IsNegative(value.X) & float.IsNegative(value.Y);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNegativeInfinity(Float32x2 value) =>
            float.IsNegativeInfinity(value.X) | float.IsNegativeInfinity(value.Y);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNormal(Float32x2 value) =>
            float.IsNormal(value.X) & float.IsNormal(value.Y);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsOddInteger(Float32x2 value) =>
            float.IsOddInteger(value.X) & float.IsOddInteger(value.Y);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsPositive(Float32x2 value) =>
            float.IsPositive(value.X) & float.IsPositive(value.Y);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsPositiveInfinity(Float32x2 value) =>
            float.IsPositiveInfinity(value.X) | float.IsPositiveInfinity(value.Y);

        /// <summary>
        /// Returns true.
        /// </summary>
        public static bool IsRealNumber(Float32x2 value) => true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsSubnormal(Float32x2 value) =>
            float.IsSubnormal(value.X) & float.IsSubnormal(value.Y);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsZero(Float32x2 value) =>
            Abs(value) == Zero;

        /// <summary>
        /// Returns the absolute value.
        /// </summary>
        public static Float32x2 Abs(Float32x2 value) =>
            new Float32x2(Math.Abs(value.X), Math.Abs(value.Y));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Float32x2 operator +(Float32x2 left, Float32x2 right) =>
            new Float32x2((float)(left.X + right.X), (float)(left.Y + right.Y));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Float32x2 operator --(Float32x2 value) => value - One;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Float32x2 operator /(Float32x2 left, Float32x2 right) =>
            new Float32x2((float)(left.X / right.X), (float)(left.Y / right.Y));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Float32x2 operator ++(Float32x2 value) => value + One;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Float32x2 operator *(Float32x2 left, Float32x2 right) =>
            new Float32x2((float)(left.X * right.X), (float)(left.Y * right.Y));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Float32x2 operator -(Float32x2 left, Float32x2 right) =>
            new Float32x2((float)(left.X - right.X), (float)(left.Y - right.Y));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Float32x2 operator -(Float32x2 value) =>
            new Float32x2((float)-value.X, (float)-value.Y);

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Float32x2 operator +(Float32x2 value) => value;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Float32x2 MaxMagnitude(Float32x2 x, Float32x2 y) =>
            new Float32x2(float.MaxMagnitude(x.X, y.X), float.MaxMagnitude(x.Y, y.Y));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Float32x2 MaxMagnitudeNumber(Float32x2 x, Float32x2 y) =>
            new Float32x2(float.MaxMagnitudeNumber(x.X, y.X), float.MaxMagnitudeNumber(x.Y, y.Y));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Float32x2 MinMagnitude(Float32x2 x, Float32x2 y) =>
            new Float32x2(float.MinMagnitude(x.X, y.X), float.MinMagnitude(x.Y, y.Y));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Float32x2 MinMagnitudeNumber(Float32x2 x, Float32x2 y) =>
            new Float32x2(float.MinMagnitudeNumber(x.X, y.X), float.MinMagnitudeNumber(x.Y, y.Y));

        // Not supported operations

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static Float32x2 IParsable<Float32x2>.Parse(
            string s,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static Float32x2 ISpanParsable<Float32x2>.Parse(
            ReadOnlySpan<char> s,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static Float32x2 INumberBase<Float32x2>.Parse(
            ReadOnlySpan<char> s,
            NumberStyles style,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static Float32x2 INumberBase<Float32x2>.Parse(
            string s,
            NumberStyles style,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        bool ISpanFormattable.TryFormat(
            Span<char> destination,
            out int charsWritten,
            ReadOnlySpan<char> format,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool IParsable<Float32x2>.TryParse(
            string? s,
            IFormatProvider? provider,
            out Float32x2 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given span into a vectorized instance.
        /// </summary>
        static bool ISpanParsable<Float32x2>.TryParse(
            ReadOnlySpan<char> s,
            IFormatProvider? provider,
            out Float32x2 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool INumberBase<Float32x2>.TryParse(
            ReadOnlySpan<char> s,
            NumberStyles style,
            IFormatProvider? provider,
            out Float32x2 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool INumberBase<Float32x2>.TryParse(
            string? s,
            NumberStyles style,
            IFormatProvider? provider,
            out Float32x2 result) =>
            throw new NotSupportedException();

        static bool INumberBase<Float32x2>.TryConvertFromChecked<TOther>(
            TOther value,
            out Float32x2 result) =>
            throw new NotSupportedException();
        static bool INumberBase<Float32x2>.TryConvertFromSaturating<TOther>(
            TOther value,
            out Float32x2 result) =>
            throw new NotSupportedException();
        static bool INumberBase<Float32x2>.TryConvertFromTruncating<TOther>(
            TOther value,
            out Float32x2 result) =>
            throw new NotSupportedException();
        static bool INumberBase<Float32x2>.TryConvertToChecked<TOther>(
            Float32x2 value,
            out TOther result) =>
            throw new NotSupportedException();
        static bool INumberBase<Float32x2>.TryConvertToSaturating<TOther>(
            Float32x2 value,
            out TOther result) =>
            throw new NotSupportedException();
        static bool INumberBase<Float32x2>.TryConvertToTruncating<TOther>(
            Float32x2 value,
            out TOther result) =>
            throw new NotSupportedException();
    }

    /// <summary>
    /// Represents a vectorized float type with length 4.
    /// </summary>
    public readonly record struct Float32x4(
        float X, float Y, float Z, float W) :
        IVectorType<Float32x4, float>
        , IAccumulationVectorType<
            Float32x4,
            Float32x4,
            float>
        , IAccumulationVectorType<
            Float32x4,
            UInt8x4,
            byte>
        , IAccumulationVectorType<
            Float32x4,
            Int8x4,
            sbyte>
        , IAccumulationVectorType<
            Float32x4,
            Int16x4,
            short>
        , IAccumulationVectorType<
            Float32x4,
            UInt16x4,
            ushort>
        , IAccumulationVectorType<
            Float32x4,
            Int32x4,
            int>
        , IAccumulationVectorType<
            Float32x4,
            UInt32x4,
            uint>
        , IAccumulationVectorType<
            Float32x4,
            Int64x4,
            long>
        , IAccumulationVectorType<
            Float32x4,
            UInt64x4,
            ulong>
    {
        /// <summary>
        /// The offset of the X field in bytes.
        /// </summary>
        public static readonly int OffsetX =
            sizeof(float) * 0;

        /// <summary>
        /// The offset of the X field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrX =>
            new UIntPtr((uint)OffsetX);
        /// <summary>
        /// The offset of the Y field in bytes.
        /// </summary>
        public static readonly int OffsetY =
            sizeof(float) * 1;

        /// <summary>
        /// The offset of the Y field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrY =>
            new UIntPtr((uint)OffsetY);
        /// <summary>
        /// The offset of the Z field in bytes.
        /// </summary>
        public static readonly int OffsetZ =
            sizeof(float) * 2;

        /// <summary>
        /// The offset of the Z field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrZ =>
            new UIntPtr((uint)OffsetZ);
        /// <summary>
        /// The offset of the W field in bytes.
        /// </summary>
        public static readonly int OffsetW =
            sizeof(float) * 3;

        /// <summary>
        /// The offset of the W field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrW =>
            new UIntPtr((uint)OffsetW);

        /// <summary>
        /// Returns the length of this vector which is 4.
        /// </summary>
        public static int Length => 4;

        /// <summary>
        /// Returns the radix of the underlying value.
        /// </summary>
        public static int Radix => 10;

        /// <summary>
        /// Returns an invalid value (min [signed types], max value [unsigned] or NaN).
        /// </summary>
        public static Float32x4 Invalid => FromScalar(
            float.NaN
        );

        /// <summary>
        /// Returns the value zero.
        /// </summary>
        public static Float32x4 Zero => new();

        /// <summary>
        /// Returns the value one.
        /// </summary>
        public static Float32x4 One => FromScalar((1f));

        /// <summary>
        /// Returns the value zero.
        /// </summary>
        public static Float32x4 AdditiveIdentity => Zero;

        /// <summary>
        /// Returns the value one.
        /// </summary>
        public static Float32x4 MultiplicativeIdentity => One;

        /// <summary>
        /// Computes the min value of both.
        /// </summary>
        /// <param name="first">The first value.</param>
        /// <param name="second">The second value.</param>
        /// <returns>The min value.</returns>
        public static Float32x4 Min(
            Float32x4 first,
            Float32x4 second) =>
            new Float32x4((float)Math.Min(first.X, second.X), (float)Math.Min(first.Y, second.Y), (float)Math.Min(first.Z, second.Z), (float)Math.Min(first.W, second.W));

        /// <summary>
        /// Computes the max value of both.
        /// </summary>
        /// <param name="first">The first value.</param>
        /// <param name="second">The second value.</param>
        /// <returns>The max value.</returns>
        public static Float32x4 Max(
            Float32x4 first,
            Float32x4 second) =>
            new Float32x4((float)Math.Max(first.X, second.X), (float)Math.Max(first.Y, second.Y), (float)Math.Max(first.Z, second.Z), (float)Math.Max(first.W, second.W));

        /// <summary>
        /// Clamps the given value.
        /// </summary>
        /// <param name="value">The value to clamp.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The clamped value.</returns>
        public static Float32x4 Clamp(
            Float32x4 value,
            Float32x4 min,
            Float32x4 max) =>
            Max(Min(value, max), min);

        /// <summary>
        /// Creates a random scalar instance falling into the range of min max.
        /// </summary>
        /// <param name="random">The random provider to use.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The created random scalar instance.</returns>
        public static float GetRandomScalar<TRandom>(
            ref TRandom random,
            float min,
            float max)
            where TRandom : struct, IRandomProvider =>
            (float)RandomExtensions.
                Next(ref random, min, max);

        /// <summary>
        /// Creates a random vector instance falling into the range of min max.
        /// </summary>
        /// <param name="random">The random provider to use.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The created random vector instance.</returns>
        public static Float32x4 GetRandom<TRandom>(
            ref TRandom random,
            Float32x4 min,
            Float32x4 max)
            where TRandom : struct, IRandomProvider
        {
            float x = GetRandomScalar(
                ref random, min.X, max.X);
            float y = GetRandomScalar(
                ref random, min.Y, max.Y);
            float z = GetRandomScalar(
                ref random, min.Z, max.Z);
            float w = GetRandomScalar(
                ref random, min.W, max.W);
            return new Float32x4(x, y, z, w);
        }

        /// <summary>
        /// Creates a vector instance from the given source view.
        /// </summary>
        /// <typeparam name="TStride">The custom stride type.</typeparam>
        /// <param name="sourceView">The source view.</param>
        /// <param name="index">The source base index.</param>
        /// <returns>The vector instance.</returns>
        public static Float32x4 FromElementView<TStride>(
            ArrayView1D<float, TStride> sourceView,
            Index1D index)
            where TStride : struct, IStride1D =>
            new Float32x4(
                sourceView[index + 0],
                sourceView[index + 1],
                sourceView[index + 2],
                sourceView[index + 3]
                );

        /// <summary>
        /// Serializes the current vector instance into the given target view.
        /// </summary>
        /// <typeparam name="TStride">The custom stride type.</typeparam>
        /// <param name="targetView">The target view.</param>
        /// <param name="index">The target base index.</param>
        public void ToElementView<TStride>(
            ArrayView1D<float, TStride> targetView,
            Index1D index)
            where TStride : struct, IStride1D
        {
            targetView[index + 0] = X;
            targetView[index + 1] = Y;
            targetView[index + 2] = Z;
            targetView[index + 3] = W;
        }

        /// <summary>
        /// Creates a vector instance from the given source view.
        /// </summary>
        /// <param name="sourceView">The source view.</param>
        /// <param name="index">The source base index.</param>
        /// <returns>The vector instance.</returns>
        public static Float32x4 FromElementView(
            SingleVectorView<float> sourceView,
            Index1D index) =>
            new Float32x4(
                sourceView[index + 0],
                sourceView[index + 1],
                sourceView[index + 2],
                sourceView[index + 3]
                );

        /// <summary>
        /// Serializes the current vector instance into the given target view.
        /// </summary>
        /// <param name="targetView">The target view.</param>
        /// <param name="index">The target base index.</param>
        public void ToElementView(
            SingleVectorView<float> targetView,
            Index1D index)
        {
            targetView[index + 0] = X;
            targetView[index + 1] = Y;
            targetView[index + 2] = Z;
            targetView[index + 3] = W;
        }

        /// <summary>
        /// Converts a scalar value into the current vectorized type.
        /// </summary>
        /// <param name="scalar">The scalar element type.</param>
        /// <returns>The created vectorized type.</returns>
        public static Float32x4 FromScalar(float scalar) =>
            new Float32x4(scalar, scalar, scalar, scalar);

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        public static void AtomicAdd(ref Float32x4 target, Float32x4 value)
        {
            ref var elementRef = ref Unsafe.As<Float32x4, float>(
                ref target);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrX),
                value.X);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrY),
                value.Y);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrZ),
                value.Z);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrW),
                value.W);
        }

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        public Float32x4 ComputeAverage(long denominator) =>
            this / FromScalar((float)denominator);
        

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float32x4 ConvertFrom_float(
            Float32x4 other) =>
            new Float32x4((float)other.X, (float)other.Y, (float)other.Z, (float)other.W);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float32x4 ConvertTo_float(
            Float32x4 current) =>
            new Float32x4((float)current.X, (float)current.Y, (float)current.Z, (float)current.W);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float32x4 IAccumulationVectorType<
            Float32x4,
            Float32x4,
            float>.ConvertFromBase(Float32x4 other) =>
            ConvertFrom_float(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float32x4 IAccumulationVectorType<
            Float32x4,
            Float32x4,
            float>.ConvertToBase(Float32x4 current) =>
            ConvertTo_float(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(true)]
        public Float32x4 ComputeAverage(float denominator) =>
            this / FromScalar((float)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float32x4 operator +(
            Float32x4 current,
            UInt8x4 toAccumulate) =>
            current + ConvertFrom_byte(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float32x4 operator +(
            UInt8x4 toAccumulate,
            Float32x4 current) =>
            ConvertFrom_byte(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float32x4 operator -(
            Float32x4 current,
            UInt8x4 toAccumulate) =>
            current - ConvertFrom_byte(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float32x4 operator -(
            UInt8x4 toAccumulate,
            Float32x4 current) =>
            ConvertFrom_byte(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref Float32x4 target,
            UInt8x4 value) =>
            AtomicAdd(ref target, ConvertFrom_byte(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float32x4 ConvertFrom_byte(
            UInt8x4 other) =>
            new Float32x4((float)other.X, (float)other.Y, (float)other.Z, (float)other.W);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt8x4 ConvertTo_byte(
            Float32x4 current) =>
            new UInt8x4((byte)current.X, (byte)current.Y, (byte)current.Z, (byte)current.W);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float32x4 IAccumulationVectorType<
            Float32x4,
            UInt8x4,
            byte>.ConvertFromBase(UInt8x4 other) =>
            ConvertFrom_byte(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt8x4 IAccumulationVectorType<
            Float32x4,
            UInt8x4,
            byte>.ConvertToBase(Float32x4 current) =>
            ConvertTo_byte(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public Float32x4 ComputeAverage(byte denominator) =>
            this / FromScalar((float)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float32x4 operator +(
            Float32x4 current,
            Int8x4 toAccumulate) =>
            current + ConvertFrom_sbyte(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float32x4 operator +(
            Int8x4 toAccumulate,
            Float32x4 current) =>
            ConvertFrom_sbyte(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float32x4 operator -(
            Float32x4 current,
            Int8x4 toAccumulate) =>
            current - ConvertFrom_sbyte(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float32x4 operator -(
            Int8x4 toAccumulate,
            Float32x4 current) =>
            ConvertFrom_sbyte(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref Float32x4 target,
            Int8x4 value) =>
            AtomicAdd(ref target, ConvertFrom_sbyte(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float32x4 ConvertFrom_sbyte(
            Int8x4 other) =>
            new Float32x4((float)other.X, (float)other.Y, (float)other.Z, (float)other.W);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int8x4 ConvertTo_sbyte(
            Float32x4 current) =>
            new Int8x4((sbyte)current.X, (sbyte)current.Y, (sbyte)current.Z, (sbyte)current.W);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float32x4 IAccumulationVectorType<
            Float32x4,
            Int8x4,
            sbyte>.ConvertFromBase(Int8x4 other) =>
            ConvertFrom_sbyte(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int8x4 IAccumulationVectorType<
            Float32x4,
            Int8x4,
            sbyte>.ConvertToBase(Float32x4 current) =>
            ConvertTo_sbyte(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public Float32x4 ComputeAverage(sbyte denominator) =>
            this / FromScalar((float)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float32x4 operator +(
            Float32x4 current,
            Int16x4 toAccumulate) =>
            current + ConvertFrom_short(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float32x4 operator +(
            Int16x4 toAccumulate,
            Float32x4 current) =>
            ConvertFrom_short(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float32x4 operator -(
            Float32x4 current,
            Int16x4 toAccumulate) =>
            current - ConvertFrom_short(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float32x4 operator -(
            Int16x4 toAccumulate,
            Float32x4 current) =>
            ConvertFrom_short(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(true)]
        public static void AtomicAdd(
            ref Float32x4 target,
            Int16x4 value) =>
            AtomicAdd(ref target, ConvertFrom_short(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float32x4 ConvertFrom_short(
            Int16x4 other) =>
            new Float32x4((float)other.X, (float)other.Y, (float)other.Z, (float)other.W);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int16x4 ConvertTo_short(
            Float32x4 current) =>
            new Int16x4((short)current.X, (short)current.Y, (short)current.Z, (short)current.W);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float32x4 IAccumulationVectorType<
            Float32x4,
            Int16x4,
            short>.ConvertFromBase(Int16x4 other) =>
            ConvertFrom_short(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int16x4 IAccumulationVectorType<
            Float32x4,
            Int16x4,
            short>.ConvertToBase(Float32x4 current) =>
            ConvertTo_short(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(true)]
        public Float32x4 ComputeAverage(short denominator) =>
            this / FromScalar((float)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float32x4 operator +(
            Float32x4 current,
            UInt16x4 toAccumulate) =>
            current + ConvertFrom_ushort(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float32x4 operator +(
            UInt16x4 toAccumulate,
            Float32x4 current) =>
            ConvertFrom_ushort(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float32x4 operator -(
            Float32x4 current,
            UInt16x4 toAccumulate) =>
            current - ConvertFrom_ushort(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float32x4 operator -(
            UInt16x4 toAccumulate,
            Float32x4 current) =>
            ConvertFrom_ushort(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref Float32x4 target,
            UInt16x4 value) =>
            AtomicAdd(ref target, ConvertFrom_ushort(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float32x4 ConvertFrom_ushort(
            UInt16x4 other) =>
            new Float32x4((float)other.X, (float)other.Y, (float)other.Z, (float)other.W);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt16x4 ConvertTo_ushort(
            Float32x4 current) =>
            new UInt16x4((ushort)current.X, (ushort)current.Y, (ushort)current.Z, (ushort)current.W);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float32x4 IAccumulationVectorType<
            Float32x4,
            UInt16x4,
            ushort>.ConvertFromBase(UInt16x4 other) =>
            ConvertFrom_ushort(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt16x4 IAccumulationVectorType<
            Float32x4,
            UInt16x4,
            ushort>.ConvertToBase(Float32x4 current) =>
            ConvertTo_ushort(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public Float32x4 ComputeAverage(ushort denominator) =>
            this / FromScalar((float)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float32x4 operator +(
            Float32x4 current,
            Int32x4 toAccumulate) =>
            current + ConvertFrom_int(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float32x4 operator +(
            Int32x4 toAccumulate,
            Float32x4 current) =>
            ConvertFrom_int(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float32x4 operator -(
            Float32x4 current,
            Int32x4 toAccumulate) =>
            current - ConvertFrom_int(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float32x4 operator -(
            Int32x4 toAccumulate,
            Float32x4 current) =>
            ConvertFrom_int(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(true)]
        public static void AtomicAdd(
            ref Float32x4 target,
            Int32x4 value) =>
            AtomicAdd(ref target, ConvertFrom_int(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float32x4 ConvertFrom_int(
            Int32x4 other) =>
            new Float32x4((float)other.X, (float)other.Y, (float)other.Z, (float)other.W);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int32x4 ConvertTo_int(
            Float32x4 current) =>
            new Int32x4((int)current.X, (int)current.Y, (int)current.Z, (int)current.W);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float32x4 IAccumulationVectorType<
            Float32x4,
            Int32x4,
            int>.ConvertFromBase(Int32x4 other) =>
            ConvertFrom_int(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int32x4 IAccumulationVectorType<
            Float32x4,
            Int32x4,
            int>.ConvertToBase(Float32x4 current) =>
            ConvertTo_int(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(true)]
        public Float32x4 ComputeAverage(int denominator) =>
            this / FromScalar((float)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float32x4 operator +(
            Float32x4 current,
            UInt32x4 toAccumulate) =>
            current + ConvertFrom_uint(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float32x4 operator +(
            UInt32x4 toAccumulate,
            Float32x4 current) =>
            ConvertFrom_uint(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float32x4 operator -(
            Float32x4 current,
            UInt32x4 toAccumulate) =>
            current - ConvertFrom_uint(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float32x4 operator -(
            UInt32x4 toAccumulate,
            Float32x4 current) =>
            ConvertFrom_uint(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref Float32x4 target,
            UInt32x4 value) =>
            AtomicAdd(ref target, ConvertFrom_uint(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float32x4 ConvertFrom_uint(
            UInt32x4 other) =>
            new Float32x4((float)other.X, (float)other.Y, (float)other.Z, (float)other.W);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt32x4 ConvertTo_uint(
            Float32x4 current) =>
            new UInt32x4((uint)current.X, (uint)current.Y, (uint)current.Z, (uint)current.W);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float32x4 IAccumulationVectorType<
            Float32x4,
            UInt32x4,
            uint>.ConvertFromBase(UInt32x4 other) =>
            ConvertFrom_uint(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt32x4 IAccumulationVectorType<
            Float32x4,
            UInt32x4,
            uint>.ConvertToBase(Float32x4 current) =>
            ConvertTo_uint(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public Float32x4 ComputeAverage(uint denominator) =>
            this / FromScalar((float)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float32x4 operator +(
            Float32x4 current,
            Int64x4 toAccumulate) =>
            current + ConvertFrom_long(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float32x4 operator +(
            Int64x4 toAccumulate,
            Float32x4 current) =>
            ConvertFrom_long(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float32x4 operator -(
            Float32x4 current,
            Int64x4 toAccumulate) =>
            current - ConvertFrom_long(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float32x4 operator -(
            Int64x4 toAccumulate,
            Float32x4 current) =>
            ConvertFrom_long(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(true)]
        public static void AtomicAdd(
            ref Float32x4 target,
            Int64x4 value) =>
            AtomicAdd(ref target, ConvertFrom_long(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float32x4 ConvertFrom_long(
            Int64x4 other) =>
            new Float32x4((float)other.X, (float)other.Y, (float)other.Z, (float)other.W);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int64x4 ConvertTo_long(
            Float32x4 current) =>
            new Int64x4((long)current.X, (long)current.Y, (long)current.Z, (long)current.W);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float32x4 IAccumulationVectorType<
            Float32x4,
            Int64x4,
            long>.ConvertFromBase(Int64x4 other) =>
            ConvertFrom_long(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int64x4 IAccumulationVectorType<
            Float32x4,
            Int64x4,
            long>.ConvertToBase(Float32x4 current) =>
            ConvertTo_long(current);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float32x4 operator +(
            Float32x4 current,
            UInt64x4 toAccumulate) =>
            current + ConvertFrom_ulong(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float32x4 operator +(
            UInt64x4 toAccumulate,
            Float32x4 current) =>
            ConvertFrom_ulong(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float32x4 operator -(
            Float32x4 current,
            UInt64x4 toAccumulate) =>
            current - ConvertFrom_ulong(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float32x4 operator -(
            UInt64x4 toAccumulate,
            Float32x4 current) =>
            ConvertFrom_ulong(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref Float32x4 target,
            UInt64x4 value) =>
            AtomicAdd(ref target, ConvertFrom_ulong(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float32x4 ConvertFrom_ulong(
            UInt64x4 other) =>
            new Float32x4((float)other.X, (float)other.Y, (float)other.Z, (float)other.W);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt64x4 ConvertTo_ulong(
            Float32x4 current) =>
            new UInt64x4((ulong)current.X, (ulong)current.Y, (ulong)current.Z, (ulong)current.W);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float32x4 IAccumulationVectorType<
            Float32x4,
            UInt64x4,
            ulong>.ConvertFromBase(UInt64x4 other) =>
            ConvertFrom_ulong(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt64x4 IAccumulationVectorType<
            Float32x4,
            UInt64x4,
            ulong>.ConvertToBase(Float32x4 current) =>
            ConvertTo_ulong(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public Float32x4 ComputeAverage(ulong denominator) =>
            this / FromScalar((float)denominator);

        /// <summary>
        /// Converts this instance into an unsafe span instance.
        /// </summary>
        /// <returns>The readonly span instance.</returns>
        public unsafe ReadOnlySpan<float> AsSpan() =>
            new(Unsafe.AsPointer(ref Unsafe.AsRef(this)), 4);

        /// <summary>
        /// Iterates over all elements by applying the given iterator to each element.
        /// </summary>
        /// <typeparam name="TIterator">The managed iterator type.</typeparam>
        /// <param name="iterator">The iterator to invoke.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ForEach<TIterator>(ref TIterator iterator)
            where TIterator : struct, IVectorElementIterator<
            Float32x4,
            float>
        {
            iterator.Iterate(X, 0);
            iterator.Iterate(Y, 1);
            iterator.Iterate(Z, 2);
            iterator.Iterate(W, 3);
        }

        /// <summary>
        /// Converts this vector instance to a string.
        /// </summary>
        public override string ToString() =>
            $"{X}, {Y}, {Z}, {W}";

        /// <summary>
        /// Converts this vector instance to a string.
        /// </summary>
        public string ToString(string? format, IFormatProvider? formatProvider) =>
            $"{X.ToString(format, formatProvider)}, {Y.ToString(format, formatProvider)}, {Z.ToString(format, formatProvider)}, {W.ToString(format, formatProvider)}";

        /// <summary>
        /// Returns true.
        /// </summary>
        public static bool IsCanonical(Float32x4 value) => true;

        /// <summary>
        /// Returns false.
        /// </summary>
        public static bool IsComplexNumber(Float32x4 value) => false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsEvenInteger(Float32x4 value) =>
            float.IsEvenInteger(value.X) & float.IsEvenInteger(value.Y) & float.IsEvenInteger(value.Z) & float.IsEvenInteger(value.W);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsFinite(Float32x4 value) =>
            float.IsFinite(value.X) & float.IsFinite(value.Y) & float.IsFinite(value.Z) & float.IsFinite(value.W);

        /// <summary>
        /// Returns false.
        /// </summary>
        public static bool IsImaginaryNumber(Float32x4 value) => false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsInfinity(Float32x4 value) =>
            float.IsInfinity(value.X) | float.IsInfinity(value.Y) | float.IsInfinity(value.Z) | float.IsInfinity(value.W);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsInteger(Float32x4 value) =>
            float.IsInteger(value.X) & float.IsInteger(value.Y) & float.IsInteger(value.Z) & float.IsInteger(value.W);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNaN(Float32x4 value) =>
            float.IsNaN(value.X) | float.IsNaN(value.Y) | float.IsNaN(value.Z) | float.IsNaN(value.W);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNegative(Float32x4 value) =>
            float.IsNegative(value.X) & float.IsNegative(value.Y) & float.IsNegative(value.Z) & float.IsNegative(value.W);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNegativeInfinity(Float32x4 value) =>
            float.IsNegativeInfinity(value.X) | float.IsNegativeInfinity(value.Y) | float.IsNegativeInfinity(value.Z) | float.IsNegativeInfinity(value.W);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNormal(Float32x4 value) =>
            float.IsNormal(value.X) & float.IsNormal(value.Y) & float.IsNormal(value.Z) & float.IsNormal(value.W);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsOddInteger(Float32x4 value) =>
            float.IsOddInteger(value.X) & float.IsOddInteger(value.Y) & float.IsOddInteger(value.Z) & float.IsOddInteger(value.W);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsPositive(Float32x4 value) =>
            float.IsPositive(value.X) & float.IsPositive(value.Y) & float.IsPositive(value.Z) & float.IsPositive(value.W);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsPositiveInfinity(Float32x4 value) =>
            float.IsPositiveInfinity(value.X) | float.IsPositiveInfinity(value.Y) | float.IsPositiveInfinity(value.Z) | float.IsPositiveInfinity(value.W);

        /// <summary>
        /// Returns true.
        /// </summary>
        public static bool IsRealNumber(Float32x4 value) => true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsSubnormal(Float32x4 value) =>
            float.IsSubnormal(value.X) & float.IsSubnormal(value.Y) & float.IsSubnormal(value.Z) & float.IsSubnormal(value.W);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsZero(Float32x4 value) =>
            Abs(value) == Zero;

        /// <summary>
        /// Returns the absolute value.
        /// </summary>
        public static Float32x4 Abs(Float32x4 value) =>
            new Float32x4(Math.Abs(value.X), Math.Abs(value.Y), Math.Abs(value.Z), Math.Abs(value.W));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Float32x4 operator +(Float32x4 left, Float32x4 right) =>
            new Float32x4((float)(left.X + right.X), (float)(left.Y + right.Y), (float)(left.Z + right.Z), (float)(left.W + right.W));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Float32x4 operator --(Float32x4 value) => value - One;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Float32x4 operator /(Float32x4 left, Float32x4 right) =>
            new Float32x4((float)(left.X / right.X), (float)(left.Y / right.Y), (float)(left.Z / right.Z), (float)(left.W / right.W));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Float32x4 operator ++(Float32x4 value) => value + One;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Float32x4 operator *(Float32x4 left, Float32x4 right) =>
            new Float32x4((float)(left.X * right.X), (float)(left.Y * right.Y), (float)(left.Z * right.Z), (float)(left.W * right.W));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Float32x4 operator -(Float32x4 left, Float32x4 right) =>
            new Float32x4((float)(left.X - right.X), (float)(left.Y - right.Y), (float)(left.Z - right.Z), (float)(left.W - right.W));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Float32x4 operator -(Float32x4 value) =>
            new Float32x4((float)-value.X, (float)-value.Y, (float)-value.Z, (float)-value.W);

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Float32x4 operator +(Float32x4 value) => value;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Float32x4 MaxMagnitude(Float32x4 x, Float32x4 y) =>
            new Float32x4(float.MaxMagnitude(x.X, y.X), float.MaxMagnitude(x.Y, y.Y), float.MaxMagnitude(x.Z, y.Z), float.MaxMagnitude(x.W, y.W));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Float32x4 MaxMagnitudeNumber(Float32x4 x, Float32x4 y) =>
            new Float32x4(float.MaxMagnitudeNumber(x.X, y.X), float.MaxMagnitudeNumber(x.Y, y.Y), float.MaxMagnitudeNumber(x.Z, y.Z), float.MaxMagnitudeNumber(x.W, y.W));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Float32x4 MinMagnitude(Float32x4 x, Float32x4 y) =>
            new Float32x4(float.MinMagnitude(x.X, y.X), float.MinMagnitude(x.Y, y.Y), float.MinMagnitude(x.Z, y.Z), float.MinMagnitude(x.W, y.W));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Float32x4 MinMagnitudeNumber(Float32x4 x, Float32x4 y) =>
            new Float32x4(float.MinMagnitudeNumber(x.X, y.X), float.MinMagnitudeNumber(x.Y, y.Y), float.MinMagnitudeNumber(x.Z, y.Z), float.MinMagnitudeNumber(x.W, y.W));

        // Not supported operations

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static Float32x4 IParsable<Float32x4>.Parse(
            string s,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static Float32x4 ISpanParsable<Float32x4>.Parse(
            ReadOnlySpan<char> s,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static Float32x4 INumberBase<Float32x4>.Parse(
            ReadOnlySpan<char> s,
            NumberStyles style,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static Float32x4 INumberBase<Float32x4>.Parse(
            string s,
            NumberStyles style,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        bool ISpanFormattable.TryFormat(
            Span<char> destination,
            out int charsWritten,
            ReadOnlySpan<char> format,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool IParsable<Float32x4>.TryParse(
            string? s,
            IFormatProvider? provider,
            out Float32x4 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given span into a vectorized instance.
        /// </summary>
        static bool ISpanParsable<Float32x4>.TryParse(
            ReadOnlySpan<char> s,
            IFormatProvider? provider,
            out Float32x4 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool INumberBase<Float32x4>.TryParse(
            ReadOnlySpan<char> s,
            NumberStyles style,
            IFormatProvider? provider,
            out Float32x4 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool INumberBase<Float32x4>.TryParse(
            string? s,
            NumberStyles style,
            IFormatProvider? provider,
            out Float32x4 result) =>
            throw new NotSupportedException();

        static bool INumberBase<Float32x4>.TryConvertFromChecked<TOther>(
            TOther value,
            out Float32x4 result) =>
            throw new NotSupportedException();
        static bool INumberBase<Float32x4>.TryConvertFromSaturating<TOther>(
            TOther value,
            out Float32x4 result) =>
            throw new NotSupportedException();
        static bool INumberBase<Float32x4>.TryConvertFromTruncating<TOther>(
            TOther value,
            out Float32x4 result) =>
            throw new NotSupportedException();
        static bool INumberBase<Float32x4>.TryConvertToChecked<TOther>(
            Float32x4 value,
            out TOther result) =>
            throw new NotSupportedException();
        static bool INumberBase<Float32x4>.TryConvertToSaturating<TOther>(
            Float32x4 value,
            out TOther result) =>
            throw new NotSupportedException();
        static bool INumberBase<Float32x4>.TryConvertToTruncating<TOther>(
            Float32x4 value,
            out TOther result) =>
            throw new NotSupportedException();
    }

    /// <summary>
    /// Represents a vectorized float type with length 8.
    /// </summary>
    public readonly record struct Float32x8(
        float X, float Y, float Z, float W, float I, float J, float K, float L) :
        IVectorType<Float32x8, float>
        , IAccumulationVectorType<
            Float32x8,
            Float32x8,
            float>
        , IAccumulationVectorType<
            Float32x8,
            UInt8x8,
            byte>
        , IAccumulationVectorType<
            Float32x8,
            Int8x8,
            sbyte>
        , IAccumulationVectorType<
            Float32x8,
            Int16x8,
            short>
        , IAccumulationVectorType<
            Float32x8,
            UInt16x8,
            ushort>
        , IAccumulationVectorType<
            Float32x8,
            Int32x8,
            int>
        , IAccumulationVectorType<
            Float32x8,
            UInt32x8,
            uint>
        , IAccumulationVectorType<
            Float32x8,
            Int64x8,
            long>
        , IAccumulationVectorType<
            Float32x8,
            UInt64x8,
            ulong>
    {
        /// <summary>
        /// The offset of the X field in bytes.
        /// </summary>
        public static readonly int OffsetX =
            sizeof(float) * 0;

        /// <summary>
        /// The offset of the X field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrX =>
            new UIntPtr((uint)OffsetX);
        /// <summary>
        /// The offset of the Y field in bytes.
        /// </summary>
        public static readonly int OffsetY =
            sizeof(float) * 1;

        /// <summary>
        /// The offset of the Y field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrY =>
            new UIntPtr((uint)OffsetY);
        /// <summary>
        /// The offset of the Z field in bytes.
        /// </summary>
        public static readonly int OffsetZ =
            sizeof(float) * 2;

        /// <summary>
        /// The offset of the Z field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrZ =>
            new UIntPtr((uint)OffsetZ);
        /// <summary>
        /// The offset of the W field in bytes.
        /// </summary>
        public static readonly int OffsetW =
            sizeof(float) * 3;

        /// <summary>
        /// The offset of the W field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrW =>
            new UIntPtr((uint)OffsetW);
        /// <summary>
        /// The offset of the I field in bytes.
        /// </summary>
        public static readonly int OffsetI =
            sizeof(float) * 4;

        /// <summary>
        /// The offset of the I field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrI =>
            new UIntPtr((uint)OffsetI);
        /// <summary>
        /// The offset of the J field in bytes.
        /// </summary>
        public static readonly int OffsetJ =
            sizeof(float) * 5;

        /// <summary>
        /// The offset of the J field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrJ =>
            new UIntPtr((uint)OffsetJ);
        /// <summary>
        /// The offset of the K field in bytes.
        /// </summary>
        public static readonly int OffsetK =
            sizeof(float) * 6;

        /// <summary>
        /// The offset of the K field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrK =>
            new UIntPtr((uint)OffsetK);
        /// <summary>
        /// The offset of the L field in bytes.
        /// </summary>
        public static readonly int OffsetL =
            sizeof(float) * 7;

        /// <summary>
        /// The offset of the L field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrL =>
            new UIntPtr((uint)OffsetL);

        /// <summary>
        /// Returns the length of this vector which is 8.
        /// </summary>
        public static int Length => 8;

        /// <summary>
        /// Returns the radix of the underlying value.
        /// </summary>
        public static int Radix => 10;

        /// <summary>
        /// Returns an invalid value (min [signed types], max value [unsigned] or NaN).
        /// </summary>
        public static Float32x8 Invalid => FromScalar(
            float.NaN
        );

        /// <summary>
        /// Returns the value zero.
        /// </summary>
        public static Float32x8 Zero => new();

        /// <summary>
        /// Returns the value one.
        /// </summary>
        public static Float32x8 One => FromScalar((1f));

        /// <summary>
        /// Returns the value zero.
        /// </summary>
        public static Float32x8 AdditiveIdentity => Zero;

        /// <summary>
        /// Returns the value one.
        /// </summary>
        public static Float32x8 MultiplicativeIdentity => One;

        /// <summary>
        /// Computes the min value of both.
        /// </summary>
        /// <param name="first">The first value.</param>
        /// <param name="second">The second value.</param>
        /// <returns>The min value.</returns>
        public static Float32x8 Min(
            Float32x8 first,
            Float32x8 second) =>
            new Float32x8((float)Math.Min(first.X, second.X), (float)Math.Min(first.Y, second.Y), (float)Math.Min(first.Z, second.Z), (float)Math.Min(first.W, second.W), (float)Math.Min(first.I, second.I), (float)Math.Min(first.J, second.J), (float)Math.Min(first.K, second.K), (float)Math.Min(first.L, second.L));

        /// <summary>
        /// Computes the max value of both.
        /// </summary>
        /// <param name="first">The first value.</param>
        /// <param name="second">The second value.</param>
        /// <returns>The max value.</returns>
        public static Float32x8 Max(
            Float32x8 first,
            Float32x8 second) =>
            new Float32x8((float)Math.Max(first.X, second.X), (float)Math.Max(first.Y, second.Y), (float)Math.Max(first.Z, second.Z), (float)Math.Max(first.W, second.W), (float)Math.Max(first.I, second.I), (float)Math.Max(first.J, second.J), (float)Math.Max(first.K, second.K), (float)Math.Max(first.L, second.L));

        /// <summary>
        /// Clamps the given value.
        /// </summary>
        /// <param name="value">The value to clamp.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The clamped value.</returns>
        public static Float32x8 Clamp(
            Float32x8 value,
            Float32x8 min,
            Float32x8 max) =>
            Max(Min(value, max), min);

        /// <summary>
        /// Creates a random scalar instance falling into the range of min max.
        /// </summary>
        /// <param name="random">The random provider to use.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The created random scalar instance.</returns>
        public static float GetRandomScalar<TRandom>(
            ref TRandom random,
            float min,
            float max)
            where TRandom : struct, IRandomProvider =>
            (float)RandomExtensions.
                Next(ref random, min, max);

        /// <summary>
        /// Creates a random vector instance falling into the range of min max.
        /// </summary>
        /// <param name="random">The random provider to use.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The created random vector instance.</returns>
        public static Float32x8 GetRandom<TRandom>(
            ref TRandom random,
            Float32x8 min,
            Float32x8 max)
            where TRandom : struct, IRandomProvider
        {
            float x = GetRandomScalar(
                ref random, min.X, max.X);
            float y = GetRandomScalar(
                ref random, min.Y, max.Y);
            float z = GetRandomScalar(
                ref random, min.Z, max.Z);
            float w = GetRandomScalar(
                ref random, min.W, max.W);
            float i = GetRandomScalar(
                ref random, min.I, max.I);
            float j = GetRandomScalar(
                ref random, min.J, max.J);
            float k = GetRandomScalar(
                ref random, min.K, max.K);
            float l = GetRandomScalar(
                ref random, min.L, max.L);
            return new Float32x8(x, y, z, w, i, j, k, l);
        }

        /// <summary>
        /// Creates a vector instance from the given source view.
        /// </summary>
        /// <typeparam name="TStride">The custom stride type.</typeparam>
        /// <param name="sourceView">The source view.</param>
        /// <param name="index">The source base index.</param>
        /// <returns>The vector instance.</returns>
        public static Float32x8 FromElementView<TStride>(
            ArrayView1D<float, TStride> sourceView,
            Index1D index)
            where TStride : struct, IStride1D =>
            new Float32x8(
                sourceView[index + 0],
                sourceView[index + 1],
                sourceView[index + 2],
                sourceView[index + 3],
                sourceView[index + 4],
                sourceView[index + 5],
                sourceView[index + 6],
                sourceView[index + 7]
                );

        /// <summary>
        /// Serializes the current vector instance into the given target view.
        /// </summary>
        /// <typeparam name="TStride">The custom stride type.</typeparam>
        /// <param name="targetView">The target view.</param>
        /// <param name="index">The target base index.</param>
        public void ToElementView<TStride>(
            ArrayView1D<float, TStride> targetView,
            Index1D index)
            where TStride : struct, IStride1D
        {
            targetView[index + 0] = X;
            targetView[index + 1] = Y;
            targetView[index + 2] = Z;
            targetView[index + 3] = W;
            targetView[index + 4] = I;
            targetView[index + 5] = J;
            targetView[index + 6] = K;
            targetView[index + 7] = L;
        }

        /// <summary>
        /// Creates a vector instance from the given source view.
        /// </summary>
        /// <param name="sourceView">The source view.</param>
        /// <param name="index">The source base index.</param>
        /// <returns>The vector instance.</returns>
        public static Float32x8 FromElementView(
            SingleVectorView<float> sourceView,
            Index1D index) =>
            new Float32x8(
                sourceView[index + 0],
                sourceView[index + 1],
                sourceView[index + 2],
                sourceView[index + 3],
                sourceView[index + 4],
                sourceView[index + 5],
                sourceView[index + 6],
                sourceView[index + 7]
                );

        /// <summary>
        /// Serializes the current vector instance into the given target view.
        /// </summary>
        /// <param name="targetView">The target view.</param>
        /// <param name="index">The target base index.</param>
        public void ToElementView(
            SingleVectorView<float> targetView,
            Index1D index)
        {
            targetView[index + 0] = X;
            targetView[index + 1] = Y;
            targetView[index + 2] = Z;
            targetView[index + 3] = W;
            targetView[index + 4] = I;
            targetView[index + 5] = J;
            targetView[index + 6] = K;
            targetView[index + 7] = L;
        }

        /// <summary>
        /// Converts a scalar value into the current vectorized type.
        /// </summary>
        /// <param name="scalar">The scalar element type.</param>
        /// <returns>The created vectorized type.</returns>
        public static Float32x8 FromScalar(float scalar) =>
            new Float32x8(scalar, scalar, scalar, scalar, scalar, scalar, scalar, scalar);

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        public static void AtomicAdd(ref Float32x8 target, Float32x8 value)
        {
            ref var elementRef = ref Unsafe.As<Float32x8, float>(
                ref target);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrX),
                value.X);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrY),
                value.Y);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrZ),
                value.Z);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrW),
                value.W);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrI),
                value.I);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrJ),
                value.J);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrK),
                value.K);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrL),
                value.L);
        }

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        public Float32x8 ComputeAverage(long denominator) =>
            this / FromScalar((float)denominator);
        

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float32x8 ConvertFrom_float(
            Float32x8 other) =>
            new Float32x8((float)other.X, (float)other.Y, (float)other.Z, (float)other.W, (float)other.I, (float)other.J, (float)other.K, (float)other.L);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float32x8 ConvertTo_float(
            Float32x8 current) =>
            new Float32x8((float)current.X, (float)current.Y, (float)current.Z, (float)current.W, (float)current.I, (float)current.J, (float)current.K, (float)current.L);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float32x8 IAccumulationVectorType<
            Float32x8,
            Float32x8,
            float>.ConvertFromBase(Float32x8 other) =>
            ConvertFrom_float(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float32x8 IAccumulationVectorType<
            Float32x8,
            Float32x8,
            float>.ConvertToBase(Float32x8 current) =>
            ConvertTo_float(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(true)]
        public Float32x8 ComputeAverage(float denominator) =>
            this / FromScalar((float)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float32x8 operator +(
            Float32x8 current,
            UInt8x8 toAccumulate) =>
            current + ConvertFrom_byte(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float32x8 operator +(
            UInt8x8 toAccumulate,
            Float32x8 current) =>
            ConvertFrom_byte(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float32x8 operator -(
            Float32x8 current,
            UInt8x8 toAccumulate) =>
            current - ConvertFrom_byte(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float32x8 operator -(
            UInt8x8 toAccumulate,
            Float32x8 current) =>
            ConvertFrom_byte(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref Float32x8 target,
            UInt8x8 value) =>
            AtomicAdd(ref target, ConvertFrom_byte(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float32x8 ConvertFrom_byte(
            UInt8x8 other) =>
            new Float32x8((float)other.X, (float)other.Y, (float)other.Z, (float)other.W, (float)other.I, (float)other.J, (float)other.K, (float)other.L);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt8x8 ConvertTo_byte(
            Float32x8 current) =>
            new UInt8x8((byte)current.X, (byte)current.Y, (byte)current.Z, (byte)current.W, (byte)current.I, (byte)current.J, (byte)current.K, (byte)current.L);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float32x8 IAccumulationVectorType<
            Float32x8,
            UInt8x8,
            byte>.ConvertFromBase(UInt8x8 other) =>
            ConvertFrom_byte(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt8x8 IAccumulationVectorType<
            Float32x8,
            UInt8x8,
            byte>.ConvertToBase(Float32x8 current) =>
            ConvertTo_byte(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public Float32x8 ComputeAverage(byte denominator) =>
            this / FromScalar((float)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float32x8 operator +(
            Float32x8 current,
            Int8x8 toAccumulate) =>
            current + ConvertFrom_sbyte(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float32x8 operator +(
            Int8x8 toAccumulate,
            Float32x8 current) =>
            ConvertFrom_sbyte(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float32x8 operator -(
            Float32x8 current,
            Int8x8 toAccumulate) =>
            current - ConvertFrom_sbyte(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float32x8 operator -(
            Int8x8 toAccumulate,
            Float32x8 current) =>
            ConvertFrom_sbyte(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref Float32x8 target,
            Int8x8 value) =>
            AtomicAdd(ref target, ConvertFrom_sbyte(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float32x8 ConvertFrom_sbyte(
            Int8x8 other) =>
            new Float32x8((float)other.X, (float)other.Y, (float)other.Z, (float)other.W, (float)other.I, (float)other.J, (float)other.K, (float)other.L);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int8x8 ConvertTo_sbyte(
            Float32x8 current) =>
            new Int8x8((sbyte)current.X, (sbyte)current.Y, (sbyte)current.Z, (sbyte)current.W, (sbyte)current.I, (sbyte)current.J, (sbyte)current.K, (sbyte)current.L);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float32x8 IAccumulationVectorType<
            Float32x8,
            Int8x8,
            sbyte>.ConvertFromBase(Int8x8 other) =>
            ConvertFrom_sbyte(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int8x8 IAccumulationVectorType<
            Float32x8,
            Int8x8,
            sbyte>.ConvertToBase(Float32x8 current) =>
            ConvertTo_sbyte(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public Float32x8 ComputeAverage(sbyte denominator) =>
            this / FromScalar((float)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float32x8 operator +(
            Float32x8 current,
            Int16x8 toAccumulate) =>
            current + ConvertFrom_short(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float32x8 operator +(
            Int16x8 toAccumulate,
            Float32x8 current) =>
            ConvertFrom_short(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float32x8 operator -(
            Float32x8 current,
            Int16x8 toAccumulate) =>
            current - ConvertFrom_short(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float32x8 operator -(
            Int16x8 toAccumulate,
            Float32x8 current) =>
            ConvertFrom_short(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(true)]
        public static void AtomicAdd(
            ref Float32x8 target,
            Int16x8 value) =>
            AtomicAdd(ref target, ConvertFrom_short(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float32x8 ConvertFrom_short(
            Int16x8 other) =>
            new Float32x8((float)other.X, (float)other.Y, (float)other.Z, (float)other.W, (float)other.I, (float)other.J, (float)other.K, (float)other.L);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int16x8 ConvertTo_short(
            Float32x8 current) =>
            new Int16x8((short)current.X, (short)current.Y, (short)current.Z, (short)current.W, (short)current.I, (short)current.J, (short)current.K, (short)current.L);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float32x8 IAccumulationVectorType<
            Float32x8,
            Int16x8,
            short>.ConvertFromBase(Int16x8 other) =>
            ConvertFrom_short(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int16x8 IAccumulationVectorType<
            Float32x8,
            Int16x8,
            short>.ConvertToBase(Float32x8 current) =>
            ConvertTo_short(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(true)]
        public Float32x8 ComputeAverage(short denominator) =>
            this / FromScalar((float)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float32x8 operator +(
            Float32x8 current,
            UInt16x8 toAccumulate) =>
            current + ConvertFrom_ushort(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float32x8 operator +(
            UInt16x8 toAccumulate,
            Float32x8 current) =>
            ConvertFrom_ushort(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float32x8 operator -(
            Float32x8 current,
            UInt16x8 toAccumulate) =>
            current - ConvertFrom_ushort(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float32x8 operator -(
            UInt16x8 toAccumulate,
            Float32x8 current) =>
            ConvertFrom_ushort(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref Float32x8 target,
            UInt16x8 value) =>
            AtomicAdd(ref target, ConvertFrom_ushort(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float32x8 ConvertFrom_ushort(
            UInt16x8 other) =>
            new Float32x8((float)other.X, (float)other.Y, (float)other.Z, (float)other.W, (float)other.I, (float)other.J, (float)other.K, (float)other.L);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt16x8 ConvertTo_ushort(
            Float32x8 current) =>
            new UInt16x8((ushort)current.X, (ushort)current.Y, (ushort)current.Z, (ushort)current.W, (ushort)current.I, (ushort)current.J, (ushort)current.K, (ushort)current.L);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float32x8 IAccumulationVectorType<
            Float32x8,
            UInt16x8,
            ushort>.ConvertFromBase(UInt16x8 other) =>
            ConvertFrom_ushort(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt16x8 IAccumulationVectorType<
            Float32x8,
            UInt16x8,
            ushort>.ConvertToBase(Float32x8 current) =>
            ConvertTo_ushort(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public Float32x8 ComputeAverage(ushort denominator) =>
            this / FromScalar((float)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float32x8 operator +(
            Float32x8 current,
            Int32x8 toAccumulate) =>
            current + ConvertFrom_int(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float32x8 operator +(
            Int32x8 toAccumulate,
            Float32x8 current) =>
            ConvertFrom_int(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float32x8 operator -(
            Float32x8 current,
            Int32x8 toAccumulate) =>
            current - ConvertFrom_int(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float32x8 operator -(
            Int32x8 toAccumulate,
            Float32x8 current) =>
            ConvertFrom_int(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(true)]
        public static void AtomicAdd(
            ref Float32x8 target,
            Int32x8 value) =>
            AtomicAdd(ref target, ConvertFrom_int(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float32x8 ConvertFrom_int(
            Int32x8 other) =>
            new Float32x8((float)other.X, (float)other.Y, (float)other.Z, (float)other.W, (float)other.I, (float)other.J, (float)other.K, (float)other.L);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int32x8 ConvertTo_int(
            Float32x8 current) =>
            new Int32x8((int)current.X, (int)current.Y, (int)current.Z, (int)current.W, (int)current.I, (int)current.J, (int)current.K, (int)current.L);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float32x8 IAccumulationVectorType<
            Float32x8,
            Int32x8,
            int>.ConvertFromBase(Int32x8 other) =>
            ConvertFrom_int(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int32x8 IAccumulationVectorType<
            Float32x8,
            Int32x8,
            int>.ConvertToBase(Float32x8 current) =>
            ConvertTo_int(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(true)]
        public Float32x8 ComputeAverage(int denominator) =>
            this / FromScalar((float)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float32x8 operator +(
            Float32x8 current,
            UInt32x8 toAccumulate) =>
            current + ConvertFrom_uint(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float32x8 operator +(
            UInt32x8 toAccumulate,
            Float32x8 current) =>
            ConvertFrom_uint(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float32x8 operator -(
            Float32x8 current,
            UInt32x8 toAccumulate) =>
            current - ConvertFrom_uint(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float32x8 operator -(
            UInt32x8 toAccumulate,
            Float32x8 current) =>
            ConvertFrom_uint(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref Float32x8 target,
            UInt32x8 value) =>
            AtomicAdd(ref target, ConvertFrom_uint(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float32x8 ConvertFrom_uint(
            UInt32x8 other) =>
            new Float32x8((float)other.X, (float)other.Y, (float)other.Z, (float)other.W, (float)other.I, (float)other.J, (float)other.K, (float)other.L);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt32x8 ConvertTo_uint(
            Float32x8 current) =>
            new UInt32x8((uint)current.X, (uint)current.Y, (uint)current.Z, (uint)current.W, (uint)current.I, (uint)current.J, (uint)current.K, (uint)current.L);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float32x8 IAccumulationVectorType<
            Float32x8,
            UInt32x8,
            uint>.ConvertFromBase(UInt32x8 other) =>
            ConvertFrom_uint(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt32x8 IAccumulationVectorType<
            Float32x8,
            UInt32x8,
            uint>.ConvertToBase(Float32x8 current) =>
            ConvertTo_uint(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public Float32x8 ComputeAverage(uint denominator) =>
            this / FromScalar((float)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float32x8 operator +(
            Float32x8 current,
            Int64x8 toAccumulate) =>
            current + ConvertFrom_long(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float32x8 operator +(
            Int64x8 toAccumulate,
            Float32x8 current) =>
            ConvertFrom_long(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float32x8 operator -(
            Float32x8 current,
            Int64x8 toAccumulate) =>
            current - ConvertFrom_long(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float32x8 operator -(
            Int64x8 toAccumulate,
            Float32x8 current) =>
            ConvertFrom_long(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(true)]
        public static void AtomicAdd(
            ref Float32x8 target,
            Int64x8 value) =>
            AtomicAdd(ref target, ConvertFrom_long(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float32x8 ConvertFrom_long(
            Int64x8 other) =>
            new Float32x8((float)other.X, (float)other.Y, (float)other.Z, (float)other.W, (float)other.I, (float)other.J, (float)other.K, (float)other.L);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int64x8 ConvertTo_long(
            Float32x8 current) =>
            new Int64x8((long)current.X, (long)current.Y, (long)current.Z, (long)current.W, (long)current.I, (long)current.J, (long)current.K, (long)current.L);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float32x8 IAccumulationVectorType<
            Float32x8,
            Int64x8,
            long>.ConvertFromBase(Int64x8 other) =>
            ConvertFrom_long(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int64x8 IAccumulationVectorType<
            Float32x8,
            Int64x8,
            long>.ConvertToBase(Float32x8 current) =>
            ConvertTo_long(current);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float32x8 operator +(
            Float32x8 current,
            UInt64x8 toAccumulate) =>
            current + ConvertFrom_ulong(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float32x8 operator +(
            UInt64x8 toAccumulate,
            Float32x8 current) =>
            ConvertFrom_ulong(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float32x8 operator -(
            Float32x8 current,
            UInt64x8 toAccumulate) =>
            current - ConvertFrom_ulong(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float32x8 operator -(
            UInt64x8 toAccumulate,
            Float32x8 current) =>
            ConvertFrom_ulong(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref Float32x8 target,
            UInt64x8 value) =>
            AtomicAdd(ref target, ConvertFrom_ulong(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float32x8 ConvertFrom_ulong(
            UInt64x8 other) =>
            new Float32x8((float)other.X, (float)other.Y, (float)other.Z, (float)other.W, (float)other.I, (float)other.J, (float)other.K, (float)other.L);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt64x8 ConvertTo_ulong(
            Float32x8 current) =>
            new UInt64x8((ulong)current.X, (ulong)current.Y, (ulong)current.Z, (ulong)current.W, (ulong)current.I, (ulong)current.J, (ulong)current.K, (ulong)current.L);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float32x8 IAccumulationVectorType<
            Float32x8,
            UInt64x8,
            ulong>.ConvertFromBase(UInt64x8 other) =>
            ConvertFrom_ulong(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt64x8 IAccumulationVectorType<
            Float32x8,
            UInt64x8,
            ulong>.ConvertToBase(Float32x8 current) =>
            ConvertTo_ulong(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public Float32x8 ComputeAverage(ulong denominator) =>
            this / FromScalar((float)denominator);

        /// <summary>
        /// Converts this instance into an unsafe span instance.
        /// </summary>
        /// <returns>The readonly span instance.</returns>
        public unsafe ReadOnlySpan<float> AsSpan() =>
            new(Unsafe.AsPointer(ref Unsafe.AsRef(this)), 8);

        /// <summary>
        /// Iterates over all elements by applying the given iterator to each element.
        /// </summary>
        /// <typeparam name="TIterator">The managed iterator type.</typeparam>
        /// <param name="iterator">The iterator to invoke.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ForEach<TIterator>(ref TIterator iterator)
            where TIterator : struct, IVectorElementIterator<
            Float32x8,
            float>
        {
            iterator.Iterate(X, 0);
            iterator.Iterate(Y, 1);
            iterator.Iterate(Z, 2);
            iterator.Iterate(W, 3);
            iterator.Iterate(I, 4);
            iterator.Iterate(J, 5);
            iterator.Iterate(K, 6);
            iterator.Iterate(L, 7);
        }

        /// <summary>
        /// Converts this vector instance to a string.
        /// </summary>
        public override string ToString() =>
            $"{X}, {Y}, {Z}, {W}, {I}, {J}, {K}, {L}";

        /// <summary>
        /// Converts this vector instance to a string.
        /// </summary>
        public string ToString(string? format, IFormatProvider? formatProvider) =>
            $"{X.ToString(format, formatProvider)}, {Y.ToString(format, formatProvider)}, {Z.ToString(format, formatProvider)}, {W.ToString(format, formatProvider)}, {I.ToString(format, formatProvider)}, {J.ToString(format, formatProvider)}, {K.ToString(format, formatProvider)}, {L.ToString(format, formatProvider)}";

        /// <summary>
        /// Returns true.
        /// </summary>
        public static bool IsCanonical(Float32x8 value) => true;

        /// <summary>
        /// Returns false.
        /// </summary>
        public static bool IsComplexNumber(Float32x8 value) => false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsEvenInteger(Float32x8 value) =>
            float.IsEvenInteger(value.X) & float.IsEvenInteger(value.Y) & float.IsEvenInteger(value.Z) & float.IsEvenInteger(value.W) & float.IsEvenInteger(value.I) & float.IsEvenInteger(value.J) & float.IsEvenInteger(value.K) & float.IsEvenInteger(value.L);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsFinite(Float32x8 value) =>
            float.IsFinite(value.X) & float.IsFinite(value.Y) & float.IsFinite(value.Z) & float.IsFinite(value.W) & float.IsFinite(value.I) & float.IsFinite(value.J) & float.IsFinite(value.K) & float.IsFinite(value.L);

        /// <summary>
        /// Returns false.
        /// </summary>
        public static bool IsImaginaryNumber(Float32x8 value) => false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsInfinity(Float32x8 value) =>
            float.IsInfinity(value.X) | float.IsInfinity(value.Y) | float.IsInfinity(value.Z) | float.IsInfinity(value.W) | float.IsInfinity(value.I) | float.IsInfinity(value.J) | float.IsInfinity(value.K) | float.IsInfinity(value.L);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsInteger(Float32x8 value) =>
            float.IsInteger(value.X) & float.IsInteger(value.Y) & float.IsInteger(value.Z) & float.IsInteger(value.W) & float.IsInteger(value.I) & float.IsInteger(value.J) & float.IsInteger(value.K) & float.IsInteger(value.L);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNaN(Float32x8 value) =>
            float.IsNaN(value.X) | float.IsNaN(value.Y) | float.IsNaN(value.Z) | float.IsNaN(value.W) | float.IsNaN(value.I) | float.IsNaN(value.J) | float.IsNaN(value.K) | float.IsNaN(value.L);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNegative(Float32x8 value) =>
            float.IsNegative(value.X) & float.IsNegative(value.Y) & float.IsNegative(value.Z) & float.IsNegative(value.W) & float.IsNegative(value.I) & float.IsNegative(value.J) & float.IsNegative(value.K) & float.IsNegative(value.L);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNegativeInfinity(Float32x8 value) =>
            float.IsNegativeInfinity(value.X) | float.IsNegativeInfinity(value.Y) | float.IsNegativeInfinity(value.Z) | float.IsNegativeInfinity(value.W) | float.IsNegativeInfinity(value.I) | float.IsNegativeInfinity(value.J) | float.IsNegativeInfinity(value.K) | float.IsNegativeInfinity(value.L);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNormal(Float32x8 value) =>
            float.IsNormal(value.X) & float.IsNormal(value.Y) & float.IsNormal(value.Z) & float.IsNormal(value.W) & float.IsNormal(value.I) & float.IsNormal(value.J) & float.IsNormal(value.K) & float.IsNormal(value.L);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsOddInteger(Float32x8 value) =>
            float.IsOddInteger(value.X) & float.IsOddInteger(value.Y) & float.IsOddInteger(value.Z) & float.IsOddInteger(value.W) & float.IsOddInteger(value.I) & float.IsOddInteger(value.J) & float.IsOddInteger(value.K) & float.IsOddInteger(value.L);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsPositive(Float32x8 value) =>
            float.IsPositive(value.X) & float.IsPositive(value.Y) & float.IsPositive(value.Z) & float.IsPositive(value.W) & float.IsPositive(value.I) & float.IsPositive(value.J) & float.IsPositive(value.K) & float.IsPositive(value.L);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsPositiveInfinity(Float32x8 value) =>
            float.IsPositiveInfinity(value.X) | float.IsPositiveInfinity(value.Y) | float.IsPositiveInfinity(value.Z) | float.IsPositiveInfinity(value.W) | float.IsPositiveInfinity(value.I) | float.IsPositiveInfinity(value.J) | float.IsPositiveInfinity(value.K) | float.IsPositiveInfinity(value.L);

        /// <summary>
        /// Returns true.
        /// </summary>
        public static bool IsRealNumber(Float32x8 value) => true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsSubnormal(Float32x8 value) =>
            float.IsSubnormal(value.X) & float.IsSubnormal(value.Y) & float.IsSubnormal(value.Z) & float.IsSubnormal(value.W) & float.IsSubnormal(value.I) & float.IsSubnormal(value.J) & float.IsSubnormal(value.K) & float.IsSubnormal(value.L);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsZero(Float32x8 value) =>
            Abs(value) == Zero;

        /// <summary>
        /// Returns the absolute value.
        /// </summary>
        public static Float32x8 Abs(Float32x8 value) =>
            new Float32x8(Math.Abs(value.X), Math.Abs(value.Y), Math.Abs(value.Z), Math.Abs(value.W), Math.Abs(value.I), Math.Abs(value.J), Math.Abs(value.K), Math.Abs(value.L));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Float32x8 operator +(Float32x8 left, Float32x8 right) =>
            new Float32x8((float)(left.X + right.X), (float)(left.Y + right.Y), (float)(left.Z + right.Z), (float)(left.W + right.W), (float)(left.I + right.I), (float)(left.J + right.J), (float)(left.K + right.K), (float)(left.L + right.L));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Float32x8 operator --(Float32x8 value) => value - One;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Float32x8 operator /(Float32x8 left, Float32x8 right) =>
            new Float32x8((float)(left.X / right.X), (float)(left.Y / right.Y), (float)(left.Z / right.Z), (float)(left.W / right.W), (float)(left.I / right.I), (float)(left.J / right.J), (float)(left.K / right.K), (float)(left.L / right.L));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Float32x8 operator ++(Float32x8 value) => value + One;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Float32x8 operator *(Float32x8 left, Float32x8 right) =>
            new Float32x8((float)(left.X * right.X), (float)(left.Y * right.Y), (float)(left.Z * right.Z), (float)(left.W * right.W), (float)(left.I * right.I), (float)(left.J * right.J), (float)(left.K * right.K), (float)(left.L * right.L));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Float32x8 operator -(Float32x8 left, Float32x8 right) =>
            new Float32x8((float)(left.X - right.X), (float)(left.Y - right.Y), (float)(left.Z - right.Z), (float)(left.W - right.W), (float)(left.I - right.I), (float)(left.J - right.J), (float)(left.K - right.K), (float)(left.L - right.L));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Float32x8 operator -(Float32x8 value) =>
            new Float32x8((float)-value.X, (float)-value.Y, (float)-value.Z, (float)-value.W, (float)-value.I, (float)-value.J, (float)-value.K, (float)-value.L);

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Float32x8 operator +(Float32x8 value) => value;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Float32x8 MaxMagnitude(Float32x8 x, Float32x8 y) =>
            new Float32x8(float.MaxMagnitude(x.X, y.X), float.MaxMagnitude(x.Y, y.Y), float.MaxMagnitude(x.Z, y.Z), float.MaxMagnitude(x.W, y.W), float.MaxMagnitude(x.I, y.I), float.MaxMagnitude(x.J, y.J), float.MaxMagnitude(x.K, y.K), float.MaxMagnitude(x.L, y.L));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Float32x8 MaxMagnitudeNumber(Float32x8 x, Float32x8 y) =>
            new Float32x8(float.MaxMagnitudeNumber(x.X, y.X), float.MaxMagnitudeNumber(x.Y, y.Y), float.MaxMagnitudeNumber(x.Z, y.Z), float.MaxMagnitudeNumber(x.W, y.W), float.MaxMagnitudeNumber(x.I, y.I), float.MaxMagnitudeNumber(x.J, y.J), float.MaxMagnitudeNumber(x.K, y.K), float.MaxMagnitudeNumber(x.L, y.L));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Float32x8 MinMagnitude(Float32x8 x, Float32x8 y) =>
            new Float32x8(float.MinMagnitude(x.X, y.X), float.MinMagnitude(x.Y, y.Y), float.MinMagnitude(x.Z, y.Z), float.MinMagnitude(x.W, y.W), float.MinMagnitude(x.I, y.I), float.MinMagnitude(x.J, y.J), float.MinMagnitude(x.K, y.K), float.MinMagnitude(x.L, y.L));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Float32x8 MinMagnitudeNumber(Float32x8 x, Float32x8 y) =>
            new Float32x8(float.MinMagnitudeNumber(x.X, y.X), float.MinMagnitudeNumber(x.Y, y.Y), float.MinMagnitudeNumber(x.Z, y.Z), float.MinMagnitudeNumber(x.W, y.W), float.MinMagnitudeNumber(x.I, y.I), float.MinMagnitudeNumber(x.J, y.J), float.MinMagnitudeNumber(x.K, y.K), float.MinMagnitudeNumber(x.L, y.L));

        // Not supported operations

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static Float32x8 IParsable<Float32x8>.Parse(
            string s,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static Float32x8 ISpanParsable<Float32x8>.Parse(
            ReadOnlySpan<char> s,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static Float32x8 INumberBase<Float32x8>.Parse(
            ReadOnlySpan<char> s,
            NumberStyles style,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static Float32x8 INumberBase<Float32x8>.Parse(
            string s,
            NumberStyles style,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        bool ISpanFormattable.TryFormat(
            Span<char> destination,
            out int charsWritten,
            ReadOnlySpan<char> format,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool IParsable<Float32x8>.TryParse(
            string? s,
            IFormatProvider? provider,
            out Float32x8 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given span into a vectorized instance.
        /// </summary>
        static bool ISpanParsable<Float32x8>.TryParse(
            ReadOnlySpan<char> s,
            IFormatProvider? provider,
            out Float32x8 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool INumberBase<Float32x8>.TryParse(
            ReadOnlySpan<char> s,
            NumberStyles style,
            IFormatProvider? provider,
            out Float32x8 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool INumberBase<Float32x8>.TryParse(
            string? s,
            NumberStyles style,
            IFormatProvider? provider,
            out Float32x8 result) =>
            throw new NotSupportedException();

        static bool INumberBase<Float32x8>.TryConvertFromChecked<TOther>(
            TOther value,
            out Float32x8 result) =>
            throw new NotSupportedException();
        static bool INumberBase<Float32x8>.TryConvertFromSaturating<TOther>(
            TOther value,
            out Float32x8 result) =>
            throw new NotSupportedException();
        static bool INumberBase<Float32x8>.TryConvertFromTruncating<TOther>(
            TOther value,
            out Float32x8 result) =>
            throw new NotSupportedException();
        static bool INumberBase<Float32x8>.TryConvertToChecked<TOther>(
            Float32x8 value,
            out TOther result) =>
            throw new NotSupportedException();
        static bool INumberBase<Float32x8>.TryConvertToSaturating<TOther>(
            Float32x8 value,
            out TOther result) =>
            throw new NotSupportedException();
        static bool INumberBase<Float32x8>.TryConvertToTruncating<TOther>(
            Float32x8 value,
            out TOther result) =>
            throw new NotSupportedException();
    }

    /// <summary>
    /// Represents a vectorized double type with length 2.
    /// </summary>
    public readonly record struct Float64x2(
        double X, double Y) :
        IVectorType<Float64x2, double>
        , IAccumulationVectorType<
            Float64x2,
            Float32x2,
            float>
        , IAccumulationVectorType<
            Float64x2,
            Float64x2,
            double>
        , IAccumulationVectorType<
            Float64x2,
            UInt8x2,
            byte>
        , IAccumulationVectorType<
            Float64x2,
            Int8x2,
            sbyte>
        , IAccumulationVectorType<
            Float64x2,
            Int16x2,
            short>
        , IAccumulationVectorType<
            Float64x2,
            UInt16x2,
            ushort>
        , IAccumulationVectorType<
            Float64x2,
            Int32x2,
            int>
        , IAccumulationVectorType<
            Float64x2,
            UInt32x2,
            uint>
        , IAccumulationVectorType<
            Float64x2,
            Int64x2,
            long>
        , IAccumulationVectorType<
            Float64x2,
            UInt64x2,
            ulong>
    {
        /// <summary>
        /// The offset of the X field in bytes.
        /// </summary>
        public static readonly int OffsetX =
            sizeof(double) * 0;

        /// <summary>
        /// The offset of the X field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrX =>
            new UIntPtr((uint)OffsetX);
        /// <summary>
        /// The offset of the Y field in bytes.
        /// </summary>
        public static readonly int OffsetY =
            sizeof(double) * 1;

        /// <summary>
        /// The offset of the Y field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrY =>
            new UIntPtr((uint)OffsetY);

        /// <summary>
        /// Returns the length of this vector which is 2.
        /// </summary>
        public static int Length => 2;

        /// <summary>
        /// Returns the radix of the underlying value.
        /// </summary>
        public static int Radix => 10;

        /// <summary>
        /// Returns an invalid value (min [signed types], max value [unsigned] or NaN).
        /// </summary>
        public static Float64x2 Invalid => FromScalar(
            double.NaN
        );

        /// <summary>
        /// Returns the value zero.
        /// </summary>
        public static Float64x2 Zero => new();

        /// <summary>
        /// Returns the value one.
        /// </summary>
        public static Float64x2 One => FromScalar((1));

        /// <summary>
        /// Returns the value zero.
        /// </summary>
        public static Float64x2 AdditiveIdentity => Zero;

        /// <summary>
        /// Returns the value one.
        /// </summary>
        public static Float64x2 MultiplicativeIdentity => One;

        /// <summary>
        /// Computes the min value of both.
        /// </summary>
        /// <param name="first">The first value.</param>
        /// <param name="second">The second value.</param>
        /// <returns>The min value.</returns>
        public static Float64x2 Min(
            Float64x2 first,
            Float64x2 second) =>
            new Float64x2((double)Math.Min(first.X, second.X), (double)Math.Min(first.Y, second.Y));

        /// <summary>
        /// Computes the max value of both.
        /// </summary>
        /// <param name="first">The first value.</param>
        /// <param name="second">The second value.</param>
        /// <returns>The max value.</returns>
        public static Float64x2 Max(
            Float64x2 first,
            Float64x2 second) =>
            new Float64x2((double)Math.Max(first.X, second.X), (double)Math.Max(first.Y, second.Y));

        /// <summary>
        /// Clamps the given value.
        /// </summary>
        /// <param name="value">The value to clamp.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The clamped value.</returns>
        public static Float64x2 Clamp(
            Float64x2 value,
            Float64x2 min,
            Float64x2 max) =>
            Max(Min(value, max), min);

        /// <summary>
        /// Creates a random scalar instance falling into the range of min max.
        /// </summary>
        /// <param name="random">The random provider to use.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The created random scalar instance.</returns>
        public static double GetRandomScalar<TRandom>(
            ref TRandom random,
            double min,
            double max)
            where TRandom : struct, IRandomProvider =>
            (double)RandomExtensions.
                Next(ref random, min, max);

        /// <summary>
        /// Creates a random vector instance falling into the range of min max.
        /// </summary>
        /// <param name="random">The random provider to use.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The created random vector instance.</returns>
        public static Float64x2 GetRandom<TRandom>(
            ref TRandom random,
            Float64x2 min,
            Float64x2 max)
            where TRandom : struct, IRandomProvider
        {
            double x = GetRandomScalar(
                ref random, min.X, max.X);
            double y = GetRandomScalar(
                ref random, min.Y, max.Y);
            return new Float64x2(x, y);
        }

        /// <summary>
        /// Creates a vector instance from the given source view.
        /// </summary>
        /// <typeparam name="TStride">The custom stride type.</typeparam>
        /// <param name="sourceView">The source view.</param>
        /// <param name="index">The source base index.</param>
        /// <returns>The vector instance.</returns>
        public static Float64x2 FromElementView<TStride>(
            ArrayView1D<double, TStride> sourceView,
            Index1D index)
            where TStride : struct, IStride1D =>
            new Float64x2(
                sourceView[index + 0],
                sourceView[index + 1]
                );

        /// <summary>
        /// Serializes the current vector instance into the given target view.
        /// </summary>
        /// <typeparam name="TStride">The custom stride type.</typeparam>
        /// <param name="targetView">The target view.</param>
        /// <param name="index">The target base index.</param>
        public void ToElementView<TStride>(
            ArrayView1D<double, TStride> targetView,
            Index1D index)
            where TStride : struct, IStride1D
        {
            targetView[index + 0] = X;
            targetView[index + 1] = Y;
        }

        /// <summary>
        /// Creates a vector instance from the given source view.
        /// </summary>
        /// <param name="sourceView">The source view.</param>
        /// <param name="index">The source base index.</param>
        /// <returns>The vector instance.</returns>
        public static Float64x2 FromElementView(
            SingleVectorView<double> sourceView,
            Index1D index) =>
            new Float64x2(
                sourceView[index + 0],
                sourceView[index + 1]
                );

        /// <summary>
        /// Serializes the current vector instance into the given target view.
        /// </summary>
        /// <param name="targetView">The target view.</param>
        /// <param name="index">The target base index.</param>
        public void ToElementView(
            SingleVectorView<double> targetView,
            Index1D index)
        {
            targetView[index + 0] = X;
            targetView[index + 1] = Y;
        }

        /// <summary>
        /// Converts a scalar value into the current vectorized type.
        /// </summary>
        /// <param name="scalar">The scalar element type.</param>
        /// <returns>The created vectorized type.</returns>
        public static Float64x2 FromScalar(double scalar) =>
            new Float64x2(scalar, scalar);

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        public static void AtomicAdd(ref Float64x2 target, Float64x2 value)
        {
            ref var elementRef = ref Unsafe.As<Float64x2, double>(
                ref target);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrX),
                value.X);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrY),
                value.Y);
        }

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        public Float64x2 ComputeAverage(long denominator) =>
            this / FromScalar((double)denominator);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float64x2 operator +(
            Float64x2 current,
            Float32x2 toAccumulate) =>
            current + ConvertFrom_float(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float64x2 operator +(
            Float32x2 toAccumulate,
            Float64x2 current) =>
            ConvertFrom_float(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float64x2 operator -(
            Float64x2 current,
            Float32x2 toAccumulate) =>
            current - ConvertFrom_float(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float64x2 operator -(
            Float32x2 toAccumulate,
            Float64x2 current) =>
            ConvertFrom_float(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(true)]
        public static void AtomicAdd(
            ref Float64x2 target,
            Float32x2 value) =>
            AtomicAdd(ref target, ConvertFrom_float(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float64x2 ConvertFrom_float(
            Float32x2 other) =>
            new Float64x2((double)other.X, (double)other.Y);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float32x2 ConvertTo_float(
            Float64x2 current) =>
            new Float32x2((float)current.X, (float)current.Y);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float64x2 IAccumulationVectorType<
            Float64x2,
            Float32x2,
            float>.ConvertFromBase(Float32x2 other) =>
            ConvertFrom_float(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float32x2 IAccumulationVectorType<
            Float64x2,
            Float32x2,
            float>.ConvertToBase(Float64x2 current) =>
            ConvertTo_float(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(true)]
        public Float64x2 ComputeAverage(float denominator) =>
            this / FromScalar((double)denominator);


        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float64x2 ConvertFrom_double(
            Float64x2 other) =>
            new Float64x2((double)other.X, (double)other.Y);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float64x2 ConvertTo_double(
            Float64x2 current) =>
            new Float64x2((double)current.X, (double)current.Y);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float64x2 IAccumulationVectorType<
            Float64x2,
            Float64x2,
            double>.ConvertFromBase(Float64x2 other) =>
            ConvertFrom_double(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float64x2 IAccumulationVectorType<
            Float64x2,
            Float64x2,
            double>.ConvertToBase(Float64x2 current) =>
            ConvertTo_double(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(true)]
        public Float64x2 ComputeAverage(double denominator) =>
            this / FromScalar((double)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float64x2 operator +(
            Float64x2 current,
            UInt8x2 toAccumulate) =>
            current + ConvertFrom_byte(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float64x2 operator +(
            UInt8x2 toAccumulate,
            Float64x2 current) =>
            ConvertFrom_byte(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float64x2 operator -(
            Float64x2 current,
            UInt8x2 toAccumulate) =>
            current - ConvertFrom_byte(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float64x2 operator -(
            UInt8x2 toAccumulate,
            Float64x2 current) =>
            ConvertFrom_byte(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref Float64x2 target,
            UInt8x2 value) =>
            AtomicAdd(ref target, ConvertFrom_byte(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float64x2 ConvertFrom_byte(
            UInt8x2 other) =>
            new Float64x2((double)other.X, (double)other.Y);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt8x2 ConvertTo_byte(
            Float64x2 current) =>
            new UInt8x2((byte)current.X, (byte)current.Y);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float64x2 IAccumulationVectorType<
            Float64x2,
            UInt8x2,
            byte>.ConvertFromBase(UInt8x2 other) =>
            ConvertFrom_byte(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt8x2 IAccumulationVectorType<
            Float64x2,
            UInt8x2,
            byte>.ConvertToBase(Float64x2 current) =>
            ConvertTo_byte(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public Float64x2 ComputeAverage(byte denominator) =>
            this / FromScalar((double)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float64x2 operator +(
            Float64x2 current,
            Int8x2 toAccumulate) =>
            current + ConvertFrom_sbyte(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float64x2 operator +(
            Int8x2 toAccumulate,
            Float64x2 current) =>
            ConvertFrom_sbyte(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float64x2 operator -(
            Float64x2 current,
            Int8x2 toAccumulate) =>
            current - ConvertFrom_sbyte(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float64x2 operator -(
            Int8x2 toAccumulate,
            Float64x2 current) =>
            ConvertFrom_sbyte(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref Float64x2 target,
            Int8x2 value) =>
            AtomicAdd(ref target, ConvertFrom_sbyte(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float64x2 ConvertFrom_sbyte(
            Int8x2 other) =>
            new Float64x2((double)other.X, (double)other.Y);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int8x2 ConvertTo_sbyte(
            Float64x2 current) =>
            new Int8x2((sbyte)current.X, (sbyte)current.Y);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float64x2 IAccumulationVectorType<
            Float64x2,
            Int8x2,
            sbyte>.ConvertFromBase(Int8x2 other) =>
            ConvertFrom_sbyte(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int8x2 IAccumulationVectorType<
            Float64x2,
            Int8x2,
            sbyte>.ConvertToBase(Float64x2 current) =>
            ConvertTo_sbyte(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public Float64x2 ComputeAverage(sbyte denominator) =>
            this / FromScalar((double)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float64x2 operator +(
            Float64x2 current,
            Int16x2 toAccumulate) =>
            current + ConvertFrom_short(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float64x2 operator +(
            Int16x2 toAccumulate,
            Float64x2 current) =>
            ConvertFrom_short(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float64x2 operator -(
            Float64x2 current,
            Int16x2 toAccumulate) =>
            current - ConvertFrom_short(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float64x2 operator -(
            Int16x2 toAccumulate,
            Float64x2 current) =>
            ConvertFrom_short(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(true)]
        public static void AtomicAdd(
            ref Float64x2 target,
            Int16x2 value) =>
            AtomicAdd(ref target, ConvertFrom_short(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float64x2 ConvertFrom_short(
            Int16x2 other) =>
            new Float64x2((double)other.X, (double)other.Y);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int16x2 ConvertTo_short(
            Float64x2 current) =>
            new Int16x2((short)current.X, (short)current.Y);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float64x2 IAccumulationVectorType<
            Float64x2,
            Int16x2,
            short>.ConvertFromBase(Int16x2 other) =>
            ConvertFrom_short(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int16x2 IAccumulationVectorType<
            Float64x2,
            Int16x2,
            short>.ConvertToBase(Float64x2 current) =>
            ConvertTo_short(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(true)]
        public Float64x2 ComputeAverage(short denominator) =>
            this / FromScalar((double)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float64x2 operator +(
            Float64x2 current,
            UInt16x2 toAccumulate) =>
            current + ConvertFrom_ushort(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float64x2 operator +(
            UInt16x2 toAccumulate,
            Float64x2 current) =>
            ConvertFrom_ushort(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float64x2 operator -(
            Float64x2 current,
            UInt16x2 toAccumulate) =>
            current - ConvertFrom_ushort(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float64x2 operator -(
            UInt16x2 toAccumulate,
            Float64x2 current) =>
            ConvertFrom_ushort(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref Float64x2 target,
            UInt16x2 value) =>
            AtomicAdd(ref target, ConvertFrom_ushort(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float64x2 ConvertFrom_ushort(
            UInt16x2 other) =>
            new Float64x2((double)other.X, (double)other.Y);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt16x2 ConvertTo_ushort(
            Float64x2 current) =>
            new UInt16x2((ushort)current.X, (ushort)current.Y);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float64x2 IAccumulationVectorType<
            Float64x2,
            UInt16x2,
            ushort>.ConvertFromBase(UInt16x2 other) =>
            ConvertFrom_ushort(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt16x2 IAccumulationVectorType<
            Float64x2,
            UInt16x2,
            ushort>.ConvertToBase(Float64x2 current) =>
            ConvertTo_ushort(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public Float64x2 ComputeAverage(ushort denominator) =>
            this / FromScalar((double)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float64x2 operator +(
            Float64x2 current,
            Int32x2 toAccumulate) =>
            current + ConvertFrom_int(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float64x2 operator +(
            Int32x2 toAccumulate,
            Float64x2 current) =>
            ConvertFrom_int(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float64x2 operator -(
            Float64x2 current,
            Int32x2 toAccumulate) =>
            current - ConvertFrom_int(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float64x2 operator -(
            Int32x2 toAccumulate,
            Float64x2 current) =>
            ConvertFrom_int(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(true)]
        public static void AtomicAdd(
            ref Float64x2 target,
            Int32x2 value) =>
            AtomicAdd(ref target, ConvertFrom_int(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float64x2 ConvertFrom_int(
            Int32x2 other) =>
            new Float64x2((double)other.X, (double)other.Y);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int32x2 ConvertTo_int(
            Float64x2 current) =>
            new Int32x2((int)current.X, (int)current.Y);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float64x2 IAccumulationVectorType<
            Float64x2,
            Int32x2,
            int>.ConvertFromBase(Int32x2 other) =>
            ConvertFrom_int(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int32x2 IAccumulationVectorType<
            Float64x2,
            Int32x2,
            int>.ConvertToBase(Float64x2 current) =>
            ConvertTo_int(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(true)]
        public Float64x2 ComputeAverage(int denominator) =>
            this / FromScalar((double)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float64x2 operator +(
            Float64x2 current,
            UInt32x2 toAccumulate) =>
            current + ConvertFrom_uint(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float64x2 operator +(
            UInt32x2 toAccumulate,
            Float64x2 current) =>
            ConvertFrom_uint(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float64x2 operator -(
            Float64x2 current,
            UInt32x2 toAccumulate) =>
            current - ConvertFrom_uint(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float64x2 operator -(
            UInt32x2 toAccumulate,
            Float64x2 current) =>
            ConvertFrom_uint(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref Float64x2 target,
            UInt32x2 value) =>
            AtomicAdd(ref target, ConvertFrom_uint(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float64x2 ConvertFrom_uint(
            UInt32x2 other) =>
            new Float64x2((double)other.X, (double)other.Y);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt32x2 ConvertTo_uint(
            Float64x2 current) =>
            new UInt32x2((uint)current.X, (uint)current.Y);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float64x2 IAccumulationVectorType<
            Float64x2,
            UInt32x2,
            uint>.ConvertFromBase(UInt32x2 other) =>
            ConvertFrom_uint(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt32x2 IAccumulationVectorType<
            Float64x2,
            UInt32x2,
            uint>.ConvertToBase(Float64x2 current) =>
            ConvertTo_uint(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public Float64x2 ComputeAverage(uint denominator) =>
            this / FromScalar((double)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float64x2 operator +(
            Float64x2 current,
            Int64x2 toAccumulate) =>
            current + ConvertFrom_long(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float64x2 operator +(
            Int64x2 toAccumulate,
            Float64x2 current) =>
            ConvertFrom_long(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float64x2 operator -(
            Float64x2 current,
            Int64x2 toAccumulate) =>
            current - ConvertFrom_long(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float64x2 operator -(
            Int64x2 toAccumulate,
            Float64x2 current) =>
            ConvertFrom_long(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(true)]
        public static void AtomicAdd(
            ref Float64x2 target,
            Int64x2 value) =>
            AtomicAdd(ref target, ConvertFrom_long(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float64x2 ConvertFrom_long(
            Int64x2 other) =>
            new Float64x2((double)other.X, (double)other.Y);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int64x2 ConvertTo_long(
            Float64x2 current) =>
            new Int64x2((long)current.X, (long)current.Y);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float64x2 IAccumulationVectorType<
            Float64x2,
            Int64x2,
            long>.ConvertFromBase(Int64x2 other) =>
            ConvertFrom_long(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int64x2 IAccumulationVectorType<
            Float64x2,
            Int64x2,
            long>.ConvertToBase(Float64x2 current) =>
            ConvertTo_long(current);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float64x2 operator +(
            Float64x2 current,
            UInt64x2 toAccumulate) =>
            current + ConvertFrom_ulong(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float64x2 operator +(
            UInt64x2 toAccumulate,
            Float64x2 current) =>
            ConvertFrom_ulong(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float64x2 operator -(
            Float64x2 current,
            UInt64x2 toAccumulate) =>
            current - ConvertFrom_ulong(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float64x2 operator -(
            UInt64x2 toAccumulate,
            Float64x2 current) =>
            ConvertFrom_ulong(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref Float64x2 target,
            UInt64x2 value) =>
            AtomicAdd(ref target, ConvertFrom_ulong(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float64x2 ConvertFrom_ulong(
            UInt64x2 other) =>
            new Float64x2((double)other.X, (double)other.Y);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt64x2 ConvertTo_ulong(
            Float64x2 current) =>
            new UInt64x2((ulong)current.X, (ulong)current.Y);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float64x2 IAccumulationVectorType<
            Float64x2,
            UInt64x2,
            ulong>.ConvertFromBase(UInt64x2 other) =>
            ConvertFrom_ulong(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt64x2 IAccumulationVectorType<
            Float64x2,
            UInt64x2,
            ulong>.ConvertToBase(Float64x2 current) =>
            ConvertTo_ulong(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public Float64x2 ComputeAverage(ulong denominator) =>
            this / FromScalar((double)denominator);

        /// <summary>
        /// Converts this instance into an unsafe span instance.
        /// </summary>
        /// <returns>The readonly span instance.</returns>
        public unsafe ReadOnlySpan<double> AsSpan() =>
            new(Unsafe.AsPointer(ref Unsafe.AsRef(this)), 2);

        /// <summary>
        /// Iterates over all elements by applying the given iterator to each element.
        /// </summary>
        /// <typeparam name="TIterator">The managed iterator type.</typeparam>
        /// <param name="iterator">The iterator to invoke.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ForEach<TIterator>(ref TIterator iterator)
            where TIterator : struct, IVectorElementIterator<
            Float64x2,
            double>
        {
            iterator.Iterate(X, 0);
            iterator.Iterate(Y, 1);
        }

        /// <summary>
        /// Converts this vector instance to a string.
        /// </summary>
        public override string ToString() =>
            $"{X}, {Y}";

        /// <summary>
        /// Converts this vector instance to a string.
        /// </summary>
        public string ToString(string? format, IFormatProvider? formatProvider) =>
            $"{X.ToString(format, formatProvider)}, {Y.ToString(format, formatProvider)}";

        /// <summary>
        /// Returns true.
        /// </summary>
        public static bool IsCanonical(Float64x2 value) => true;

        /// <summary>
        /// Returns false.
        /// </summary>
        public static bool IsComplexNumber(Float64x2 value) => false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsEvenInteger(Float64x2 value) =>
            double.IsEvenInteger(value.X) & double.IsEvenInteger(value.Y);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsFinite(Float64x2 value) =>
            double.IsFinite(value.X) & double.IsFinite(value.Y);

        /// <summary>
        /// Returns false.
        /// </summary>
        public static bool IsImaginaryNumber(Float64x2 value) => false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsInfinity(Float64x2 value) =>
            double.IsInfinity(value.X) | double.IsInfinity(value.Y);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsInteger(Float64x2 value) =>
            double.IsInteger(value.X) & double.IsInteger(value.Y);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNaN(Float64x2 value) =>
            double.IsNaN(value.X) | double.IsNaN(value.Y);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNegative(Float64x2 value) =>
            double.IsNegative(value.X) & double.IsNegative(value.Y);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNegativeInfinity(Float64x2 value) =>
            double.IsNegativeInfinity(value.X) | double.IsNegativeInfinity(value.Y);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNormal(Float64x2 value) =>
            double.IsNormal(value.X) & double.IsNormal(value.Y);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsOddInteger(Float64x2 value) =>
            double.IsOddInteger(value.X) & double.IsOddInteger(value.Y);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsPositive(Float64x2 value) =>
            double.IsPositive(value.X) & double.IsPositive(value.Y);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsPositiveInfinity(Float64x2 value) =>
            double.IsPositiveInfinity(value.X) | double.IsPositiveInfinity(value.Y);

        /// <summary>
        /// Returns true.
        /// </summary>
        public static bool IsRealNumber(Float64x2 value) => true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsSubnormal(Float64x2 value) =>
            double.IsSubnormal(value.X) & double.IsSubnormal(value.Y);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsZero(Float64x2 value) =>
            Abs(value) == Zero;

        /// <summary>
        /// Returns the absolute value.
        /// </summary>
        public static Float64x2 Abs(Float64x2 value) =>
            new Float64x2(Math.Abs(value.X), Math.Abs(value.Y));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Float64x2 operator +(Float64x2 left, Float64x2 right) =>
            new Float64x2((double)(left.X + right.X), (double)(left.Y + right.Y));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Float64x2 operator --(Float64x2 value) => value - One;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Float64x2 operator /(Float64x2 left, Float64x2 right) =>
            new Float64x2((double)(left.X / right.X), (double)(left.Y / right.Y));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Float64x2 operator ++(Float64x2 value) => value + One;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Float64x2 operator *(Float64x2 left, Float64x2 right) =>
            new Float64x2((double)(left.X * right.X), (double)(left.Y * right.Y));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Float64x2 operator -(Float64x2 left, Float64x2 right) =>
            new Float64x2((double)(left.X - right.X), (double)(left.Y - right.Y));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Float64x2 operator -(Float64x2 value) =>
            new Float64x2((double)-value.X, (double)-value.Y);

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Float64x2 operator +(Float64x2 value) => value;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Float64x2 MaxMagnitude(Float64x2 x, Float64x2 y) =>
            new Float64x2(double.MaxMagnitude(x.X, y.X), double.MaxMagnitude(x.Y, y.Y));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Float64x2 MaxMagnitudeNumber(Float64x2 x, Float64x2 y) =>
            new Float64x2(double.MaxMagnitudeNumber(x.X, y.X), double.MaxMagnitudeNumber(x.Y, y.Y));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Float64x2 MinMagnitude(Float64x2 x, Float64x2 y) =>
            new Float64x2(double.MinMagnitude(x.X, y.X), double.MinMagnitude(x.Y, y.Y));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Float64x2 MinMagnitudeNumber(Float64x2 x, Float64x2 y) =>
            new Float64x2(double.MinMagnitudeNumber(x.X, y.X), double.MinMagnitudeNumber(x.Y, y.Y));

        // Not supported operations

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static Float64x2 IParsable<Float64x2>.Parse(
            string s,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static Float64x2 ISpanParsable<Float64x2>.Parse(
            ReadOnlySpan<char> s,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static Float64x2 INumberBase<Float64x2>.Parse(
            ReadOnlySpan<char> s,
            NumberStyles style,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static Float64x2 INumberBase<Float64x2>.Parse(
            string s,
            NumberStyles style,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        bool ISpanFormattable.TryFormat(
            Span<char> destination,
            out int charsWritten,
            ReadOnlySpan<char> format,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool IParsable<Float64x2>.TryParse(
            string? s,
            IFormatProvider? provider,
            out Float64x2 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given span into a vectorized instance.
        /// </summary>
        static bool ISpanParsable<Float64x2>.TryParse(
            ReadOnlySpan<char> s,
            IFormatProvider? provider,
            out Float64x2 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool INumberBase<Float64x2>.TryParse(
            ReadOnlySpan<char> s,
            NumberStyles style,
            IFormatProvider? provider,
            out Float64x2 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool INumberBase<Float64x2>.TryParse(
            string? s,
            NumberStyles style,
            IFormatProvider? provider,
            out Float64x2 result) =>
            throw new NotSupportedException();

        static bool INumberBase<Float64x2>.TryConvertFromChecked<TOther>(
            TOther value,
            out Float64x2 result) =>
            throw new NotSupportedException();
        static bool INumberBase<Float64x2>.TryConvertFromSaturating<TOther>(
            TOther value,
            out Float64x2 result) =>
            throw new NotSupportedException();
        static bool INumberBase<Float64x2>.TryConvertFromTruncating<TOther>(
            TOther value,
            out Float64x2 result) =>
            throw new NotSupportedException();
        static bool INumberBase<Float64x2>.TryConvertToChecked<TOther>(
            Float64x2 value,
            out TOther result) =>
            throw new NotSupportedException();
        static bool INumberBase<Float64x2>.TryConvertToSaturating<TOther>(
            Float64x2 value,
            out TOther result) =>
            throw new NotSupportedException();
        static bool INumberBase<Float64x2>.TryConvertToTruncating<TOther>(
            Float64x2 value,
            out TOther result) =>
            throw new NotSupportedException();
    }

    /// <summary>
    /// Represents a vectorized double type with length 4.
    /// </summary>
    public readonly record struct Float64x4(
        double X, double Y, double Z, double W) :
        IVectorType<Float64x4, double>
        , IAccumulationVectorType<
            Float64x4,
            Float32x4,
            float>
        , IAccumulationVectorType<
            Float64x4,
            Float64x4,
            double>
        , IAccumulationVectorType<
            Float64x4,
            UInt8x4,
            byte>
        , IAccumulationVectorType<
            Float64x4,
            Int8x4,
            sbyte>
        , IAccumulationVectorType<
            Float64x4,
            Int16x4,
            short>
        , IAccumulationVectorType<
            Float64x4,
            UInt16x4,
            ushort>
        , IAccumulationVectorType<
            Float64x4,
            Int32x4,
            int>
        , IAccumulationVectorType<
            Float64x4,
            UInt32x4,
            uint>
        , IAccumulationVectorType<
            Float64x4,
            Int64x4,
            long>
        , IAccumulationVectorType<
            Float64x4,
            UInt64x4,
            ulong>
    {
        /// <summary>
        /// The offset of the X field in bytes.
        /// </summary>
        public static readonly int OffsetX =
            sizeof(double) * 0;

        /// <summary>
        /// The offset of the X field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrX =>
            new UIntPtr((uint)OffsetX);
        /// <summary>
        /// The offset of the Y field in bytes.
        /// </summary>
        public static readonly int OffsetY =
            sizeof(double) * 1;

        /// <summary>
        /// The offset of the Y field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrY =>
            new UIntPtr((uint)OffsetY);
        /// <summary>
        /// The offset of the Z field in bytes.
        /// </summary>
        public static readonly int OffsetZ =
            sizeof(double) * 2;

        /// <summary>
        /// The offset of the Z field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrZ =>
            new UIntPtr((uint)OffsetZ);
        /// <summary>
        /// The offset of the W field in bytes.
        /// </summary>
        public static readonly int OffsetW =
            sizeof(double) * 3;

        /// <summary>
        /// The offset of the W field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrW =>
            new UIntPtr((uint)OffsetW);

        /// <summary>
        /// Returns the length of this vector which is 4.
        /// </summary>
        public static int Length => 4;

        /// <summary>
        /// Returns the radix of the underlying value.
        /// </summary>
        public static int Radix => 10;

        /// <summary>
        /// Returns an invalid value (min [signed types], max value [unsigned] or NaN).
        /// </summary>
        public static Float64x4 Invalid => FromScalar(
            double.NaN
        );

        /// <summary>
        /// Returns the value zero.
        /// </summary>
        public static Float64x4 Zero => new();

        /// <summary>
        /// Returns the value one.
        /// </summary>
        public static Float64x4 One => FromScalar((1));

        /// <summary>
        /// Returns the value zero.
        /// </summary>
        public static Float64x4 AdditiveIdentity => Zero;

        /// <summary>
        /// Returns the value one.
        /// </summary>
        public static Float64x4 MultiplicativeIdentity => One;

        /// <summary>
        /// Computes the min value of both.
        /// </summary>
        /// <param name="first">The first value.</param>
        /// <param name="second">The second value.</param>
        /// <returns>The min value.</returns>
        public static Float64x4 Min(
            Float64x4 first,
            Float64x4 second) =>
            new Float64x4((double)Math.Min(first.X, second.X), (double)Math.Min(first.Y, second.Y), (double)Math.Min(first.Z, second.Z), (double)Math.Min(first.W, second.W));

        /// <summary>
        /// Computes the max value of both.
        /// </summary>
        /// <param name="first">The first value.</param>
        /// <param name="second">The second value.</param>
        /// <returns>The max value.</returns>
        public static Float64x4 Max(
            Float64x4 first,
            Float64x4 second) =>
            new Float64x4((double)Math.Max(first.X, second.X), (double)Math.Max(first.Y, second.Y), (double)Math.Max(first.Z, second.Z), (double)Math.Max(first.W, second.W));

        /// <summary>
        /// Clamps the given value.
        /// </summary>
        /// <param name="value">The value to clamp.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The clamped value.</returns>
        public static Float64x4 Clamp(
            Float64x4 value,
            Float64x4 min,
            Float64x4 max) =>
            Max(Min(value, max), min);

        /// <summary>
        /// Creates a random scalar instance falling into the range of min max.
        /// </summary>
        /// <param name="random">The random provider to use.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The created random scalar instance.</returns>
        public static double GetRandomScalar<TRandom>(
            ref TRandom random,
            double min,
            double max)
            where TRandom : struct, IRandomProvider =>
            (double)RandomExtensions.
                Next(ref random, min, max);

        /// <summary>
        /// Creates a random vector instance falling into the range of min max.
        /// </summary>
        /// <param name="random">The random provider to use.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The created random vector instance.</returns>
        public static Float64x4 GetRandom<TRandom>(
            ref TRandom random,
            Float64x4 min,
            Float64x4 max)
            where TRandom : struct, IRandomProvider
        {
            double x = GetRandomScalar(
                ref random, min.X, max.X);
            double y = GetRandomScalar(
                ref random, min.Y, max.Y);
            double z = GetRandomScalar(
                ref random, min.Z, max.Z);
            double w = GetRandomScalar(
                ref random, min.W, max.W);
            return new Float64x4(x, y, z, w);
        }

        /// <summary>
        /// Creates a vector instance from the given source view.
        /// </summary>
        /// <typeparam name="TStride">The custom stride type.</typeparam>
        /// <param name="sourceView">The source view.</param>
        /// <param name="index">The source base index.</param>
        /// <returns>The vector instance.</returns>
        public static Float64x4 FromElementView<TStride>(
            ArrayView1D<double, TStride> sourceView,
            Index1D index)
            where TStride : struct, IStride1D =>
            new Float64x4(
                sourceView[index + 0],
                sourceView[index + 1],
                sourceView[index + 2],
                sourceView[index + 3]
                );

        /// <summary>
        /// Serializes the current vector instance into the given target view.
        /// </summary>
        /// <typeparam name="TStride">The custom stride type.</typeparam>
        /// <param name="targetView">The target view.</param>
        /// <param name="index">The target base index.</param>
        public void ToElementView<TStride>(
            ArrayView1D<double, TStride> targetView,
            Index1D index)
            where TStride : struct, IStride1D
        {
            targetView[index + 0] = X;
            targetView[index + 1] = Y;
            targetView[index + 2] = Z;
            targetView[index + 3] = W;
        }

        /// <summary>
        /// Creates a vector instance from the given source view.
        /// </summary>
        /// <param name="sourceView">The source view.</param>
        /// <param name="index">The source base index.</param>
        /// <returns>The vector instance.</returns>
        public static Float64x4 FromElementView(
            SingleVectorView<double> sourceView,
            Index1D index) =>
            new Float64x4(
                sourceView[index + 0],
                sourceView[index + 1],
                sourceView[index + 2],
                sourceView[index + 3]
                );

        /// <summary>
        /// Serializes the current vector instance into the given target view.
        /// </summary>
        /// <param name="targetView">The target view.</param>
        /// <param name="index">The target base index.</param>
        public void ToElementView(
            SingleVectorView<double> targetView,
            Index1D index)
        {
            targetView[index + 0] = X;
            targetView[index + 1] = Y;
            targetView[index + 2] = Z;
            targetView[index + 3] = W;
        }

        /// <summary>
        /// Converts a scalar value into the current vectorized type.
        /// </summary>
        /// <param name="scalar">The scalar element type.</param>
        /// <returns>The created vectorized type.</returns>
        public static Float64x4 FromScalar(double scalar) =>
            new Float64x4(scalar, scalar, scalar, scalar);

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        public static void AtomicAdd(ref Float64x4 target, Float64x4 value)
        {
            ref var elementRef = ref Unsafe.As<Float64x4, double>(
                ref target);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrX),
                value.X);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrY),
                value.Y);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrZ),
                value.Z);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrW),
                value.W);
        }

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        public Float64x4 ComputeAverage(long denominator) =>
            this / FromScalar((double)denominator);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float64x4 operator +(
            Float64x4 current,
            Float32x4 toAccumulate) =>
            current + ConvertFrom_float(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float64x4 operator +(
            Float32x4 toAccumulate,
            Float64x4 current) =>
            ConvertFrom_float(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float64x4 operator -(
            Float64x4 current,
            Float32x4 toAccumulate) =>
            current - ConvertFrom_float(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float64x4 operator -(
            Float32x4 toAccumulate,
            Float64x4 current) =>
            ConvertFrom_float(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(true)]
        public static void AtomicAdd(
            ref Float64x4 target,
            Float32x4 value) =>
            AtomicAdd(ref target, ConvertFrom_float(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float64x4 ConvertFrom_float(
            Float32x4 other) =>
            new Float64x4((double)other.X, (double)other.Y, (double)other.Z, (double)other.W);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float32x4 ConvertTo_float(
            Float64x4 current) =>
            new Float32x4((float)current.X, (float)current.Y, (float)current.Z, (float)current.W);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float64x4 IAccumulationVectorType<
            Float64x4,
            Float32x4,
            float>.ConvertFromBase(Float32x4 other) =>
            ConvertFrom_float(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float32x4 IAccumulationVectorType<
            Float64x4,
            Float32x4,
            float>.ConvertToBase(Float64x4 current) =>
            ConvertTo_float(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(true)]
        public Float64x4 ComputeAverage(float denominator) =>
            this / FromScalar((double)denominator);


        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float64x4 ConvertFrom_double(
            Float64x4 other) =>
            new Float64x4((double)other.X, (double)other.Y, (double)other.Z, (double)other.W);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float64x4 ConvertTo_double(
            Float64x4 current) =>
            new Float64x4((double)current.X, (double)current.Y, (double)current.Z, (double)current.W);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float64x4 IAccumulationVectorType<
            Float64x4,
            Float64x4,
            double>.ConvertFromBase(Float64x4 other) =>
            ConvertFrom_double(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float64x4 IAccumulationVectorType<
            Float64x4,
            Float64x4,
            double>.ConvertToBase(Float64x4 current) =>
            ConvertTo_double(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(true)]
        public Float64x4 ComputeAverage(double denominator) =>
            this / FromScalar((double)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float64x4 operator +(
            Float64x4 current,
            UInt8x4 toAccumulate) =>
            current + ConvertFrom_byte(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float64x4 operator +(
            UInt8x4 toAccumulate,
            Float64x4 current) =>
            ConvertFrom_byte(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float64x4 operator -(
            Float64x4 current,
            UInt8x4 toAccumulate) =>
            current - ConvertFrom_byte(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float64x4 operator -(
            UInt8x4 toAccumulate,
            Float64x4 current) =>
            ConvertFrom_byte(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref Float64x4 target,
            UInt8x4 value) =>
            AtomicAdd(ref target, ConvertFrom_byte(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float64x4 ConvertFrom_byte(
            UInt8x4 other) =>
            new Float64x4((double)other.X, (double)other.Y, (double)other.Z, (double)other.W);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt8x4 ConvertTo_byte(
            Float64x4 current) =>
            new UInt8x4((byte)current.X, (byte)current.Y, (byte)current.Z, (byte)current.W);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float64x4 IAccumulationVectorType<
            Float64x4,
            UInt8x4,
            byte>.ConvertFromBase(UInt8x4 other) =>
            ConvertFrom_byte(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt8x4 IAccumulationVectorType<
            Float64x4,
            UInt8x4,
            byte>.ConvertToBase(Float64x4 current) =>
            ConvertTo_byte(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public Float64x4 ComputeAverage(byte denominator) =>
            this / FromScalar((double)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float64x4 operator +(
            Float64x4 current,
            Int8x4 toAccumulate) =>
            current + ConvertFrom_sbyte(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float64x4 operator +(
            Int8x4 toAccumulate,
            Float64x4 current) =>
            ConvertFrom_sbyte(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float64x4 operator -(
            Float64x4 current,
            Int8x4 toAccumulate) =>
            current - ConvertFrom_sbyte(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float64x4 operator -(
            Int8x4 toAccumulate,
            Float64x4 current) =>
            ConvertFrom_sbyte(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref Float64x4 target,
            Int8x4 value) =>
            AtomicAdd(ref target, ConvertFrom_sbyte(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float64x4 ConvertFrom_sbyte(
            Int8x4 other) =>
            new Float64x4((double)other.X, (double)other.Y, (double)other.Z, (double)other.W);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int8x4 ConvertTo_sbyte(
            Float64x4 current) =>
            new Int8x4((sbyte)current.X, (sbyte)current.Y, (sbyte)current.Z, (sbyte)current.W);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float64x4 IAccumulationVectorType<
            Float64x4,
            Int8x4,
            sbyte>.ConvertFromBase(Int8x4 other) =>
            ConvertFrom_sbyte(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int8x4 IAccumulationVectorType<
            Float64x4,
            Int8x4,
            sbyte>.ConvertToBase(Float64x4 current) =>
            ConvertTo_sbyte(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public Float64x4 ComputeAverage(sbyte denominator) =>
            this / FromScalar((double)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float64x4 operator +(
            Float64x4 current,
            Int16x4 toAccumulate) =>
            current + ConvertFrom_short(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float64x4 operator +(
            Int16x4 toAccumulate,
            Float64x4 current) =>
            ConvertFrom_short(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float64x4 operator -(
            Float64x4 current,
            Int16x4 toAccumulate) =>
            current - ConvertFrom_short(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float64x4 operator -(
            Int16x4 toAccumulate,
            Float64x4 current) =>
            ConvertFrom_short(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(true)]
        public static void AtomicAdd(
            ref Float64x4 target,
            Int16x4 value) =>
            AtomicAdd(ref target, ConvertFrom_short(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float64x4 ConvertFrom_short(
            Int16x4 other) =>
            new Float64x4((double)other.X, (double)other.Y, (double)other.Z, (double)other.W);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int16x4 ConvertTo_short(
            Float64x4 current) =>
            new Int16x4((short)current.X, (short)current.Y, (short)current.Z, (short)current.W);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float64x4 IAccumulationVectorType<
            Float64x4,
            Int16x4,
            short>.ConvertFromBase(Int16x4 other) =>
            ConvertFrom_short(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int16x4 IAccumulationVectorType<
            Float64x4,
            Int16x4,
            short>.ConvertToBase(Float64x4 current) =>
            ConvertTo_short(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(true)]
        public Float64x4 ComputeAverage(short denominator) =>
            this / FromScalar((double)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float64x4 operator +(
            Float64x4 current,
            UInt16x4 toAccumulate) =>
            current + ConvertFrom_ushort(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float64x4 operator +(
            UInt16x4 toAccumulate,
            Float64x4 current) =>
            ConvertFrom_ushort(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float64x4 operator -(
            Float64x4 current,
            UInt16x4 toAccumulate) =>
            current - ConvertFrom_ushort(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float64x4 operator -(
            UInt16x4 toAccumulate,
            Float64x4 current) =>
            ConvertFrom_ushort(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref Float64x4 target,
            UInt16x4 value) =>
            AtomicAdd(ref target, ConvertFrom_ushort(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float64x4 ConvertFrom_ushort(
            UInt16x4 other) =>
            new Float64x4((double)other.X, (double)other.Y, (double)other.Z, (double)other.W);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt16x4 ConvertTo_ushort(
            Float64x4 current) =>
            new UInt16x4((ushort)current.X, (ushort)current.Y, (ushort)current.Z, (ushort)current.W);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float64x4 IAccumulationVectorType<
            Float64x4,
            UInt16x4,
            ushort>.ConvertFromBase(UInt16x4 other) =>
            ConvertFrom_ushort(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt16x4 IAccumulationVectorType<
            Float64x4,
            UInt16x4,
            ushort>.ConvertToBase(Float64x4 current) =>
            ConvertTo_ushort(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public Float64x4 ComputeAverage(ushort denominator) =>
            this / FromScalar((double)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float64x4 operator +(
            Float64x4 current,
            Int32x4 toAccumulate) =>
            current + ConvertFrom_int(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float64x4 operator +(
            Int32x4 toAccumulate,
            Float64x4 current) =>
            ConvertFrom_int(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float64x4 operator -(
            Float64x4 current,
            Int32x4 toAccumulate) =>
            current - ConvertFrom_int(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float64x4 operator -(
            Int32x4 toAccumulate,
            Float64x4 current) =>
            ConvertFrom_int(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(true)]
        public static void AtomicAdd(
            ref Float64x4 target,
            Int32x4 value) =>
            AtomicAdd(ref target, ConvertFrom_int(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float64x4 ConvertFrom_int(
            Int32x4 other) =>
            new Float64x4((double)other.X, (double)other.Y, (double)other.Z, (double)other.W);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int32x4 ConvertTo_int(
            Float64x4 current) =>
            new Int32x4((int)current.X, (int)current.Y, (int)current.Z, (int)current.W);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float64x4 IAccumulationVectorType<
            Float64x4,
            Int32x4,
            int>.ConvertFromBase(Int32x4 other) =>
            ConvertFrom_int(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int32x4 IAccumulationVectorType<
            Float64x4,
            Int32x4,
            int>.ConvertToBase(Float64x4 current) =>
            ConvertTo_int(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(true)]
        public Float64x4 ComputeAverage(int denominator) =>
            this / FromScalar((double)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float64x4 operator +(
            Float64x4 current,
            UInt32x4 toAccumulate) =>
            current + ConvertFrom_uint(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float64x4 operator +(
            UInt32x4 toAccumulate,
            Float64x4 current) =>
            ConvertFrom_uint(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float64x4 operator -(
            Float64x4 current,
            UInt32x4 toAccumulate) =>
            current - ConvertFrom_uint(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float64x4 operator -(
            UInt32x4 toAccumulate,
            Float64x4 current) =>
            ConvertFrom_uint(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref Float64x4 target,
            UInt32x4 value) =>
            AtomicAdd(ref target, ConvertFrom_uint(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float64x4 ConvertFrom_uint(
            UInt32x4 other) =>
            new Float64x4((double)other.X, (double)other.Y, (double)other.Z, (double)other.W);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt32x4 ConvertTo_uint(
            Float64x4 current) =>
            new UInt32x4((uint)current.X, (uint)current.Y, (uint)current.Z, (uint)current.W);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float64x4 IAccumulationVectorType<
            Float64x4,
            UInt32x4,
            uint>.ConvertFromBase(UInt32x4 other) =>
            ConvertFrom_uint(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt32x4 IAccumulationVectorType<
            Float64x4,
            UInt32x4,
            uint>.ConvertToBase(Float64x4 current) =>
            ConvertTo_uint(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public Float64x4 ComputeAverage(uint denominator) =>
            this / FromScalar((double)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float64x4 operator +(
            Float64x4 current,
            Int64x4 toAccumulate) =>
            current + ConvertFrom_long(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float64x4 operator +(
            Int64x4 toAccumulate,
            Float64x4 current) =>
            ConvertFrom_long(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float64x4 operator -(
            Float64x4 current,
            Int64x4 toAccumulate) =>
            current - ConvertFrom_long(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float64x4 operator -(
            Int64x4 toAccumulate,
            Float64x4 current) =>
            ConvertFrom_long(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(true)]
        public static void AtomicAdd(
            ref Float64x4 target,
            Int64x4 value) =>
            AtomicAdd(ref target, ConvertFrom_long(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float64x4 ConvertFrom_long(
            Int64x4 other) =>
            new Float64x4((double)other.X, (double)other.Y, (double)other.Z, (double)other.W);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int64x4 ConvertTo_long(
            Float64x4 current) =>
            new Int64x4((long)current.X, (long)current.Y, (long)current.Z, (long)current.W);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float64x4 IAccumulationVectorType<
            Float64x4,
            Int64x4,
            long>.ConvertFromBase(Int64x4 other) =>
            ConvertFrom_long(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int64x4 IAccumulationVectorType<
            Float64x4,
            Int64x4,
            long>.ConvertToBase(Float64x4 current) =>
            ConvertTo_long(current);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float64x4 operator +(
            Float64x4 current,
            UInt64x4 toAccumulate) =>
            current + ConvertFrom_ulong(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float64x4 operator +(
            UInt64x4 toAccumulate,
            Float64x4 current) =>
            ConvertFrom_ulong(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float64x4 operator -(
            Float64x4 current,
            UInt64x4 toAccumulate) =>
            current - ConvertFrom_ulong(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float64x4 operator -(
            UInt64x4 toAccumulate,
            Float64x4 current) =>
            ConvertFrom_ulong(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref Float64x4 target,
            UInt64x4 value) =>
            AtomicAdd(ref target, ConvertFrom_ulong(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float64x4 ConvertFrom_ulong(
            UInt64x4 other) =>
            new Float64x4((double)other.X, (double)other.Y, (double)other.Z, (double)other.W);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt64x4 ConvertTo_ulong(
            Float64x4 current) =>
            new UInt64x4((ulong)current.X, (ulong)current.Y, (ulong)current.Z, (ulong)current.W);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float64x4 IAccumulationVectorType<
            Float64x4,
            UInt64x4,
            ulong>.ConvertFromBase(UInt64x4 other) =>
            ConvertFrom_ulong(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt64x4 IAccumulationVectorType<
            Float64x4,
            UInt64x4,
            ulong>.ConvertToBase(Float64x4 current) =>
            ConvertTo_ulong(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public Float64x4 ComputeAverage(ulong denominator) =>
            this / FromScalar((double)denominator);

        /// <summary>
        /// Converts this instance into an unsafe span instance.
        /// </summary>
        /// <returns>The readonly span instance.</returns>
        public unsafe ReadOnlySpan<double> AsSpan() =>
            new(Unsafe.AsPointer(ref Unsafe.AsRef(this)), 4);

        /// <summary>
        /// Iterates over all elements by applying the given iterator to each element.
        /// </summary>
        /// <typeparam name="TIterator">The managed iterator type.</typeparam>
        /// <param name="iterator">The iterator to invoke.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ForEach<TIterator>(ref TIterator iterator)
            where TIterator : struct, IVectorElementIterator<
            Float64x4,
            double>
        {
            iterator.Iterate(X, 0);
            iterator.Iterate(Y, 1);
            iterator.Iterate(Z, 2);
            iterator.Iterate(W, 3);
        }

        /// <summary>
        /// Converts this vector instance to a string.
        /// </summary>
        public override string ToString() =>
            $"{X}, {Y}, {Z}, {W}";

        /// <summary>
        /// Converts this vector instance to a string.
        /// </summary>
        public string ToString(string? format, IFormatProvider? formatProvider) =>
            $"{X.ToString(format, formatProvider)}, {Y.ToString(format, formatProvider)}, {Z.ToString(format, formatProvider)}, {W.ToString(format, formatProvider)}";

        /// <summary>
        /// Returns true.
        /// </summary>
        public static bool IsCanonical(Float64x4 value) => true;

        /// <summary>
        /// Returns false.
        /// </summary>
        public static bool IsComplexNumber(Float64x4 value) => false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsEvenInteger(Float64x4 value) =>
            double.IsEvenInteger(value.X) & double.IsEvenInteger(value.Y) & double.IsEvenInteger(value.Z) & double.IsEvenInteger(value.W);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsFinite(Float64x4 value) =>
            double.IsFinite(value.X) & double.IsFinite(value.Y) & double.IsFinite(value.Z) & double.IsFinite(value.W);

        /// <summary>
        /// Returns false.
        /// </summary>
        public static bool IsImaginaryNumber(Float64x4 value) => false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsInfinity(Float64x4 value) =>
            double.IsInfinity(value.X) | double.IsInfinity(value.Y) | double.IsInfinity(value.Z) | double.IsInfinity(value.W);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsInteger(Float64x4 value) =>
            double.IsInteger(value.X) & double.IsInteger(value.Y) & double.IsInteger(value.Z) & double.IsInteger(value.W);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNaN(Float64x4 value) =>
            double.IsNaN(value.X) | double.IsNaN(value.Y) | double.IsNaN(value.Z) | double.IsNaN(value.W);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNegative(Float64x4 value) =>
            double.IsNegative(value.X) & double.IsNegative(value.Y) & double.IsNegative(value.Z) & double.IsNegative(value.W);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNegativeInfinity(Float64x4 value) =>
            double.IsNegativeInfinity(value.X) | double.IsNegativeInfinity(value.Y) | double.IsNegativeInfinity(value.Z) | double.IsNegativeInfinity(value.W);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNormal(Float64x4 value) =>
            double.IsNormal(value.X) & double.IsNormal(value.Y) & double.IsNormal(value.Z) & double.IsNormal(value.W);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsOddInteger(Float64x4 value) =>
            double.IsOddInteger(value.X) & double.IsOddInteger(value.Y) & double.IsOddInteger(value.Z) & double.IsOddInteger(value.W);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsPositive(Float64x4 value) =>
            double.IsPositive(value.X) & double.IsPositive(value.Y) & double.IsPositive(value.Z) & double.IsPositive(value.W);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsPositiveInfinity(Float64x4 value) =>
            double.IsPositiveInfinity(value.X) | double.IsPositiveInfinity(value.Y) | double.IsPositiveInfinity(value.Z) | double.IsPositiveInfinity(value.W);

        /// <summary>
        /// Returns true.
        /// </summary>
        public static bool IsRealNumber(Float64x4 value) => true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsSubnormal(Float64x4 value) =>
            double.IsSubnormal(value.X) & double.IsSubnormal(value.Y) & double.IsSubnormal(value.Z) & double.IsSubnormal(value.W);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsZero(Float64x4 value) =>
            Abs(value) == Zero;

        /// <summary>
        /// Returns the absolute value.
        /// </summary>
        public static Float64x4 Abs(Float64x4 value) =>
            new Float64x4(Math.Abs(value.X), Math.Abs(value.Y), Math.Abs(value.Z), Math.Abs(value.W));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Float64x4 operator +(Float64x4 left, Float64x4 right) =>
            new Float64x4((double)(left.X + right.X), (double)(left.Y + right.Y), (double)(left.Z + right.Z), (double)(left.W + right.W));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Float64x4 operator --(Float64x4 value) => value - One;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Float64x4 operator /(Float64x4 left, Float64x4 right) =>
            new Float64x4((double)(left.X / right.X), (double)(left.Y / right.Y), (double)(left.Z / right.Z), (double)(left.W / right.W));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Float64x4 operator ++(Float64x4 value) => value + One;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Float64x4 operator *(Float64x4 left, Float64x4 right) =>
            new Float64x4((double)(left.X * right.X), (double)(left.Y * right.Y), (double)(left.Z * right.Z), (double)(left.W * right.W));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Float64x4 operator -(Float64x4 left, Float64x4 right) =>
            new Float64x4((double)(left.X - right.X), (double)(left.Y - right.Y), (double)(left.Z - right.Z), (double)(left.W - right.W));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Float64x4 operator -(Float64x4 value) =>
            new Float64x4((double)-value.X, (double)-value.Y, (double)-value.Z, (double)-value.W);

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Float64x4 operator +(Float64x4 value) => value;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Float64x4 MaxMagnitude(Float64x4 x, Float64x4 y) =>
            new Float64x4(double.MaxMagnitude(x.X, y.X), double.MaxMagnitude(x.Y, y.Y), double.MaxMagnitude(x.Z, y.Z), double.MaxMagnitude(x.W, y.W));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Float64x4 MaxMagnitudeNumber(Float64x4 x, Float64x4 y) =>
            new Float64x4(double.MaxMagnitudeNumber(x.X, y.X), double.MaxMagnitudeNumber(x.Y, y.Y), double.MaxMagnitudeNumber(x.Z, y.Z), double.MaxMagnitudeNumber(x.W, y.W));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Float64x4 MinMagnitude(Float64x4 x, Float64x4 y) =>
            new Float64x4(double.MinMagnitude(x.X, y.X), double.MinMagnitude(x.Y, y.Y), double.MinMagnitude(x.Z, y.Z), double.MinMagnitude(x.W, y.W));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Float64x4 MinMagnitudeNumber(Float64x4 x, Float64x4 y) =>
            new Float64x4(double.MinMagnitudeNumber(x.X, y.X), double.MinMagnitudeNumber(x.Y, y.Y), double.MinMagnitudeNumber(x.Z, y.Z), double.MinMagnitudeNumber(x.W, y.W));

        // Not supported operations

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static Float64x4 IParsable<Float64x4>.Parse(
            string s,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static Float64x4 ISpanParsable<Float64x4>.Parse(
            ReadOnlySpan<char> s,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static Float64x4 INumberBase<Float64x4>.Parse(
            ReadOnlySpan<char> s,
            NumberStyles style,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static Float64x4 INumberBase<Float64x4>.Parse(
            string s,
            NumberStyles style,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        bool ISpanFormattable.TryFormat(
            Span<char> destination,
            out int charsWritten,
            ReadOnlySpan<char> format,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool IParsable<Float64x4>.TryParse(
            string? s,
            IFormatProvider? provider,
            out Float64x4 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given span into a vectorized instance.
        /// </summary>
        static bool ISpanParsable<Float64x4>.TryParse(
            ReadOnlySpan<char> s,
            IFormatProvider? provider,
            out Float64x4 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool INumberBase<Float64x4>.TryParse(
            ReadOnlySpan<char> s,
            NumberStyles style,
            IFormatProvider? provider,
            out Float64x4 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool INumberBase<Float64x4>.TryParse(
            string? s,
            NumberStyles style,
            IFormatProvider? provider,
            out Float64x4 result) =>
            throw new NotSupportedException();

        static bool INumberBase<Float64x4>.TryConvertFromChecked<TOther>(
            TOther value,
            out Float64x4 result) =>
            throw new NotSupportedException();
        static bool INumberBase<Float64x4>.TryConvertFromSaturating<TOther>(
            TOther value,
            out Float64x4 result) =>
            throw new NotSupportedException();
        static bool INumberBase<Float64x4>.TryConvertFromTruncating<TOther>(
            TOther value,
            out Float64x4 result) =>
            throw new NotSupportedException();
        static bool INumberBase<Float64x4>.TryConvertToChecked<TOther>(
            Float64x4 value,
            out TOther result) =>
            throw new NotSupportedException();
        static bool INumberBase<Float64x4>.TryConvertToSaturating<TOther>(
            Float64x4 value,
            out TOther result) =>
            throw new NotSupportedException();
        static bool INumberBase<Float64x4>.TryConvertToTruncating<TOther>(
            Float64x4 value,
            out TOther result) =>
            throw new NotSupportedException();
    }

    /// <summary>
    /// Represents a vectorized double type with length 8.
    /// </summary>
    public readonly record struct Float64x8(
        double X, double Y, double Z, double W, double I, double J, double K, double L) :
        IVectorType<Float64x8, double>
        , IAccumulationVectorType<
            Float64x8,
            Float32x8,
            float>
        , IAccumulationVectorType<
            Float64x8,
            Float64x8,
            double>
        , IAccumulationVectorType<
            Float64x8,
            UInt8x8,
            byte>
        , IAccumulationVectorType<
            Float64x8,
            Int8x8,
            sbyte>
        , IAccumulationVectorType<
            Float64x8,
            Int16x8,
            short>
        , IAccumulationVectorType<
            Float64x8,
            UInt16x8,
            ushort>
        , IAccumulationVectorType<
            Float64x8,
            Int32x8,
            int>
        , IAccumulationVectorType<
            Float64x8,
            UInt32x8,
            uint>
        , IAccumulationVectorType<
            Float64x8,
            Int64x8,
            long>
        , IAccumulationVectorType<
            Float64x8,
            UInt64x8,
            ulong>
    {
        /// <summary>
        /// The offset of the X field in bytes.
        /// </summary>
        public static readonly int OffsetX =
            sizeof(double) * 0;

        /// <summary>
        /// The offset of the X field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrX =>
            new UIntPtr((uint)OffsetX);
        /// <summary>
        /// The offset of the Y field in bytes.
        /// </summary>
        public static readonly int OffsetY =
            sizeof(double) * 1;

        /// <summary>
        /// The offset of the Y field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrY =>
            new UIntPtr((uint)OffsetY);
        /// <summary>
        /// The offset of the Z field in bytes.
        /// </summary>
        public static readonly int OffsetZ =
            sizeof(double) * 2;

        /// <summary>
        /// The offset of the Z field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrZ =>
            new UIntPtr((uint)OffsetZ);
        /// <summary>
        /// The offset of the W field in bytes.
        /// </summary>
        public static readonly int OffsetW =
            sizeof(double) * 3;

        /// <summary>
        /// The offset of the W field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrW =>
            new UIntPtr((uint)OffsetW);
        /// <summary>
        /// The offset of the I field in bytes.
        /// </summary>
        public static readonly int OffsetI =
            sizeof(double) * 4;

        /// <summary>
        /// The offset of the I field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrI =>
            new UIntPtr((uint)OffsetI);
        /// <summary>
        /// The offset of the J field in bytes.
        /// </summary>
        public static readonly int OffsetJ =
            sizeof(double) * 5;

        /// <summary>
        /// The offset of the J field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrJ =>
            new UIntPtr((uint)OffsetJ);
        /// <summary>
        /// The offset of the K field in bytes.
        /// </summary>
        public static readonly int OffsetK =
            sizeof(double) * 6;

        /// <summary>
        /// The offset of the K field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrK =>
            new UIntPtr((uint)OffsetK);
        /// <summary>
        /// The offset of the L field in bytes.
        /// </summary>
        public static readonly int OffsetL =
            sizeof(double) * 7;

        /// <summary>
        /// The offset of the L field in bytes.
        /// </summary>
        [CLSCompliant(false)]
        public static UIntPtr OffsetPtrL =>
            new UIntPtr((uint)OffsetL);

        /// <summary>
        /// Returns the length of this vector which is 8.
        /// </summary>
        public static int Length => 8;

        /// <summary>
        /// Returns the radix of the underlying value.
        /// </summary>
        public static int Radix => 10;

        /// <summary>
        /// Returns an invalid value (min [signed types], max value [unsigned] or NaN).
        /// </summary>
        public static Float64x8 Invalid => FromScalar(
            double.NaN
        );

        /// <summary>
        /// Returns the value zero.
        /// </summary>
        public static Float64x8 Zero => new();

        /// <summary>
        /// Returns the value one.
        /// </summary>
        public static Float64x8 One => FromScalar((1));

        /// <summary>
        /// Returns the value zero.
        /// </summary>
        public static Float64x8 AdditiveIdentity => Zero;

        /// <summary>
        /// Returns the value one.
        /// </summary>
        public static Float64x8 MultiplicativeIdentity => One;

        /// <summary>
        /// Computes the min value of both.
        /// </summary>
        /// <param name="first">The first value.</param>
        /// <param name="second">The second value.</param>
        /// <returns>The min value.</returns>
        public static Float64x8 Min(
            Float64x8 first,
            Float64x8 second) =>
            new Float64x8((double)Math.Min(first.X, second.X), (double)Math.Min(first.Y, second.Y), (double)Math.Min(first.Z, second.Z), (double)Math.Min(first.W, second.W), (double)Math.Min(first.I, second.I), (double)Math.Min(first.J, second.J), (double)Math.Min(first.K, second.K), (double)Math.Min(first.L, second.L));

        /// <summary>
        /// Computes the max value of both.
        /// </summary>
        /// <param name="first">The first value.</param>
        /// <param name="second">The second value.</param>
        /// <returns>The max value.</returns>
        public static Float64x8 Max(
            Float64x8 first,
            Float64x8 second) =>
            new Float64x8((double)Math.Max(first.X, second.X), (double)Math.Max(first.Y, second.Y), (double)Math.Max(first.Z, second.Z), (double)Math.Max(first.W, second.W), (double)Math.Max(first.I, second.I), (double)Math.Max(first.J, second.J), (double)Math.Max(first.K, second.K), (double)Math.Max(first.L, second.L));

        /// <summary>
        /// Clamps the given value.
        /// </summary>
        /// <param name="value">The value to clamp.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The clamped value.</returns>
        public static Float64x8 Clamp(
            Float64x8 value,
            Float64x8 min,
            Float64x8 max) =>
            Max(Min(value, max), min);

        /// <summary>
        /// Creates a random scalar instance falling into the range of min max.
        /// </summary>
        /// <param name="random">The random provider to use.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The created random scalar instance.</returns>
        public static double GetRandomScalar<TRandom>(
            ref TRandom random,
            double min,
            double max)
            where TRandom : struct, IRandomProvider =>
            (double)RandomExtensions.
                Next(ref random, min, max);

        /// <summary>
        /// Creates a random vector instance falling into the range of min max.
        /// </summary>
        /// <param name="random">The random provider to use.</param>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <returns>The created random vector instance.</returns>
        public static Float64x8 GetRandom<TRandom>(
            ref TRandom random,
            Float64x8 min,
            Float64x8 max)
            where TRandom : struct, IRandomProvider
        {
            double x = GetRandomScalar(
                ref random, min.X, max.X);
            double y = GetRandomScalar(
                ref random, min.Y, max.Y);
            double z = GetRandomScalar(
                ref random, min.Z, max.Z);
            double w = GetRandomScalar(
                ref random, min.W, max.W);
            double i = GetRandomScalar(
                ref random, min.I, max.I);
            double j = GetRandomScalar(
                ref random, min.J, max.J);
            double k = GetRandomScalar(
                ref random, min.K, max.K);
            double l = GetRandomScalar(
                ref random, min.L, max.L);
            return new Float64x8(x, y, z, w, i, j, k, l);
        }

        /// <summary>
        /// Creates a vector instance from the given source view.
        /// </summary>
        /// <typeparam name="TStride">The custom stride type.</typeparam>
        /// <param name="sourceView">The source view.</param>
        /// <param name="index">The source base index.</param>
        /// <returns>The vector instance.</returns>
        public static Float64x8 FromElementView<TStride>(
            ArrayView1D<double, TStride> sourceView,
            Index1D index)
            where TStride : struct, IStride1D =>
            new Float64x8(
                sourceView[index + 0],
                sourceView[index + 1],
                sourceView[index + 2],
                sourceView[index + 3],
                sourceView[index + 4],
                sourceView[index + 5],
                sourceView[index + 6],
                sourceView[index + 7]
                );

        /// <summary>
        /// Serializes the current vector instance into the given target view.
        /// </summary>
        /// <typeparam name="TStride">The custom stride type.</typeparam>
        /// <param name="targetView">The target view.</param>
        /// <param name="index">The target base index.</param>
        public void ToElementView<TStride>(
            ArrayView1D<double, TStride> targetView,
            Index1D index)
            where TStride : struct, IStride1D
        {
            targetView[index + 0] = X;
            targetView[index + 1] = Y;
            targetView[index + 2] = Z;
            targetView[index + 3] = W;
            targetView[index + 4] = I;
            targetView[index + 5] = J;
            targetView[index + 6] = K;
            targetView[index + 7] = L;
        }

        /// <summary>
        /// Creates a vector instance from the given source view.
        /// </summary>
        /// <param name="sourceView">The source view.</param>
        /// <param name="index">The source base index.</param>
        /// <returns>The vector instance.</returns>
        public static Float64x8 FromElementView(
            SingleVectorView<double> sourceView,
            Index1D index) =>
            new Float64x8(
                sourceView[index + 0],
                sourceView[index + 1],
                sourceView[index + 2],
                sourceView[index + 3],
                sourceView[index + 4],
                sourceView[index + 5],
                sourceView[index + 6],
                sourceView[index + 7]
                );

        /// <summary>
        /// Serializes the current vector instance into the given target view.
        /// </summary>
        /// <param name="targetView">The target view.</param>
        /// <param name="index">The target base index.</param>
        public void ToElementView(
            SingleVectorView<double> targetView,
            Index1D index)
        {
            targetView[index + 0] = X;
            targetView[index + 1] = Y;
            targetView[index + 2] = Z;
            targetView[index + 3] = W;
            targetView[index + 4] = I;
            targetView[index + 5] = J;
            targetView[index + 6] = K;
            targetView[index + 7] = L;
        }

        /// <summary>
        /// Converts a scalar value into the current vectorized type.
        /// </summary>
        /// <param name="scalar">The scalar element type.</param>
        /// <returns>The created vectorized type.</returns>
        public static Float64x8 FromScalar(double scalar) =>
            new Float64x8(scalar, scalar, scalar, scalar, scalar, scalar, scalar, scalar);

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        public static void AtomicAdd(ref Float64x8 target, Float64x8 value)
        {
            ref var elementRef = ref Unsafe.As<Float64x8, double>(
                ref target);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrX),
                value.X);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrY),
                value.Y);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrZ),
                value.Z);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrW),
                value.W);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrI),
                value.I);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrJ),
                value.J);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrK),
                value.K);
            Atomic.Add(
                ref Unsafe.AddByteOffset(
                    ref elementRef,
                    OffsetPtrL),
                value.L);
        }

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        public Float64x8 ComputeAverage(long denominator) =>
            this / FromScalar((double)denominator);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float64x8 operator +(
            Float64x8 current,
            Float32x8 toAccumulate) =>
            current + ConvertFrom_float(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float64x8 operator +(
            Float32x8 toAccumulate,
            Float64x8 current) =>
            ConvertFrom_float(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float64x8 operator -(
            Float64x8 current,
            Float32x8 toAccumulate) =>
            current - ConvertFrom_float(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float64x8 operator -(
            Float32x8 toAccumulate,
            Float64x8 current) =>
            ConvertFrom_float(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(true)]
        public static void AtomicAdd(
            ref Float64x8 target,
            Float32x8 value) =>
            AtomicAdd(ref target, ConvertFrom_float(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float64x8 ConvertFrom_float(
            Float32x8 other) =>
            new Float64x8((double)other.X, (double)other.Y, (double)other.Z, (double)other.W, (double)other.I, (double)other.J, (double)other.K, (double)other.L);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float32x8 ConvertTo_float(
            Float64x8 current) =>
            new Float32x8((float)current.X, (float)current.Y, (float)current.Z, (float)current.W, (float)current.I, (float)current.J, (float)current.K, (float)current.L);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float64x8 IAccumulationVectorType<
            Float64x8,
            Float32x8,
            float>.ConvertFromBase(Float32x8 other) =>
            ConvertFrom_float(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float32x8 IAccumulationVectorType<
            Float64x8,
            Float32x8,
            float>.ConvertToBase(Float64x8 current) =>
            ConvertTo_float(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(true)]
        public Float64x8 ComputeAverage(float denominator) =>
            this / FromScalar((double)denominator);


        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float64x8 ConvertFrom_double(
            Float64x8 other) =>
            new Float64x8((double)other.X, (double)other.Y, (double)other.Z, (double)other.W, (double)other.I, (double)other.J, (double)other.K, (double)other.L);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float64x8 ConvertTo_double(
            Float64x8 current) =>
            new Float64x8((double)current.X, (double)current.Y, (double)current.Z, (double)current.W, (double)current.I, (double)current.J, (double)current.K, (double)current.L);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float64x8 IAccumulationVectorType<
            Float64x8,
            Float64x8,
            double>.ConvertFromBase(Float64x8 other) =>
            ConvertFrom_double(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float64x8 IAccumulationVectorType<
            Float64x8,
            Float64x8,
            double>.ConvertToBase(Float64x8 current) =>
            ConvertTo_double(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(true)]
        public Float64x8 ComputeAverage(double denominator) =>
            this / FromScalar((double)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float64x8 operator +(
            Float64x8 current,
            UInt8x8 toAccumulate) =>
            current + ConvertFrom_byte(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float64x8 operator +(
            UInt8x8 toAccumulate,
            Float64x8 current) =>
            ConvertFrom_byte(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float64x8 operator -(
            Float64x8 current,
            UInt8x8 toAccumulate) =>
            current - ConvertFrom_byte(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float64x8 operator -(
            UInt8x8 toAccumulate,
            Float64x8 current) =>
            ConvertFrom_byte(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref Float64x8 target,
            UInt8x8 value) =>
            AtomicAdd(ref target, ConvertFrom_byte(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float64x8 ConvertFrom_byte(
            UInt8x8 other) =>
            new Float64x8((double)other.X, (double)other.Y, (double)other.Z, (double)other.W, (double)other.I, (double)other.J, (double)other.K, (double)other.L);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt8x8 ConvertTo_byte(
            Float64x8 current) =>
            new UInt8x8((byte)current.X, (byte)current.Y, (byte)current.Z, (byte)current.W, (byte)current.I, (byte)current.J, (byte)current.K, (byte)current.L);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float64x8 IAccumulationVectorType<
            Float64x8,
            UInt8x8,
            byte>.ConvertFromBase(UInt8x8 other) =>
            ConvertFrom_byte(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt8x8 IAccumulationVectorType<
            Float64x8,
            UInt8x8,
            byte>.ConvertToBase(Float64x8 current) =>
            ConvertTo_byte(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public Float64x8 ComputeAverage(byte denominator) =>
            this / FromScalar((double)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float64x8 operator +(
            Float64x8 current,
            Int8x8 toAccumulate) =>
            current + ConvertFrom_sbyte(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float64x8 operator +(
            Int8x8 toAccumulate,
            Float64x8 current) =>
            ConvertFrom_sbyte(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float64x8 operator -(
            Float64x8 current,
            Int8x8 toAccumulate) =>
            current - ConvertFrom_sbyte(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float64x8 operator -(
            Int8x8 toAccumulate,
            Float64x8 current) =>
            ConvertFrom_sbyte(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref Float64x8 target,
            Int8x8 value) =>
            AtomicAdd(ref target, ConvertFrom_sbyte(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float64x8 ConvertFrom_sbyte(
            Int8x8 other) =>
            new Float64x8((double)other.X, (double)other.Y, (double)other.Z, (double)other.W, (double)other.I, (double)other.J, (double)other.K, (double)other.L);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int8x8 ConvertTo_sbyte(
            Float64x8 current) =>
            new Int8x8((sbyte)current.X, (sbyte)current.Y, (sbyte)current.Z, (sbyte)current.W, (sbyte)current.I, (sbyte)current.J, (sbyte)current.K, (sbyte)current.L);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float64x8 IAccumulationVectorType<
            Float64x8,
            Int8x8,
            sbyte>.ConvertFromBase(Int8x8 other) =>
            ConvertFrom_sbyte(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int8x8 IAccumulationVectorType<
            Float64x8,
            Int8x8,
            sbyte>.ConvertToBase(Float64x8 current) =>
            ConvertTo_sbyte(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public Float64x8 ComputeAverage(sbyte denominator) =>
            this / FromScalar((double)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float64x8 operator +(
            Float64x8 current,
            Int16x8 toAccumulate) =>
            current + ConvertFrom_short(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float64x8 operator +(
            Int16x8 toAccumulate,
            Float64x8 current) =>
            ConvertFrom_short(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float64x8 operator -(
            Float64x8 current,
            Int16x8 toAccumulate) =>
            current - ConvertFrom_short(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float64x8 operator -(
            Int16x8 toAccumulate,
            Float64x8 current) =>
            ConvertFrom_short(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(true)]
        public static void AtomicAdd(
            ref Float64x8 target,
            Int16x8 value) =>
            AtomicAdd(ref target, ConvertFrom_short(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float64x8 ConvertFrom_short(
            Int16x8 other) =>
            new Float64x8((double)other.X, (double)other.Y, (double)other.Z, (double)other.W, (double)other.I, (double)other.J, (double)other.K, (double)other.L);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int16x8 ConvertTo_short(
            Float64x8 current) =>
            new Int16x8((short)current.X, (short)current.Y, (short)current.Z, (short)current.W, (short)current.I, (short)current.J, (short)current.K, (short)current.L);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float64x8 IAccumulationVectorType<
            Float64x8,
            Int16x8,
            short>.ConvertFromBase(Int16x8 other) =>
            ConvertFrom_short(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int16x8 IAccumulationVectorType<
            Float64x8,
            Int16x8,
            short>.ConvertToBase(Float64x8 current) =>
            ConvertTo_short(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(true)]
        public Float64x8 ComputeAverage(short denominator) =>
            this / FromScalar((double)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float64x8 operator +(
            Float64x8 current,
            UInt16x8 toAccumulate) =>
            current + ConvertFrom_ushort(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float64x8 operator +(
            UInt16x8 toAccumulate,
            Float64x8 current) =>
            ConvertFrom_ushort(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float64x8 operator -(
            Float64x8 current,
            UInt16x8 toAccumulate) =>
            current - ConvertFrom_ushort(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float64x8 operator -(
            UInt16x8 toAccumulate,
            Float64x8 current) =>
            ConvertFrom_ushort(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref Float64x8 target,
            UInt16x8 value) =>
            AtomicAdd(ref target, ConvertFrom_ushort(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float64x8 ConvertFrom_ushort(
            UInt16x8 other) =>
            new Float64x8((double)other.X, (double)other.Y, (double)other.Z, (double)other.W, (double)other.I, (double)other.J, (double)other.K, (double)other.L);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt16x8 ConvertTo_ushort(
            Float64x8 current) =>
            new UInt16x8((ushort)current.X, (ushort)current.Y, (ushort)current.Z, (ushort)current.W, (ushort)current.I, (ushort)current.J, (ushort)current.K, (ushort)current.L);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float64x8 IAccumulationVectorType<
            Float64x8,
            UInt16x8,
            ushort>.ConvertFromBase(UInt16x8 other) =>
            ConvertFrom_ushort(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt16x8 IAccumulationVectorType<
            Float64x8,
            UInt16x8,
            ushort>.ConvertToBase(Float64x8 current) =>
            ConvertTo_ushort(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public Float64x8 ComputeAverage(ushort denominator) =>
            this / FromScalar((double)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float64x8 operator +(
            Float64x8 current,
            Int32x8 toAccumulate) =>
            current + ConvertFrom_int(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float64x8 operator +(
            Int32x8 toAccumulate,
            Float64x8 current) =>
            ConvertFrom_int(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float64x8 operator -(
            Float64x8 current,
            Int32x8 toAccumulate) =>
            current - ConvertFrom_int(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float64x8 operator -(
            Int32x8 toAccumulate,
            Float64x8 current) =>
            ConvertFrom_int(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(true)]
        public static void AtomicAdd(
            ref Float64x8 target,
            Int32x8 value) =>
            AtomicAdd(ref target, ConvertFrom_int(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float64x8 ConvertFrom_int(
            Int32x8 other) =>
            new Float64x8((double)other.X, (double)other.Y, (double)other.Z, (double)other.W, (double)other.I, (double)other.J, (double)other.K, (double)other.L);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int32x8 ConvertTo_int(
            Float64x8 current) =>
            new Int32x8((int)current.X, (int)current.Y, (int)current.Z, (int)current.W, (int)current.I, (int)current.J, (int)current.K, (int)current.L);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float64x8 IAccumulationVectorType<
            Float64x8,
            Int32x8,
            int>.ConvertFromBase(Int32x8 other) =>
            ConvertFrom_int(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int32x8 IAccumulationVectorType<
            Float64x8,
            Int32x8,
            int>.ConvertToBase(Float64x8 current) =>
            ConvertTo_int(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(true)]
        public Float64x8 ComputeAverage(int denominator) =>
            this / FromScalar((double)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float64x8 operator +(
            Float64x8 current,
            UInt32x8 toAccumulate) =>
            current + ConvertFrom_uint(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float64x8 operator +(
            UInt32x8 toAccumulate,
            Float64x8 current) =>
            ConvertFrom_uint(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float64x8 operator -(
            Float64x8 current,
            UInt32x8 toAccumulate) =>
            current - ConvertFrom_uint(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float64x8 operator -(
            UInt32x8 toAccumulate,
            Float64x8 current) =>
            ConvertFrom_uint(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref Float64x8 target,
            UInt32x8 value) =>
            AtomicAdd(ref target, ConvertFrom_uint(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float64x8 ConvertFrom_uint(
            UInt32x8 other) =>
            new Float64x8((double)other.X, (double)other.Y, (double)other.Z, (double)other.W, (double)other.I, (double)other.J, (double)other.K, (double)other.L);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt32x8 ConvertTo_uint(
            Float64x8 current) =>
            new UInt32x8((uint)current.X, (uint)current.Y, (uint)current.Z, (uint)current.W, (uint)current.I, (uint)current.J, (uint)current.K, (uint)current.L);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float64x8 IAccumulationVectorType<
            Float64x8,
            UInt32x8,
            uint>.ConvertFromBase(UInt32x8 other) =>
            ConvertFrom_uint(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt32x8 IAccumulationVectorType<
            Float64x8,
            UInt32x8,
            uint>.ConvertToBase(Float64x8 current) =>
            ConvertTo_uint(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public Float64x8 ComputeAverage(uint denominator) =>
            this / FromScalar((double)denominator);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float64x8 operator +(
            Float64x8 current,
            Int64x8 toAccumulate) =>
            current + ConvertFrom_long(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float64x8 operator +(
            Int64x8 toAccumulate,
            Float64x8 current) =>
            ConvertFrom_long(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float64x8 operator -(
            Float64x8 current,
            Int64x8 toAccumulate) =>
            current - ConvertFrom_long(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(true)]
        public static Float64x8 operator -(
            Int64x8 toAccumulate,
            Float64x8 current) =>
            ConvertFrom_long(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(true)]
        public static void AtomicAdd(
            ref Float64x8 target,
            Int64x8 value) =>
            AtomicAdd(ref target, ConvertFrom_long(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float64x8 ConvertFrom_long(
            Int64x8 other) =>
            new Float64x8((double)other.X, (double)other.Y, (double)other.Z, (double)other.W, (double)other.I, (double)other.J, (double)other.K, (double)other.L);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Int64x8 ConvertTo_long(
            Float64x8 current) =>
            new Int64x8((long)current.X, (long)current.Y, (long)current.Z, (long)current.W, (long)current.I, (long)current.J, (long)current.K, (long)current.L);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float64x8 IAccumulationVectorType<
            Float64x8,
            Int64x8,
            long>.ConvertFromBase(Int64x8 other) =>
            ConvertFrom_long(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Int64x8 IAccumulationVectorType<
            Float64x8,
            Int64x8,
            long>.ConvertToBase(Float64x8 current) =>
            ConvertTo_long(current);

        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float64x8 operator +(
            Float64x8 current,
            UInt64x8 toAccumulate) =>
            current + ConvertFrom_ulong(toAccumulate);
        
        /// <summary>
        /// Adds an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to add.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float64x8 operator +(
            UInt64x8 toAccumulate,
            Float64x8 current) =>
            ConvertFrom_ulong(toAccumulate) + current;
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float64x8 operator -(
            Float64x8 current,
            UInt64x8 toAccumulate) =>
            current - ConvertFrom_ulong(toAccumulate);
        
        /// <summary>
        /// Subtracts an accumulation instance and a more coarse grained value instance.
        /// </summary>
        /// <param name="toAccumulate">The precise accumulation instance.</param>
        /// <param name="current">The value to subtract.</param>
        /// <returns>The accumulated instance.</returns>
        [CLSCompliant(false)]
        public static Float64x8 operator -(
            UInt64x8 toAccumulate,
            Float64x8 current) =>
            ConvertFrom_ulong(toAccumulate) - current;

        /// <summary>
        /// Atomically adds two vectors.
        /// </summary>
        /// <param name="target">The target memory address.</param>
        /// <param name="value">The current value to add.</param>
        [CLSCompliant(false)]
        public static void AtomicAdd(
            ref Float64x8 target,
            UInt64x8 value) =>
            AtomicAdd(ref target, ConvertFrom_ulong(value));

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static Float64x8 ConvertFrom_ulong(
            UInt64x8 other) =>
            new Float64x8((double)other.X, (double)other.Y, (double)other.Z, (double)other.W, (double)other.I, (double)other.J, (double)other.K, (double)other.L);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        private static UInt64x8 ConvertTo_ulong(
            Float64x8 current) =>
            new UInt64x8((ulong)current.X, (ulong)current.Y, (ulong)current.Z, (ulong)current.W, (ulong)current.I, (ulong)current.J, (ulong)current.K, (ulong)current.L);

        /// <summary>
        /// Converts a given coarse-grained value instance into its corresponding
        /// accumulation value.
        /// </summary>
        /// <param name="other">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static Float64x8 IAccumulationVectorType<
            Float64x8,
            UInt64x8,
            ulong>.ConvertFromBase(UInt64x8 other) =>
            ConvertFrom_ulong(other);

        /// <summary>
        /// Converts a given fine-grained value instance into its corresponding
        /// raw value.
        /// </summary>
        /// <param name="current">The value to convert.</param>
        /// <returns>The converted value.</returns>
        static UInt64x8 IAccumulationVectorType<
            Float64x8,
            UInt64x8,
            ulong>.ConvertToBase(Float64x8 current) =>
            ConvertTo_ulong(current);

        /// <summary>
        /// Computes the average while using the provided denominator.
        /// </summary>
        /// <param name="denominator">The denominator to use.</param>
        /// <returns>The computed average.</returns>
        [CLSCompliant(false)]
        public Float64x8 ComputeAverage(ulong denominator) =>
            this / FromScalar((double)denominator);

        /// <summary>
        /// Converts this instance into an unsafe span instance.
        /// </summary>
        /// <returns>The readonly span instance.</returns>
        public unsafe ReadOnlySpan<double> AsSpan() =>
            new(Unsafe.AsPointer(ref Unsafe.AsRef(this)), 8);

        /// <summary>
        /// Iterates over all elements by applying the given iterator to each element.
        /// </summary>
        /// <typeparam name="TIterator">The managed iterator type.</typeparam>
        /// <param name="iterator">The iterator to invoke.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ForEach<TIterator>(ref TIterator iterator)
            where TIterator : struct, IVectorElementIterator<
            Float64x8,
            double>
        {
            iterator.Iterate(X, 0);
            iterator.Iterate(Y, 1);
            iterator.Iterate(Z, 2);
            iterator.Iterate(W, 3);
            iterator.Iterate(I, 4);
            iterator.Iterate(J, 5);
            iterator.Iterate(K, 6);
            iterator.Iterate(L, 7);
        }

        /// <summary>
        /// Converts this vector instance to a string.
        /// </summary>
        public override string ToString() =>
            $"{X}, {Y}, {Z}, {W}, {I}, {J}, {K}, {L}";

        /// <summary>
        /// Converts this vector instance to a string.
        /// </summary>
        public string ToString(string? format, IFormatProvider? formatProvider) =>
            $"{X.ToString(format, formatProvider)}, {Y.ToString(format, formatProvider)}, {Z.ToString(format, formatProvider)}, {W.ToString(format, formatProvider)}, {I.ToString(format, formatProvider)}, {J.ToString(format, formatProvider)}, {K.ToString(format, formatProvider)}, {L.ToString(format, formatProvider)}";

        /// <summary>
        /// Returns true.
        /// </summary>
        public static bool IsCanonical(Float64x8 value) => true;

        /// <summary>
        /// Returns false.
        /// </summary>
        public static bool IsComplexNumber(Float64x8 value) => false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsEvenInteger(Float64x8 value) =>
            double.IsEvenInteger(value.X) & double.IsEvenInteger(value.Y) & double.IsEvenInteger(value.Z) & double.IsEvenInteger(value.W) & double.IsEvenInteger(value.I) & double.IsEvenInteger(value.J) & double.IsEvenInteger(value.K) & double.IsEvenInteger(value.L);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsFinite(Float64x8 value) =>
            double.IsFinite(value.X) & double.IsFinite(value.Y) & double.IsFinite(value.Z) & double.IsFinite(value.W) & double.IsFinite(value.I) & double.IsFinite(value.J) & double.IsFinite(value.K) & double.IsFinite(value.L);

        /// <summary>
        /// Returns false.
        /// </summary>
        public static bool IsImaginaryNumber(Float64x8 value) => false;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsInfinity(Float64x8 value) =>
            double.IsInfinity(value.X) | double.IsInfinity(value.Y) | double.IsInfinity(value.Z) | double.IsInfinity(value.W) | double.IsInfinity(value.I) | double.IsInfinity(value.J) | double.IsInfinity(value.K) | double.IsInfinity(value.L);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsInteger(Float64x8 value) =>
            double.IsInteger(value.X) & double.IsInteger(value.Y) & double.IsInteger(value.Z) & double.IsInteger(value.W) & double.IsInteger(value.I) & double.IsInteger(value.J) & double.IsInteger(value.K) & double.IsInteger(value.L);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNaN(Float64x8 value) =>
            double.IsNaN(value.X) | double.IsNaN(value.Y) | double.IsNaN(value.Z) | double.IsNaN(value.W) | double.IsNaN(value.I) | double.IsNaN(value.J) | double.IsNaN(value.K) | double.IsNaN(value.L);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNegative(Float64x8 value) =>
            double.IsNegative(value.X) & double.IsNegative(value.Y) & double.IsNegative(value.Z) & double.IsNegative(value.W) & double.IsNegative(value.I) & double.IsNegative(value.J) & double.IsNegative(value.K) & double.IsNegative(value.L);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNegativeInfinity(Float64x8 value) =>
            double.IsNegativeInfinity(value.X) | double.IsNegativeInfinity(value.Y) | double.IsNegativeInfinity(value.Z) | double.IsNegativeInfinity(value.W) | double.IsNegativeInfinity(value.I) | double.IsNegativeInfinity(value.J) | double.IsNegativeInfinity(value.K) | double.IsNegativeInfinity(value.L);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsNormal(Float64x8 value) =>
            double.IsNormal(value.X) & double.IsNormal(value.Y) & double.IsNormal(value.Z) & double.IsNormal(value.W) & double.IsNormal(value.I) & double.IsNormal(value.J) & double.IsNormal(value.K) & double.IsNormal(value.L);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsOddInteger(Float64x8 value) =>
            double.IsOddInteger(value.X) & double.IsOddInteger(value.Y) & double.IsOddInteger(value.Z) & double.IsOddInteger(value.W) & double.IsOddInteger(value.I) & double.IsOddInteger(value.J) & double.IsOddInteger(value.K) & double.IsOddInteger(value.L);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsPositive(Float64x8 value) =>
            double.IsPositive(value.X) & double.IsPositive(value.Y) & double.IsPositive(value.Z) & double.IsPositive(value.W) & double.IsPositive(value.I) & double.IsPositive(value.J) & double.IsPositive(value.K) & double.IsPositive(value.L);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsPositiveInfinity(Float64x8 value) =>
            double.IsPositiveInfinity(value.X) | double.IsPositiveInfinity(value.Y) | double.IsPositiveInfinity(value.Z) | double.IsPositiveInfinity(value.W) | double.IsPositiveInfinity(value.I) | double.IsPositiveInfinity(value.J) | double.IsPositiveInfinity(value.K) | double.IsPositiveInfinity(value.L);

        /// <summary>
        /// Returns true.
        /// </summary>
        public static bool IsRealNumber(Float64x8 value) => true;

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsSubnormal(Float64x8 value) =>
            double.IsSubnormal(value.X) & double.IsSubnormal(value.Y) & double.IsSubnormal(value.Z) & double.IsSubnormal(value.W) & double.IsSubnormal(value.I) & double.IsSubnormal(value.J) & double.IsSubnormal(value.K) & double.IsSubnormal(value.L);

        /// <summary>
        /// Evaluates the described predicate.
        /// </summary>
        public static bool IsZero(Float64x8 value) =>
            Abs(value) == Zero;

        /// <summary>
        /// Returns the absolute value.
        /// </summary>
        public static Float64x8 Abs(Float64x8 value) =>
            new Float64x8(Math.Abs(value.X), Math.Abs(value.Y), Math.Abs(value.Z), Math.Abs(value.W), Math.Abs(value.I), Math.Abs(value.J), Math.Abs(value.K), Math.Abs(value.L));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Float64x8 operator +(Float64x8 left, Float64x8 right) =>
            new Float64x8((double)(left.X + right.X), (double)(left.Y + right.Y), (double)(left.Z + right.Z), (double)(left.W + right.W), (double)(left.I + right.I), (double)(left.J + right.J), (double)(left.K + right.K), (double)(left.L + right.L));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Float64x8 operator --(Float64x8 value) => value - One;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Float64x8 operator /(Float64x8 left, Float64x8 right) =>
            new Float64x8((double)(left.X / right.X), (double)(left.Y / right.Y), (double)(left.Z / right.Z), (double)(left.W / right.W), (double)(left.I / right.I), (double)(left.J / right.J), (double)(left.K / right.K), (double)(left.L / right.L));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Float64x8 operator ++(Float64x8 value) => value + One;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Float64x8 operator *(Float64x8 left, Float64x8 right) =>
            new Float64x8((double)(left.X * right.X), (double)(left.Y * right.Y), (double)(left.Z * right.Z), (double)(left.W * right.W), (double)(left.I * right.I), (double)(left.J * right.J), (double)(left.K * right.K), (double)(left.L * right.L));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Float64x8 operator -(Float64x8 left, Float64x8 right) =>
            new Float64x8((double)(left.X - right.X), (double)(left.Y - right.Y), (double)(left.Z - right.Z), (double)(left.W - right.W), (double)(left.I - right.I), (double)(left.J - right.J), (double)(left.K - right.K), (double)(left.L - right.L));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Float64x8 operator -(Float64x8 value) =>
            new Float64x8((double)-value.X, (double)-value.Y, (double)-value.Z, (double)-value.W, (double)-value.I, (double)-value.J, (double)-value.K, (double)-value.L);

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Float64x8 operator +(Float64x8 value) => value;

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Float64x8 MaxMagnitude(Float64x8 x, Float64x8 y) =>
            new Float64x8(double.MaxMagnitude(x.X, y.X), double.MaxMagnitude(x.Y, y.Y), double.MaxMagnitude(x.Z, y.Z), double.MaxMagnitude(x.W, y.W), double.MaxMagnitude(x.I, y.I), double.MaxMagnitude(x.J, y.J), double.MaxMagnitude(x.K, y.K), double.MaxMagnitude(x.L, y.L));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Float64x8 MaxMagnitudeNumber(Float64x8 x, Float64x8 y) =>
            new Float64x8(double.MaxMagnitudeNumber(x.X, y.X), double.MaxMagnitudeNumber(x.Y, y.Y), double.MaxMagnitudeNumber(x.Z, y.Z), double.MaxMagnitudeNumber(x.W, y.W), double.MaxMagnitudeNumber(x.I, y.I), double.MaxMagnitudeNumber(x.J, y.J), double.MaxMagnitudeNumber(x.K, y.K), double.MaxMagnitudeNumber(x.L, y.L));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Float64x8 MinMagnitude(Float64x8 x, Float64x8 y) =>
            new Float64x8(double.MinMagnitude(x.X, y.X), double.MinMagnitude(x.Y, y.Y), double.MinMagnitude(x.Z, y.Z), double.MinMagnitude(x.W, y.W), double.MinMagnitude(x.I, y.I), double.MinMagnitude(x.J, y.J), double.MinMagnitude(x.K, y.K), double.MinMagnitude(x.L, y.L));

        /// <summary>
        /// Performs the specified operation.
        /// </summary>
        public static Float64x8 MinMagnitudeNumber(Float64x8 x, Float64x8 y) =>
            new Float64x8(double.MinMagnitudeNumber(x.X, y.X), double.MinMagnitudeNumber(x.Y, y.Y), double.MinMagnitudeNumber(x.Z, y.Z), double.MinMagnitudeNumber(x.W, y.W), double.MinMagnitudeNumber(x.I, y.I), double.MinMagnitudeNumber(x.J, y.J), double.MinMagnitudeNumber(x.K, y.K), double.MinMagnitudeNumber(x.L, y.L));

        // Not supported operations

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static Float64x8 IParsable<Float64x8>.Parse(
            string s,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static Float64x8 ISpanParsable<Float64x8>.Parse(
            ReadOnlySpan<char> s,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static Float64x8 INumberBase<Float64x8>.Parse(
            ReadOnlySpan<char> s,
            NumberStyles style,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Parses the given string into a vectorized instance.
        /// </summary>
        static Float64x8 INumberBase<Float64x8>.Parse(
            string s,
            NumberStyles style,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        bool ISpanFormattable.TryFormat(
            Span<char> destination,
            out int charsWritten,
            ReadOnlySpan<char> format,
            IFormatProvider? provider) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool IParsable<Float64x8>.TryParse(
            string? s,
            IFormatProvider? provider,
            out Float64x8 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given span into a vectorized instance.
        /// </summary>
        static bool ISpanParsable<Float64x8>.TryParse(
            ReadOnlySpan<char> s,
            IFormatProvider? provider,
            out Float64x8 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool INumberBase<Float64x8>.TryParse(
            ReadOnlySpan<char> s,
            NumberStyles style,
            IFormatProvider? provider,
            out Float64x8 result) =>
            throw new NotSupportedException();

        /// <summary>
        /// Tries to parse the given string into a vectorized instance.
        /// </summary>
        static bool INumberBase<Float64x8>.TryParse(
            string? s,
            NumberStyles style,
            IFormatProvider? provider,
            out Float64x8 result) =>
            throw new NotSupportedException();

        static bool INumberBase<Float64x8>.TryConvertFromChecked<TOther>(
            TOther value,
            out Float64x8 result) =>
            throw new NotSupportedException();
        static bool INumberBase<Float64x8>.TryConvertFromSaturating<TOther>(
            TOther value,
            out Float64x8 result) =>
            throw new NotSupportedException();
        static bool INumberBase<Float64x8>.TryConvertFromTruncating<TOther>(
            TOther value,
            out Float64x8 result) =>
            throw new NotSupportedException();
        static bool INumberBase<Float64x8>.TryConvertToChecked<TOther>(
            Float64x8 value,
            out TOther result) =>
            throw new NotSupportedException();
        static bool INumberBase<Float64x8>.TryConvertToSaturating<TOther>(
            Float64x8 value,
            out TOther result) =>
            throw new NotSupportedException();
        static bool INumberBase<Float64x8>.TryConvertToTruncating<TOther>(
            Float64x8 value,
            out TOther result) =>
            throw new NotSupportedException();
    }

}

#pragma warning restore CA2225
#pragma warning restore IDE0004

#endif